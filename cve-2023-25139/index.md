# CVE 2023 25139

## 0x00 背景
TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这么个东西：
[30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)](https://sourceware.org/bugzilla/show_bug.cgi?id=30068)

## 0x01 分析
这是一个glibc 2.37里短暂出现了一下就被立即修复的漏洞，千位分隔符在格式化输出时没有被正确计算宽度，导致出现了溢出。
修复：
[Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com)](https://github.com/bminor/glibc/commit/c980549cc6a1c03c23cc2fe3e7b0fe626a0364b0)
第266行由
```c
width -= workend - string + prec
```
改成了
```c
width -= number_length + prec_inc
```
这里的width变量为需要添加的字符的宽度。由prec改为prec_inc对这里是毫无影响的，区别在于number_length和workend - string并不等同：(168-182行)
```c
  int number_length;
#ifndef COMPILE_WPRINTF
  if (use_outdigits && base == 10)
    number_length = __translated_number_width (_NL_CURRENT_LOCALE,
                                               string, workend);
  else
    number_length = workend - string;
  if (group)
    number_length += iter.separators * strlen (thousands_sep);
#else
  number_length = workend - string;
  /* All wide separators have length 1.  */
  if (group && thousands_sep != L'\0')
    number_length += iter.separators;
#endif
```
可以看到number_length是原本的数字长度加上千位分隔符的长度，而修改之前的代码没有计算千位分隔符的长度，导致了错误的长度计算。 
```c
if (!left)
    {
      width -= number_length + prec;

      if (number.word != 0 && alt && (base == 16 || base == 2))
        /* Account for 0X, 0x, 0B or 0b hex or binary marker.  */
	@@ -221,7 +227,7 @@ LABEL (unsigned_number):      /* Unsigned number of base BASE.  */
          Xprintf_buffer_putc (buf, spec);
        }

      width += prec;
      Xprintf_buffer_pad (buf, L_('0'), width);

      if (octal_marker)
	@@ -237,6 +243,8 @@ LABEL (unsigned_number):      /* Unsigned number of base BASE.  */
    }
  else
    {
      if (is_negative)
        {
          Xprintf_buffer_putc (buf, L_('-'));
	@@ -263,9 +271,13 @@ LABEL (unsigned_number):      /* Unsigned number of base BASE.  */
      if (octal_marker)
	--width;

      width -= workend - string + prec;
	  ...
	}
```
另外，根据代码可以看出只有左对齐的情况下长度计算是错误的，进行测试：
```c
#include <locale.h>
#include <stdio.h>

int main() {
  if (setlocale(LC_ALL, "en_US.utf8")) {
    printf("1234567890123:\n");
    printf("%+-'13ld:\n", 1234567L);
    printf("%0+'13ld:\n", 1234567L);
  }
  return 0;
}
```
输出：
```c
❯ ./test
1234567890123:
+1,234,567     :
+0001,234,567:
```
确实只有左对齐时结果是错误的，左对齐时由于未减去两个千位分隔符的宽度而多填充了两个空格。
## 0x02 其他
千位分隔符和精度限制同时使用在2.27时就有前导0缺少千位分隔符（我不确定这是不是bug）以及空格的编码长度会影响补0的数量的bug。看来即使是标准库，处理这种东西也很头痛。
[23432 – incorrect printf output for integers with thousands separator and precision field larger than the number of digits (needing leading zeros) (sourceware.org)](https://sourceware.org/bugzilla/show_bug.cgi?id=23432)
