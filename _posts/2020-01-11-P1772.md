---
title: P1772 物流运输
date: 2020-01-11 17:57:51
tags: [最短路,DP]
mathjax: true
layout: post
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P1772) 

## 题解

我们考虑使用DP+最短路.  

用$f(i)$表示前$i$天最小成本,那么可以想到  

$f(i) = min(f(j) + cost(j+1,i)*(i-j) + k),j<i$,其中$cost(j+1,i)$ 表示从第$j+1$天到第$i$天走相同最短路的每天成本.  

$f(i)$初始化为$cost(1,i)*i$,即一直不换路线.  

那么就要考虑如何求出$cost$数组,数据范围很小,所以直接枚举天数然后封住这些天不可用的码头,跑最短路即可.  

最后答案为$f(n)$.  

## 代码

```cpp
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<queue>
#include<stack>
#include<vector>

const int MAXN = 21;
const int MAXD = 101;

struct edge
{
    int u, v;
    long long w;
    edge(int u, int v, long long w) : u(u), v(v), w(w) {}
};
struct node
{
    int u, d;
    node (int u, int d) :u(u), d(d) {}
    bool operator < (const node& rhs) const
    {
        return d > rhs.d;
    }
};
std::vector<edge> G[MAXN];

int closed[MAXN][MAXD];
long long cost[MAXD][MAXD];
int cantvis[MAXN];
long long f[MAXD];
long long dis[MAXN];
int n, m, k, e;

void addEdge(int u, int v, long long w)
{
    G[u].push_back((edge){u,v,w});
    G[v].push_back((edge){v,u,w});
}

void dijkstra()
{
    for (int i = 2;i <= m;i ++) dis[i] = (long long)1e8;
    dis[1] = 0;
    std::priority_queue<node> Q;
    Q.push((node){1,0});
    while (!Q.empty())
    {
        node cur = Q.top();
        Q.pop();
        int u = cur.u, v, d = cur.d;
        if (d != dis[u]) continue;
        for (int i = 0;i < G[u].size();i ++)
        {
            v = G[u][i].v;
            if (cantvis[v]) continue;
            if (dis[u] + G[u][i].w < dis[v])
            {
                dis[v] = dis[u] + G[u][i].w;
                Q.push(node(v, dis[v]));
            }
        }
    }
}

int main()
{
    scanf("%d %d %d %d", &n, &m, &k, &e);
    for (int i = 0;i < e;i ++)
    {
        int u, v;
        long long w;
        scanf("%d %d %lld", &u, &v, &w);
        addEdge(u, v, w);
    }
    int d;
    scanf("%d", &d);
    for (int i = 0;i < d;i ++)
    {
        int p, a, b;
        scanf("%d %d %d", &p, &a, &b);
        for (int j = a;j <= b;j ++)
            closed[p][j] = 1;
    }
    for (int i = 1;i <= n;i ++)
    {
        for (int j = i;j <= n;j ++)
        {
            memset(cantvis, 0, sizeof(cantvis));
            for (int day = i;day <= j;day ++)
                for (int q = 1;q <= m;q ++) if (closed[q][day]) cantvis[q] = 1;
            dijkstra();
            cost[i][j] = dis[m]; 
        }
    }
    memset(f,0x7f,sizeof(f));
    for (int i = 1;i <= n;i ++)
    {
        f[i] = 1LL * (long long)cost[1][i] * (long long)i;
        for (int j = 0;j < i;j ++)
        {
            f[i] = std::min(f[i], f[j] + cost[j+1][i] * (i-j) + 1LL * k);
        }
    }
    printf("%lld", f[n]);
    return 0;
}
```

