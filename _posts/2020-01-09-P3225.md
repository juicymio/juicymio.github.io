---
layout: post
title: P3225 [HNOI2012]矿场搭建
date: 2020-01-09 15:52:43
tags: [tarjan,点双连通分量,割点]
mathjax: true
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P3225)  

## 题意

设置尽量少的救援出口,使任意点坍塌之后其他点都与至少一个救援出口联通.求最少救援出口数和最少救援出口的方案总数  

## 题解

看起来就像连通分量相关的题.首先用Tarjan跑出割点,然后DFS搜索每个被割点分割成的连通块(点双连通分量),统计每个连通块中割点的数目.  

没有:

需要建立两个出口,一个坍塌了就可以去另一个.  

一个:

如果普通点坍塌,则可以走割点到别的连通块或本连通块的出口(如果它未坍塌),如果割点坍塌,则可以走本连通块的出口.所以只需建立一个出口,建立在任意非割点的位置即可.

两个及以上:  

无需建立出口,任一割点坍塌都可以通过另一个割点到达其他连通块.

计算方案数乘法原理即可,具体见代码

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<stack>
#include<vector>
#include<cstring>

const int MAXN = 1000;

std::vector<int> G[MAXN];
int pre[MAXN], low[MAXN], iscut[MAXN], vis[MAXN], dfs_clock;
int dfs(int u, int fa)
{
    int lowu = pre[u] = ++ dfs_clock; // 时间戳
    int child = 0; // 子树个数
    for (int i = 0; i < G[u].size(); i ++)
    {
        int v = G[u][i];
        if (!pre[v]) // v未访问过
        {
            ++ child;
            int lowv = dfs(v, u);
            lowu = std::min(lowu, lowv); // 求出后代的low并更新自己
            if (lowv >= pre[u]) // 没有反向边
            {
                iscut[u] = 1;
            }
        }
        else if (pre[v] < pre[u] && v != fa) // 若v = fa,则是树边的回溯,不是反向边
        {
            lowu = std::min(lowu, pre[v]); // 用反向边更新自己
        }
        if (fa < 0 && child == 1) iscut[u] = 0; // 根至少要两个子树才是割顶
        low[u] = lowu;
    }
    return low[u];
}

int cut, com; // 一个点双连通分量里割点和普通点数目
void block(int u, int color)
{
    vis[u] = color;
    com ++;
    for (int i = 0;i < G[u].size();i ++)
    {
        int v = G[u][i];
        if (iscut[v] && vis[v] != color)
        {
            cut ++;
            vis[v] = color;
        }
        if (!vis[v])
            block(v, color);
    }
    return;
}

void addEdge(int u, int v)
{
    G[u].push_back(v);
}
int main()
{
    int n, m;
    int casenum = 0;

    while (scanf("%d", &m) && m > 0)
    {
        n = 0;
        dfs_clock = 0;
        memset(iscut, 0, sizeof(iscut));
        memset(pre, 0, sizeof(pre));
        memset(vis, 0, sizeof(vis));
        casenum ++;
        int u, v;
        for (int i = 1;i <= 500;i ++)
            G[i].clear();
        for (int i = 1;i <= m;i ++)
        {
            scanf("%d %d", &u, &v);
            addEdge(u, v);
            addEdge(v, u);
            n = std::max(n, v);
            n = std::max(n, u);
        }
        for (int i = 1;i <= n;i ++)
        {
            if(!pre[i]) dfs(i, -1);
        }

        int A = 0;
        int color = 0;
        long long B = 1;

        for (int i = 1;i <= n;i ++)
        {
            if (!vis[i] && !iscut[i])
            {
                color ++;
                cut = com = 0;
                block(i, color);

                if (cut == 0)
                {
                    A += 2;
                    B *= (com - 1) * com / 2;
                }
                else if (cut == 1)
                {
                    A ++;
                    B *= com;
                }
            }
        }
        printf("Case %d: %d %lld\n", casenum, A, B);
    }
    return 0;
}
```

