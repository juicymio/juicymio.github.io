---
layout: post
title: 高精度模板
date: 2019-12-25 22:57:31
tags: [高精度,模板]
---

主体摘抄自[Menci的博客](https://oi.men.ci/bigint-template/)  ,也借鉴了lrj的紫书,部分自行补充

```cpp
#include<cstring>
#include<string>
#include<vector>
#include<cstdio>
#include<iostream>
#include<sstream>

struct BigInt
{
    std::vector<char> v;
    BigInt()
    {
        *this = 0;
    }
    BigInt(int x)
    {
        *this = x;
    }
    BigInt &operator = (int x)
    {
        v.clear();
        do v.push_back(x % 10); while (x /= 10);
        return *this;
    }
    BigInt &operator = (BigInt x)
    {
        v.resize(x.v.size());
        memcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));
        return *this;
    }
    BigInt &operator = (const std::string& str)
    {
        v.clear();
        char x;
        int len = str.length();
        for (int i = len- 1;i >= 0;i --)
        {
            x = str[i] - '0';
            v.push_back(x);
        }
        return *this;
    }
    bool operator < (const BigInt &b) const
    {
        if (v.size() != b.v.size())  return v.size() < b.v.size();
        for (int i = v.size() - 1;i >= 0;i --)
        {
            if(v[i] != b.v[i])
                return (int)v[i] < (int)b.v[i];
        }
    }
};
std::ostream &operator << (std::ostream & out, const BigInt &x)
{
    for(int i = x.v.size() - 1;i >= 0;i --)
        out << (char)(x.v[i] + '0');
    return out;
}
std::istream &operator >> (std::istream & in, BigInt& x)
{
    std::string s;
    if(!(in >> s)) return in;
    x = s;
    return in;   
}
BigInt operator + (const BigInt &a, const BigInt &b)
{
    BigInt result;
    result.v.clear();
    bool flag = false;
    for (int i = 0;i < (int)std::max(a.v.size(), b.v.size());i ++)
    {
        int tmp = 0;
        if (i < (int)a.v.size()) tmp += a.v[i];
        if (i < (int)b.v.size()) tmp += b.v[i];
        if (flag) tmp ++, flag = false;
        if (tmp >= 10) flag = true, tmp -= 10;
        result.v.push_back(tmp);
    }
    if (flag) result.v.push_back(1);

    return result;
} 
BigInt operator - (const BigInt &a, const BigInt &b)
{
    BigInt result;
    result.v.clear();
    bool flag = false;
    for (int i = 0;i < (int)a.v.size();i ++)
    {
        int tmp = a.v[i];
        if(i < (int)b.v.size()) tmp -= b.v[i];
        if(flag) tmp --, flag = false;
        if(tmp < 0) tmp += 10, flag = true;
        result.v.push_back(tmp);
    }

    int size = result.v.size();
    while(size > 1 && result.v[size - 1] == 0) size --;
        result.v.resize(size);
    return result;
}
BigInt operator * (const BigInt &a, const BigInt &b)
{
    BigInt result;
    result.v.resize(a.v.size() + b.v.size());
    for (int i = 0;i < (int)a.v.size();i ++)
    {
        for (int j = 0; j < (int)b.v.size();j ++)
        {
            result.v[i + j] += a.v[i] * b.v[j];
            result.v[i + j + 1] += result.v[i + j] / 10;
            result.v[i + j] %= 10;
        }
    }

    int size = result.v.size();
    while (size > 1 && result.v[size - 1] == 0) size--;
    result.v.resize(size);
    return result;
}

```

