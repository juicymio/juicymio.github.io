---
layout: post
title: tarjan学习笔记
date: 2019-12-19 12:31:04
tags: [tarjan,割顶,强连通分量,点双连通分量]
---

## 代码

1.割顶

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<stack>
#include<cstring>

const int MAXN = 20000+1;

struct Edge
{
    int u, v;
};

int pre[MAXN], iscut[MAXN], low[MAXN], dfs_clock;
std::vector<int> G[MAXN];
std::vector<int> cut;

void addEdge(int u, int v)
{
    G[u].push_back(v);
    G[v].push_back(u);
}

int dfs(int u, int fa)
{
    int lowu = pre[u] = ++ dfs_clock; // 时间戳
    int child = 0; // 子树个数
    for (int i = 0; i < G[u].size(); i ++)
    {
        int v = G[u][i];
        if (!pre[v]) // v未访问过
        {
            ++ child;
            int lowv = dfs(v, u);
            lowu = std::min(lowu, lowv); // 求出后代的low并更新自己
            if (lowv >= pre[u]) // 没有反向边
            {
                iscut[u] = 1;
            }
        }
        else if (pre[v] < pre[u] && v != fa) // 若v = fa,则是树边的回溯,不是反向边
        {
            lowu = std::min(lowu, pre[v]); // 用反向边更新自己
        }
        if (fa < 0 && child == 1) iscut[u] = 0; // 根至少要两个子树才是割顶
        low[u] = lowu;
    }
    return low[u];
}

void find(int n)
{
    memset(pre, 0, sizeof(pre));
    memset(iscut, 0, sizeof(iscut));
    dfs_clock = 0;
    for (int i = 1;i <= n;i ++)
    {
        if(!pre[i]) dfs(i, -1);
    }
}

int main()
{
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 1;i <= m;i ++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(u,v);   
    }
    find(n);
    for (int i = 1;i <= n;i ++)
    {
        if(iscut[i])
        {
            cut.push_back(i);
        }
    }
    printf("%d\n", cut.size());
    for (int i = 0;i < cut.size();i ++)
    {
        printf("%d ", cut[i]);
    }
    return 0;
}
```

2.点双连通分量

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<stack>
#include<cstring>

const int MAXN = 20000+1;

struct Edge
{
    int u, v;
};

int pre[MAXN], iscut[MAXN], bccno[MAXN], dfs_clock, bcc_cnt;
std::vector<int> G[MAXN], bcc[MAXN];

std::stack<Edge> S; // 存储当前BCC中的边

void addEdge(int u, int v)
{
    G[u].push_back(v);
    G[v].push_back(u);
}

int dfs(int u, int fa)
{
    int lowu = pre[u] = ++ dfs_clock; // 时间戳
    int child = 0; // 子树个数
    for (int i = 0; i < G[u].size(); i ++)
    {
        int v = G[u][i];
        Edge e = (Edge){u, v};
        if (!pre[v]) // v未访问过
        {
            S.push(e);
            ++ child;
            int lowv = dfs(v, u);
            lowu = std::min(lowu, lowv); // 求出后代的low并更新自己
            if (lowv >= pre[u]) // 没有反向边
            {
                iscut[u] = true;
                bcc[++ bcc_cnt].clear();
                while (1)
                {
                    Edge x = S.top();
                    S.pop();
                    if (bccno[x.u] != bcc_cnt)
                    {
                        bcc[bcc_cnt].push_back(x.u);
                        bccno[x.u] = bcc_cnt;
                    }
                    if (bccno[x.v] != bcc_cnt)
                    {
                        bcc[bcc_cnt].push_back(x.v);
                        bccno[x.v] = bcc_cnt;
                    }
                    if (x.u == u && x.v == v) break;
                }
            }
        }
        else if (pre[v] < pre[u] && v != fa) // 若v = fa,则是树边的回溯,不是反向边
        {
            S.push(e);
            lowu = std::min(lowu, pre[v]); // 用反向边更新自己
        }
        if (fa < 0 && child == 1) iscut[u] = 0; // 根至少要两个子树才是割顶
    }
    return lowu;
}

void find_bcc(int n)
{
    memset(pre, 0, sizeof(pre));
    memset(iscut, 0, sizeof(iscut));
    memset(bccno, 0, sizeof(bccno));
    dfs_clock = bcc_cnt = 0;
    for (int i = 1;i <= n;i ++)
    {
        if(!pre[i]) dfs(i, -1);
    }
}
int main()
{
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 0;i < m;i ++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        addEdge(u, v);   
    }
}
```



3.tarjan求强连通分量

```cpp
//tarjan
#include<cstdio>
#include<vector>
#include<algorithm>
#include<iostream>
#include<stack>
#include<cstring>

const int MAXN = 10000+10;

std::stack<int> S;
std::vector<int> G[MAXN];
int pre[MAXN], lowlink[MAXN], sccno[MAXN], out[MAXN],size[MAXN], dfs_clock, scc_cnt;

void dfs(int u)
{
    pre[u] = lowlink[u] = ++ dfs_clock;
    S.push(u);
    for (int i = 0; i < G[u].size(); ++ i)
    {
        int v = G[u][i];
        if(!pre[v])
        {
            dfs(v);
            lowlink[u] = std::min(lowlink[u], lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u] = std::min(lowlink[u], pre[v]);
        }
    }
    if(lowlink[u] == pre[u])
    {
        scc_cnt ++;
        while(1)
        {
            int x = S.top();
            S.pop();
            sccno[x] = scc_cnt;
            size[sccno[x]] ++;
            if(x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    dfs_clock = scc_cnt = 0;
    memset(sccno, 0, sizeof(sccno));
    memset(pre, 0, sizeof(pre));
    for(int i = 1;i <= n;i ++)
        if(!pre[i]) dfs(i);
}

int main()
{
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i = 0;i < m;i ++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        G[u].push_back(v);
    }
    find_scc(n);
    int num = 0, ans;
    for(int i = 1; i <= n; i ++)
    {
        for(int j = 0; j < G[i].size(); j ++)
        {
            if(sccno[G[i][j]] != sccno[i])
                out[sccno[i]] ++;
        }
        
    }
    for(int i = 1;i <= scc_cnt;i ++)
    {
        if(!out[i])
        {
            ans = i;
            num ++;
        }
    }
    if(num == 1)
    {
        printf("%d\n", size[ans]);
    }
    else
    {
        printf("0\n");
    }
    return 0;
}
```

