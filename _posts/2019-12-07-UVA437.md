---
post: layout
title: UVA437 巴比伦塔
date: 2019-12-07 15:37:30
tags: [DP,DAG上的最短路] 
mathjax: true
---

用$n$ 种长方体堆出一座塔,每种长方体有无限个,当一个长方体的底面严格小于另一个长方体的底面时(可以选择任意一个面作为底面),这个长方体可以放在另一个长方体上面.求建出的塔的最大高度.

## 题解

存储一种长方体的三种摆放方式,将一种长方体 $i$ (之前的一种长方体现在变成了三种)可以放在另一种长方体 $j$ 上面记为从  $i$ 向 $j$ 连一条边权为$i$的高度的有向边,则原问题可转换为DAG上的最长路求解  

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>

const int N = 50;

int read()
{
    char c;
    int f=1,ans=0;
    do {c=getchar(); if (c=='-')f=-1; } while (c<'0'||c>'9');
    do {ans=(ans << 3)+(ans<<1)+c-'0'; c=getchar(); } while (c>='0'&&c<='9');
    return f * ans;
}

int dp[3*N];
int brick[3*N][3];
int n;

int d(int i)
{
    int& ans = dp[i];
    if(ans > 0)
         return ans;
    ans = brick[i][2];
    for(int j = 1;j <= 3 * n;j ++)
    {
        if((brick[i][0] < brick[j][0] && brick[i][1] < brick[j][1])\
         || (brick[i][0] < brick[j][1] && brick[i][1] < brick[j][0]))
        {
            ans = std::max(ans,d(j) + brick[i][2]);
        }
    }
    return ans;
}

int main()
{
    int kase = 0;
    while (n = read())
    {
        memset(brick,0,sizeof(brick));
        memset(dp,0,sizeof(dp));
        int a[3];
        for(int i = 1;i <= 3 * n;i += 3)
        {
            a[0] = read(),a[1] = read(),a[2] = read();
            brick[i][0] = a[0], brick[i][1] = a[1], brick[i][2] = a[2];
            brick[i+1][0] = a[1], brick[i+1][1] = a[2], brick[i+1][2] = a[0];
            brick[i+2][0] = a[2], brick[i+2][1] = a[0], brick[i+2][2] = a[1];
        }
        
        int finalans = -1;
        for(int i = 1;i <= 3 * n;i ++)
        {
            finalans = std::max(finalans,d(i));
        }

        printf("Case %d: maximum height = %d\n",++ kase,finalans);
    }
    return 0;
}

```



 