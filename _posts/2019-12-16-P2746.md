---
layout: post
title: P2746 [USACO5.3]校园网
date: 2019-12-16 22:15:34
tags: [Tarjan,缩点]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P2746)  

## 题解

子任务A: 容易看出答案即为缩点之后入度为0的点的数目,特判当只有一个时输出1(至少需要分发一个).   

子任务B: 把缩点之后的图连成强连通图,那么所有的点入度和出度都至少为1,则还需连的边为入度为0的点数和出度为0的点数中较大的那个.匹配策略为先匹配较小的,剩下的只要随意连上即可.

## 代码

```cpp
#include<cstdio>
#include<vector>
#include<stack>

const int MAXN = 100+1;

std::stack<int> S;
std::vector<int> G[MAXN], G_scc[MAXN];
int pre[MAXN], lowlink[MAXN], sccno[MAXN], in[MAXN], out[MAXN], scc_cnt, dfs_clock; 

void dfs(int u)
{
    pre[u] = lowlink[u] = ++ dfs_clock;
    S.push(u);
    for (int i = 0;i < G[u].size();i ++)
    {
        int v = G[u][i];
        if (!pre[v])
        {
            dfs(v);
            lowlink[u] = std::min(lowlink[u],lowlink[v]);
        }
        else if (!sccno[v])
        {
            lowlink[u] = std::min(lowlink[u],pre[v]);
        }
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt ++;
        int x;
        while (1)
        {
            x = S.top();
            S.pop();
            sccno[x] = scc_cnt;
            if (x == u)
                break;
        }
    }
}

void find_scc(int n)
{
    for (int i = 1;i <= n;i ++)
    {
        if(!pre[i]) dfs(i);
    }
}
int main()
{
    int n;
    scanf("%d", &n);
    int v;
    for (int i = 1; i <= n; i ++)
    {
        while (scanf("%d", &v) && v != 0)
        {
            G[i].push_back(v);
        }
    }

    find_scc(n);

    for (int u = 1; u <= n; u ++)
    {
        for(int i = 0; i < G[u].size(); i ++)
        {
            int v = G[u][i];
            if(sccno[v] != sccno[u])
            {
                G_scc[sccno[u]].push_back(sccno[v]);
                in[sccno[v]] ++;
                out[sccno[u]] ++;
            }
        }
    }

    int Acnt = 0,Bcnt = 0;
    for (int i = 1;i <= scc_cnt;i ++)
    {
        if(!in[i])
            Acnt ++;
        if(!out[i])
            Bcnt ++;
    }
    if(scc_cnt == 1)
    {
        printf("%d\n%d\n",1,0);
        return 0;
    }
    printf("%d\n%d\n", Acnt == 0 ? 1 : Acnt, std::max(Acnt,Bcnt));
    return 0;
}
// 小心只有一个强连通分量
```

