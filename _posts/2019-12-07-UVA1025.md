---
layout: post
title: UVA1025 城市里的间谍
date: 2019-12-07 15:49:18
tags: [DP]
mathjax: true
---

## 链接

[A spy in the metro](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3466)  

[Luogu](https://www.luogu.com.cn/problem/UVA1025)

## 题解

时间单向流逝,所以可以直接按时间倒序DP,每一秒有三种决策:上左边的车,上右边的车,等车,从中取最小值.

关于实现,可以简单地预处理出每秒有没有车.

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<climits>
#include<cstring>

int read()
{
    char c;
    int f = 1,ans = 0;
    do
    {
        /* code */
        c = getchar();
        if(c == '-')
            f = -1;
    } while (c < '0' || c > '9');
    do
    {
        /* code */
        ans = (ans << 3) + (ans << 1) + c - '0';
        c = getchar();
    } while (c >= '0' && c <= '9');
    return f * ans;
}

const int N = 200+10;
const int MAXT = 200+10;
int time[N];
int train[MAXT][N][2];//t时刻i站是否有向左/右的车
int dp[MAXT][N];
int main()
{
    int n,M1,M2,T,kase = 0;
    while(n = read())
    {
        memset(dp,0,sizeof(dp));
        memset(time,0,sizeof(time));
        memset(train,0,sizeof(train));
        T = read();
        for (int i = 1;i < n;i ++)
        {
            time[i] = read();
        }
        M1 = read();
        for (int i = 1;i <= M1;i ++)
        {
            int t = read();
            for (int j = 1;j < n;j ++)
            {
                train[t][j][0] = 1;
                t += time[j];    
            }
        }
        M2 = read();
        for (int i = 1;i <= M2;i ++)
        {
            int t =read();
            for (int j = n - 1;j > 0;j --)
            {
                train[t][j + 1][1] = 1;
                t += time[j];
            }
        }
        for (int i = 1;i < n;i ++)
        {
            dp[T][i] = 0x3f3f3f3f;
        }
        dp[T][n] = 0;
        for(int i = T - 1;i >= 0;i --)
        {
            for(int j = 1;j <= n;j ++)
            {
                dp[i][j] = dp[i+1][j] + 1;
                if(j < n && train[i][j][0] && i + time[j] <= T)
                    dp[i][j] = std::min(dp[i][j],dp[i+time[j]][j+1]);
                if(j > 1 && train[i][j][1] && i + time[j-1] <= T)
                    dp[i][j] = std::min(dp[i][j],dp[i+time[j-1]][j-1]);
            }
        }
        printf("Case Number %d: ", ++ kase);
        if(dp[0][1] >= 0x3f3f3f3f)
            printf("impossible\n");
        else
            printf("%d\n",dp[0][1]);
    }
    return 0;
}
```

