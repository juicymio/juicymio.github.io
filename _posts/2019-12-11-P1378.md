---
title: P1378 油滴扩展
date: 2019-12-11 14:09:24
tags: [搜索,DFS]
layout: post
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P1378)

## 题解

直接爆搜即可,每次放点的时候判断半径设为其他油滴相切或与边界相切(当然取最小值),放完所有点时更新最小值即可.

## 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>

const double PI = 3.1415926535898;
int read()
{
    char c;
    int f = 1,ans = 0;
    do
    {
        c = getchar();
        if(c == '-')
            f = -1;
    } while (c < '0' || c > '9');
    do
    {
        ans = (ans << 3) + (ans << 1) + c - '0';
        c = getchar();
    } while (c <= '9' &&  c >= '0');
    return f * ans;
}

struct node
{
    int x, y, r;
    node(int r = 0) : r(r) {}
} nodes[100];

double rad[100];
int n;
double mins = 10000000.0;
int vis[100];

double dist(node a,node b)
{
    return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}
double s(int i)
{
    double r = 100000000.0;
    for (int j = 2;j < n+2;j ++)
    {
        if(vis[j] && j != i)
        {
            r = std::min(r,std::max(dist(nodes[i],nodes[j])-rad[j],0.0));
        }
    }
    r = std::min(r,(double)std::abs(nodes[0].x-nodes[i].x));
    r = std::min(r,(double)std::abs(nodes[1].x-nodes[i].x));
    r = std::min(r,(double)std::abs(nodes[0].y-nodes[i].y));
    r = std::min(r,(double)std::abs(nodes[1].y-nodes[i].y));
    rad[i] = r;
    return PI*r*r;
}
void dfs(int k,double rest)
{
    if(k > n - 1)
    {
        //printf("%f %f\n",mins,rest);
        mins = std::min(mins,rest);
        return;
    }
    for(int i = 2;i < n + 2;i ++)
    {
        if(vis[i])
            continue;
        vis[i] = 1;
        dfs(k+1,rest-s(i));
        vis[i] = 0;
    }
}

int main()
{
    n = read();
    nodes[0].x = read(),nodes[0].y = read();
    nodes[1].x = read(),nodes[1].y = read();
    double S = std::abs((nodes[1].x-nodes[0].x)*(nodes[1].y-nodes[0].y));
    for(int i = 2;i < n + 2;i ++)
    {
        nodes[i].x = read();
        nodes[i].y = read();
    }
    dfs(0,S);
    int ans = mins+0.5;
    printf("%d", ans);
    return 0;
}
```

