---
layout: post
title: P2055 [ZJOI2009]假期的宿舍
date: 2019-12-27 13:26:12
tags: [二分图匹配,匈牙利算法]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P2055)  

## 题解

看起来是二分图最大匹配.需要床的人跟床匹配,直接套用匈牙利算法,当有人匹配不到床的时候输出T_T.  

多组数据记得清空数组.

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>

const int MAXN = 50 + 1;

bool G[MAXN][MAXN];
bool vis[MAXN];
int left[MAXN];
bool holiday[MAXN];
bool stu[MAXN];
int n;

bool dfs(int x)
{
    for (int i = 1;i <= n;i ++)
    {
        if (G[x][i] && !vis[i])
        {
            vis[i] = 1;
            if (!left[i] || dfs(left[i]))
            {
                left[i] = x;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T --)
    {
        memset(left, 0, sizeof(left));
        memset(G,0,sizeof(G));
        memset(stu, 0, sizeof(stu));
        memset(holiday, 0, sizeof(holiday));
        int cnt;
        scanf("%d", &n);
        cnt = n;
        int is;
        for (int i = 1;i <= n;i ++)
        {
            scanf("%d", &is);
            stu[i] = is;
        }
        for (int i = 1;i <= n;i ++)
        {
            scanf("%d", &is);
            holiday[i] = stu[i] && is;
            cnt -= holiday[i];
        }
        for (int i = 1;i <= n;i ++)
        {
            for (int j = 1;j <= n;j ++)
            {
                scanf("%d", &is);
                G[i][j] = (is || (i == j && !holiday[j])) && stu[j];
            }
        }
        bool flag = true;
        for (int i = 1;i <= n;i ++)
        {
            memset(vis,0,sizeof(vis));
            if (!holiday[i] && !dfs(i))
            {
                flag = false;
                printf("T_T\n");
                break;
            } 
        }
        if (flag)
            printf("^_^\n");
    }
}
```



 