---
layout: post
title: P1084 [SCOI2005]扫雷
date: 2020-01-29 08:02:51
tags: [递推]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P2327)  

[bzoj](https://www.lydsy.com/JudgeOnline/problem.php?id=1088)

## 题解

只可能有三种情况:

0: 不合法  

1: 有唯一情况  

2: 有两种情况,分别是第一个有雷和第一个没有雷  

然后由第$i-1$个的数字和第$i-1$,$i-2$的雷,可以判断第i个雷的情况

由上可知只要确定第一个之后直接递推一遍即可

## 代码

```cpp
//抄了老K
#include<cstdio>
#include<algorithm>
#include<cstring>
int a[10000 + 5];
int b[10000 + 5];

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1;i <= n;i ++) scanf("%d", &a[i]);
    int cnt = 0;
    int flag = 1;
    b[1] = 0;
    for (int i = 2;i <= n + 1;i ++)
    {
        b[i] = a[i - 1] - b[i - 1] - b[i - 2];
        if (b[i] < 0 || b[i] > 1)
        {
            flag = 0;
            break;
        }
    }
    if (b[n + 1]) flag = 0;
    cnt += flag;
    memset(b, 0, sizeof(b));
    b[1] = 1;
    flag = 1;
    for (int i = 2;i <= n + 1;i ++)
    {
        b[i] = a[i - 1] - b[i - 1] - b[i - 2];
        if (b[i] < 0 || b[i] > 1)
        {
            flag = 0;
            break;
        }
    }
    if (b[n + 1]) flag = 0;
    cnt += flag;
    printf("%d\n", cnt);
    return 0;
}
```

