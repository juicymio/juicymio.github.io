---
layout: post
title: 浅谈算法之Kruskal
date: 2018-12-15 17:13:00
tags: [最小生成树,Kruskal,数据结构]
mathjax: true
---

Kruskal是一种被广泛使用的最小生成树算法，其实质为一种贪心算法。相比Prim来说，比较好写，用的人也比较多。 
首先我们需要知道最小生成树是个什么东西。

最小生成树
严格定义可以自己百度，通俗来讲就是连通所有节点的总权值最小的树，或者说所有边权和最小的生成树，所以“最小生成树”应是“最小权重生成树”的简称。 
显然，非连通图中是没有最小生成树的。

算法过程
将边按边权从小到大排序，从权值最小的边开始，依次将边加入，如果某条边所连接的两个点已经连通，也就是加入该边后会形成环，则跳过这条边，直至加入(结点数-1)条边。

算法证明
首先感性理解下，在两个点已经连通的情况下，再加入连接这两条边的点的唯一作用就是凭空增加边权，所以不需要加该边。

>证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。
>
>基础：对于算法刚开始时，显然成立（最小生成树存在）。
>
>归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。
>
>如果 $e$ 属于 $T$，那么成立。
>
>否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。
>
>首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取。
>
>然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。
>
>所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。

引用内容摘自OI-wiki


算法具体实现
根据上述过程，我们可以知道，需要的操作有判断两个点是否连通，朴素做法为O(n^2)的BFS，显然过慢。而且还需要连边，于是我们就想到了一个数据结构：并查集 
通过并查集，就可以做到查询两个点是否在同一棵树中和连接两棵树这些操作了。 
1. 读入后，对边按边权从小到大进行排序，下面代码中用的是结构体快排。 
2. 遍历排序后存边的数组，如果目前考虑的边的两个结点已经连通（处于同一个集合里），则跳过这条边考虑下一条。否则将这条边加入已选边中（即为将这条边的两个结点所在集合合并）。 
3. 当选择（结点数-1）条边时结束，此时已选边集合内为一颗最小生成树。 
4. 如果有空我会补图（我会持续咕咕咕的。

代码
(直接把我LuoguP3366的AC代码拿过来了。
```cpp
#include<cstdio>
#include<algorithm>
using std::sort;
const int MAXN = 5000 + 10;
const int MAXM = 200000 + 10;
struct edge
{
    int u,v,w;//u,v是两个点，w是边权
};edge E[MAXM];
bool cmpe(edge a,edge b)
{
    return a.w < b.w;
}
int n,m,tot;
int uset[MAXN];
void makeSet(int n)
{
    for(int i = 1;i <= n;i ++)
        uset[i] = i;
    return;
}
int find(int x)
{
    if(uset[x] != x)
        uset[x] = find(uset[x]);
    return uset[x];
}
void unionSet(int x,int y)
{
    x = find(x),y = find(y);
    uset[y] = x;
}
void kruskal(int i,int num)
{
    if(num == n-1)
        return;
    if(i > m)
    {   
        tot = -1;
        return;
    }
    if(find(E[i].u) == find(E[i].v))
    {
        kruskal(i+1,num);
        return;
    }
    else
    {
        unionSet(E[i].u,E[i].v);
        tot += E[i].w;
        kruskal(i+1,num+1);
    }
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    makeSet(n);
    for(int i = 1;i <= m;i ++)
    {
        scanf("%d%d%d",&E[i].u,&E[i].v,&E[i].w);
    }
    sort(E+1,E+m+1,cmpe);
    kruskal(1,0);
    if(tot == -1)
    printf("orz");
    else
    printf("%d",tot);
    return 0;
}
```