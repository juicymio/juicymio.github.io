---
layout: post
title: P1514 引水入城
date: 2019-12-10 23:28:53
tags: [BFS,DP,搜索]
mathjax: true
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P1514)

## 题解

由第一排向最后一排DFS/BFS,记录第一排每个城市所能拓展到的干旱区城市的最左,最右端,第 $i$ 个城市用 $l[i],r[i]$ 表示.   

先判断是否所有干旱区的城市都能建有水利设施,如果不是则直接输出0,再扫一遍有几个城市没有.

如果所有的都能,那么需要求蓄水厂的最小值  

这里有一个结论:若所有干旱区城市都能建有水利设施,那么上面记录的第一排城市能扩展的干旱区城市一定是连续一个区间的,因为如果它不是连续的,那么中间断开的城市一定比它左右两个城市的引水路径中间的城市都高,那它就被封闭起来了,也就无法得到水,与所有干旱区城市都能建有水利设施的假设不符.

于是转换为了区间覆盖,可DP求解,用 $d(i)$ 表示覆盖前 $i$ 个干旱区城市需多少蓄水厂.

边界,最左端的线段覆盖的城市需要的蓄水厂数显然为1  

$d(k) = 1,l[i]=0,l[i]<=k<=r[i]$

状态转移方程  

$d(i)= min(d(i),d(l[j]-1)+1),l[j]<=i,r[j]>=i$   

有个优化就是在搜索开始之前如果这个点已经被搜过了,那就不用搜了(后面走的一定跟之前一样).

## 代码

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>

const int MAXN = 500;
const int MAXM = 500;

int read()
{
    char c;
    int f=1,ans=0;
    do {c=getchar(); if (c=='-')f=-1; } while (c<'0'||c>'9');
    do {ans=(ans << 3)+(ans<<1)+c-'0'; c=getchar(); } while (c>='0'&&c<='9');
    return f * ans;
}

int dir[4][2] = { {1,0},{0,1},{-1,0},{0,-1} };
int h[MAXN][MAXM];
int vis[MAXN][MAXM];
int l[MAXM],r[MAXM];
int d[MAXM];
int n, m;

struct node
{
    int x, y;
    node(int x = 0,int y = 0) : x(x), y(y) {}
};

bool bfs(node s)
{
    std::queue<node> Q;
    Q.push(s);
    vis[s.x][s.y] = s.y+1;
    node cur;
    while (!Q.empty())
    {
        cur = Q.front();
        Q.pop();
        int& x = cur.x,y = cur.y;
        for (int i = 0;i < 4;i ++)
        {
            int dx = x + dir[i][0];
            int dy = y + dir[i][1];
            if (dx < 0 || dx >= n || dy < 0 || dy >= m)
                 continue;
            if (h[dx][dy] < h[x][y] && vis[dx][dy] != s.y+1)
            {
                vis[dx][dy] = s.y+1;
                Q.push(node(dx,dy));
            }
        }
    }
    for (int i = 0;i < m;i ++)
    {
        if (vis[n-1][i] == s.y+1)
        {
            l[s.y] = i;
            break;
        }
    }
    for (int i = m - 1;i >= 0;i --)
    {
        if (vis[n-1][i] == s.y+1)
        {
            r[s.y] = i;
            break;
        }
    }
        
}
int main()
{
    scanf("%d %d", &n, &m);
    for (int i = 0;i < n;i ++)
        for (int j = 0;j < m;j ++)
            h[i][j] = read();

    memset(l,-1,sizeof(l));
    for (int i = 0;i < m;i ++)
    {
        if(!vis[0][i])
            bfs(node(0,i));
    }
    bool flag = true;
    int num = 0;
    for (int i = 0;i < m;i ++)
    {
        if (!vis[n-1][i])
        {
            flag = false;
            num ++;
        }
    }

    if (flag)
    {
        printf("1\n");
        memset(d,0x3f,sizeof(d));
        for (int i = 0;i < m;i ++)
        {
            if (l[i] == 0)
            {
                for (int j = l[i];j <= r[i];j ++)
                {
                    d[j] = 1;
                }
            }
        }
        for (int i = 0;i < m;i ++)
        {
            for (int j = 0;j < m;j ++)
            {
                if(l[j] > 0 && l[j] <= i && r[j] >= i)
                {
                    d[i] = std::min(d[i],d[l[j]-1]+1);
                }
            }
        }
        printf("%d\n",d[m-1]);
    }
    else
    {
        printf("0\n%d\n",num);
    }
    
    return 0;
}
```

