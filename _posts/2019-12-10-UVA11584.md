---
layout: post
title: UVA11584 划分成回文串
date: 2019-12-10 13:17:27
tags: [DP]
mathjax: true
---

输入一个完全由小写字母构成的字符串,把它划分成尽量少的回文串,输出最小的**回文串个数**

## 链接

[Luogu](https://www.luogu.com.cn/problem/UVA11584)  

[Uva](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2631)  

## 题解

用$d(i)$表示 $0$~$i$ 划分成的最小回文串的个数,那么初始值可设为最差情况,即为字符 $i$ 自己为一个回文串,$d(i) = d(i-1)+1$.

用一个布尔数组 $isPal(i)(j)$ 表示从 $i$ 到 $j$ 是一个回文串

状态转移方程为  

$d(i) = d(j-1)+1 ,j < i,isPal(j)(i)$   

现在考虑如何判断回文串,如果每次状态转移的时候都判断一次,时间复杂度会达到$O(n^3)$  

那么需要预处理回文串,可使用动态规划法,易知初始值为

$isPal(i)(i) = 1$

$isPal(i-1)(i)=1,s[i-1]=s[i](处理偶数长度的回文串)$

状态转移方程为

$isPal(i)(j) = isPal(i+1)(j-1),i<j-1,s[i]=s[j]$  

$isPal(i)(j)=false,s[i]!=s[j]$  

## 代码

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<iostream>

const int MAXN = 1000+1;

bool is_pal[MAXN][MAXN];
int d[MAXN];
int read()
{
    char c;
    int f = 1,ans = 0;
    do
    {
        c = getchar();
        if(c == '-') f = -1;
    } while (c < '0' || c > '9');
    do
    {
        ans = (ans << 3) + (ans << 1) + c - '0';
        c = getchar();
    } while (c <= '9' && c >= '0');
    return f * ans;
}

void judge(std::string& s,int len)
{
    /*
    for(int i = 0;i < len;i ++)
    {
        is_pal[i][i] = true;
        for(int l = 0;(i - l >= 0) && (i + l < len);l ++)
        {
            if(s[i-l] == s[i+l])
                is_pal[i-l][i+l] = true;
        }
    }*/
    for(int i = 0;i < len;++ i)
        {
            is_pal[i][i] = true;
            is_pal[i-1][i] = (s[i-1] == s[i]);
        }
    for(int j = 1;j < len;++ j)
    {
        for(int i = 0;i < j - 1;++ i)
        {
            if(s[i] == s[j])
                is_pal[i][j] = is_pal[i+1][j-1];
            else is_pal[i][j]=false;
        }
    }
}

int main()
{
    int T = read();
    while (T --)
    {
        memset(is_pal,0,sizeof(is_pal));
        memset(d,0,sizeof(d));
        std::string s;
        std::cin >> s;
        int len = s.length();
        judge(s,len);
        d[0] = 1;
        for (int i = 0;i < len;i ++)
        {
            if(i > 0)
                d[i] = d[i-1] + 1;
            for(int j = 0;j < i;j ++)
            {
                if(is_pal[j][i])
                    d[i] = std::min(d[i],d[j-1] + 1);
            }
        }
        printf("%d\n",d[len-1]);
    }
}
```

