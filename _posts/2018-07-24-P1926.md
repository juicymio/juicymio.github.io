---
layout: post
title: P1926 小书童刷题大军
date: 2018-07-24 18:39:46
tags: [搜索]
mathjax: true
---

**第一次发题解**

这题本蒟蒻纠结了好久,第一眼看上去像个01背包,但是我弱,我不会背包啊!于是我瞄了一眼数据范围,小的可怕2333,怪不得是橙题(那我还做那么久

暴搜显然能过,于是我调了一个小时的暴搜...

这两个东西怎么搜?把最短做完作业的时间搜出来再搜剩下时间能做多少题目？好像有点复杂了，后来分析一下，发现作业跟题目没有什么本质上的区别，只不过一个可以加题数，一个可以加分数。而本题要的又是保证分数的情况下要最大题数（这可不太好，有点本末倒置吧2333

所以可以把它们放在一起搜，就好写多了(主观认为

```cpp
#include<iostream>
#include<cstdio>
#define mian main
int a[1000][2];
int n,m,k,r;
int tot = 0,max = -1;
void dfs(int step,int t,int g)//step通常用于控制当前要选择的元素 t时间 g分数
{   
    if(step < n+m)//只要选择没有做完（确定每个元素选或不选
    {
        if(t-a[step][0] >= 0)  //如果选了还没超时
        {   
            if(step < n)//如果选到的是题（因为题存在a[0]~a[n-1],则刷题数+1
            tot ++;                                         
            dfs(step+1,t-a[step][0],g+a[step][1]);//选
            if(step < n)//如果之前加过了，还要在出口减回来
            tot --;
        }
        dfs(step+1,t,g);//当然可以不做这道题/作业
    }
    else
    {
        if(g>=k && t>=0)//及格并且没有超时
            max = std::max(max,tot);
        //tot = 0;这个地方为什么不能清0，因为回溯还要用到
                //而且之前选了之后递归的出口已经减回去了（这个地方我调了好久
        return;
    } 
    return;
}
int mian()
{
    scanf("%d%d%d%d",&n,&m,&k,&r);
    for(int i = 0;i < n+m; i++)//放在一起存
    {
        scanf("%d",&a[i][0]);
    }
    for(int i = n;i < n+m;i ++)//从n往后就是有分数的作业
    {
        scanf("%d",&a[i][1]);
    }
    dfs(0,r,0);//数组是从0从开始存放的，所以step也从0开始（个人习惯而已
    printf("%d",max);
    return 0; 
    //拒绝抄袭，从我做起
    //话说真的有人会抄我这么丑的代码吗（逃
}

```
