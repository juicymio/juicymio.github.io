---
layout: post
title: UVA1625 颜色的长度
date: 2019-12-11 16:49:33
tags: [DP]
---

## 链接

[UVA](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4500)  

[Luogu](https://www.luogu.com.cn/problem/UVA1625)  

## 题解

主要参照紫书思路

$f(i)(j)$ 表示第一个串移走 $i$ 个,第二个串移走 $j$ 个的最小代价.该状态定义类似最长公共子序列.  

$d(i)(j)$ 表示第一个串移走 $i$ 个,第二个串移走 $j$ 个时所有 $L(c)$ 的和.

易知状态转移方程为

$f(i)(j)=min(f(i-1)(j)+d(i-1)(j),f(i)(j-1)+d(i)(j-1))$

边界$f(0)(0)=0$

然后想办法求$d(i)(j)$

记录每个颜色第一次和最后一次出现的位置,每次取出一个字符时判断是否是第一个或最后一个,据此更新.  

然后我写完T飞,改了许多次,最后没办法打开题解对着改,仍然T飞.把$f$数组的memset删了改到dp循环内部赋值之后,A了.

**启示:不要对整个数组乱用memset**

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<iostream>

int f[5000+1][5000+1];
int d[5000+1][5000+1];
int first[2][27];
int last[2][27];
int main()
{
    int T = 0;
    scanf("%d",&T);
    while(T --)
    {
        //memset(f,0x3f,sizeof(f));
        memset(first,0x3f,sizeof(first));
        memset(last,-1,sizeof(last));
       char s1[5000+1],s2[5000+1];
       scanf("%s", s1+1);
       scanf("%s", s2+1);
       int l1 = strlen(s1 + 1);
       int l2 = strlen(s2 + 1);
        d[0][0] = f[0][0] = 0;
        for (int i = 0;i < 26;i ++)
        {
            for (int j = 1;j <= l1;j ++)
            {
                if (s1[j]-'A' == i)
                {
                    first[0][i] = j;
                    break;
                }
            }
            for(int j = 1;j <= l2;j ++)
            {
                if(s2[j] - 'A' == i)
                {
                    first[1][i] = j;
                    break;
                }
            }
            for (int j = l1;j > 0;j --)
            {
                if(s1[j] - 'A' == i)
                {
                    last[0][i] = j;
                    break;
                }
            }
            for(int j = l2;j > 0;j --)
            {
                if(s2[j] - 'A' == i)
                {
                    last[1][i] = j;
                    break;
                }
            }
        }

        for(int i = 0;i <= l1;i ++)
        {
            for(int j = 0;j <= l2;j ++)
            {
                if(i == 0 && j == 0)
                    continue;
                f[i][j] = 0x3f3f3f3f;
                if(i > 0)
                {
                    f[i][j] = std::min(f[i][j],f[i-1][j]+d[i-1][j]);
                    d[i][j] = d[i-1][j];
                    
                    if(i == first[0][s1[i]-'A'] && j < first[1][s1[i]-'A'])
                        d[i][j] ++;
                    if(i == last[0][s1[i]-'A'] && j >= last[1][s1[i]-'A'])
                        d[i][j] --;
                        
                }
                if(j > 0)
                {
                    f[i][j] = std::min(f[i][j],f[i][j-1]+d[i][j-1]);
                    d[i][j] = d[i][j-1];
                    
                    if(i < first[0][s2[j]-'A'] && j == first[1][s2[j]-'A'])
                        d[i][j] ++;
                    if(i >= last[0][s2[j]-'A'] && j == last[1][s2[j]-'A'])
                        d[i][j] --;
                }
            }
        }

        printf("%d\n",f[l1][l2]);
    }
    return 0;
}
```

