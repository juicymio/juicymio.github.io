---
title: UVA116 单向TSP
date: 2019-12-07 15:16:02
tags: [DP]
mathjax: true
---

给定一个 $m$ 行 $n$ 列的整数矩阵,从第一列任何一个位置出发每次往右,右上,右下走一格,最终到达最后一列任意位置.要求经过的整数之和最小.整个矩阵是环形的,即第一行的上一行是最后一行,最后一行的下一行是第一行.输出路径上每列的行号.多解时输出字典序最小的.

## 题解

用$a(i,j)$表示矩阵中的数, $d(i,j)$ 表示当位于 $(i,j)$ 时到最后一列需要经过的整数之和的最小值.  

根据题意, $d(i,j)$ 可从 $d(i+1,j+1)$,$d(i,j+1)$,$d(i-1,j+1)$. 转移来 

其中当 $i=1$ 时 $i-1=m$,当$i=m$时$i+1=1$

状态转移方程为  

$d(i,j)=min(d(i+1,j+1),d(i,j+1),d(i+1,j+1))+a(i,j)$

根据定义易知边界为$d(i,n) = a(i,n)$

因为要输出路径,所以再开一个数组记录$(i,j)$的下一个点,具体见代码  

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>

const int M = 20;
const int N = 200;
const int INF = 0x3f3f3f3f;

int read()
{
    char c;
    int f=1,ans=0;
    do {c=getchar(); if (c=='-')f=-1; } while (c<'0'||c>'9');
    do {ans=(ans << 3)+(ans<<1)+c-'0'; c=getchar(); } while (c>='0'&&c<='9');
    return f * ans;
}

int a[M][N];
int ne[M][N];
int d[M][N];

int main()
{
    int m, n;
    while (~scanf("%d%d",&m,&n) && m && n)
    {
        for (int i = 0;i < m;i ++)
            for (int j = 0;j < n;j ++)
                a[i][j] = read();
        
        int ans = INF;
        int first;
        for (int j = n - 1;j >= 0;j --)
        {
            for (int i = 0;i < m;i ++)
            {
                if (j == n - 1)
                    d[i][j] = a[i][j];
                else
                {
                    int rows[3] = {i,i - 1,i + 1};
                    if (i == 0)
                        rows[1] = m - 1;
                    if (i == m - 1)
                        rows[2] = 0;
                    std::sort(rows,rows+3);//字典序
                    d[i][j] = INF;
                    for (int k = 0;k < 3;k ++)
                    {
                        if (d[rows[k]][j+1] + a[i][j] < d[i][j])
                        {
                            d[i][j] = d[rows[k]][j+1] + a[i][j];
                            ne[i][j] = rows[k];
                        }
                    }
                }
                if (j == 0 && d[i][j] < ans)
                {
                    first = i;
                    ans = d[i][j];
                }
            }
        }
        printf("%d",first + 1);
        for (int i = ne[first][0],j = 1;j < n;i = ne[i][j ++])
            printf(" %d",i + 1);
        printf("\n%d\n",ans);
    }
    return 0;
}
```

