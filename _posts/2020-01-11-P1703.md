---
layout: post
title: P1703 最优贸易
date: 2020-01-11 16:55:59
tags: [Tarjan]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P1073)

## 题解

因为可以重复经过,所以可以缩点,同时记录每个强连通分量的最高和最低价格.  

在DAG上进行拓扑排序,然后就可以以拓扑序维护起点到每个点的最低价格,然后如果某个点可达终点,那么就尝试用这个点的最高价格减去可达这个点的最低价格更新答案.  

关于如何计算可达终点的点,我们建反图从终点进行DFS即可.  

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<iostream>
#include<stack>
#include<queue>

const int MAXN = 100000 + 1;

std::queue<int> topo;
std::stack<int> S;
int n, m;
std::vector<int> G[MAXN], SCC[MAXN], B[MAXN], T;
int pre[MAXN], lowlink[MAXN], sccno[MAXN], dfs_clock, scc_cnt;
int v[MAXN], vmin[MAXN], vmax[MAXN],in[MAXN], vis[MAXN], f[MAXN];

void dfs(int u)
{
    pre[u] = lowlink[u] = ++ dfs_clock;
    S.push(u);
    for (int i = 0;i < G[u].size();i ++)
    {
        int v = G[u][i];
        if (!pre[v])
        {
            dfs(v);
            lowlink[u] = std::min(lowlink[u], lowlink[v]);
        }
        else if (!sccno[v])
        {
            lowlink[u] = std::min(lowlink[u], pre[v]);
        }
    }
    if (pre[u] == lowlink[u])
    {
        scc_cnt ++;
        int x = S.top();
        vmin[scc_cnt] = vmax[scc_cnt] = v[x];
        while (true)
        {
            x = S.top();
            S.pop();
            sccno[x] = scc_cnt;
            vmin[scc_cnt] = std::min(vmin[scc_cnt], v[x]);
            vmax[scc_cnt] = std::max(vmax[scc_cnt], v[x]);
            if (x == u)
                break;
        }
    }
    return;
}

void toposort()
{
    for (int i = 1;i <= scc_cnt;i ++)
    {
        if (!in[i])
        {
            topo.push(i);
        }
    }
    while (!topo.empty())
    {
        int u = topo.front();
        topo.pop();
        T.push_back(u);
        for (int i = 0;i < SCC[u].size();i ++)
        {
            in[SCC[u][i]] --;
            if (!in[SCC[u][i]])
            {
                topo.push(SCC[u][i]);
            }
        }
    }
    return;
}

void find(int x)
{
    for (int i = 0;i < B[x].size();i ++)
    {
        if (!vis[B[x][i]])
        {
            vis[B[x][i]] = 1;
            find(B[x][i]);
        }
    }
    return;
}

int main()
{
    scanf("%d %d", &n, &m);

    for (int i = 1;i <= n;i ++)
    {
        scanf("%d", &v[i]);
    }

    for (int i = 1;i <= m;i ++)
    {
        int x, y, z;
        scanf("%d %d %d", &x, &y, &z);
        G[x].push_back(y);
        if (z == 2) G[y].push_back(x);
    }

    for (int i = 1;i <= n;i ++)
        if (!pre[i]) dfs(i);

    for (int i = 1;i <= n;i ++)
    {
        for (int j = 0;j < G[i].size();j ++)
        {
            int u = sccno[i], v = sccno[G[i][j]];
            if (u == v) continue;
            SCC[u].push_back(v);
            B[v].push_back(u);
            in[v] ++;
        }
    }

    toposort();

    vis[sccno[n]] = 1;
    find(sccno[n]);

    int ans = 0; 
    for (int i = 1;i <= scc_cnt;i ++) f[i] = vmin[i];
    for (int i = 1;i <= scc_cnt;i ++)
    {
        int u = T[i];
        if (vis[u]) ans = std::max(ans, vmax[u] - f[u]);
        for (int j = 0;j < SCC[u].size();j ++)
        {
            int v = SCC[u][j];
            f[v] = std::min(f[v], f[u]);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

