---
title: 1292A NEKO's Maze Game
date: 2020-01-20 11:29:07
tags: [CF]
mathjax: true
---

## 题意

一个2xn的方格图,每个时刻会封住/解封一个点,求每个时刻操作后是否能从$(1,1)$走到$(2,n)$.(只能走到有共同边的格子,也就是四连块)  

## 题解

不妨认为图是竖着的(n行2列),无法通行就是任意一个2x2的正方形中每列中都有至少一个被封住了.即为存在$(1,a)$,$(2,b)$被封住,且$|a-b| \leq 1$.为方便,将这样的一组称为封锁对.

那我们可以对于每一次操作,检查可能和它一起构成封锁的三个方块(另一列正对着,斜上和斜下),更新封锁对的数量,当没有封锁对时即为可通行,否则不可通行.  

## 代码

```cpp
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<vector>

int n, q;
std::vector<std::vector<int> > lava;

int main()
{
    std::cin >> n >> q;
    lava.resize(2, std::vector<int>(n, 0));
    int blockedPair = 0;
    while (q --)
    {
        int x, y;
        std::cin >> x >> y;
        x --, y --;
        int delta = (lava[x][y] == 0) ? 1 : -1;

        lava[x][y] = 1 - lava[x][y];
        for (int dy = -1; dy <= 1; dy ++)
        {
            if (y + dy < 0 || y + dy >= n) continue;

            if (lava[1 - x][y + dy] == 1) blockedPair += delta;
        }
        std::cout << ((blockedPair == 0) ? "Yes" : "No") << std::endl;
    }
    return 0;
}
//基本抄的cf题解
```



以上借鉴[CF官方题解](https://codeforces.com/blog/entry/73051)

