---
layout: post
title: P1352 没有上司的舞会
date: 2019-12-06 16:56:37
tags: [DP,树形DP]
mathjax: true
---

一棵树上儿子和父亲不能同时出现,求最大点权和  

## 链接

[P1352](https://www.luogu.com.cn/problem/P1352)

## 题解

树形DP经典题,不妨用  $ f[i][0]$  表示 $i$ 号不来时(下属来不来都可以)的最大快乐指数, $f[i][1]$ 表示 $i$ 号来时(下属一定都不来)的最大快乐指数

则

 $f[x][0] = \Sigma({\max(f[v][0],f[v][1])}),v\in son[x]$  

$f[x][1] = \Sigma(f[v][0])+w[x] ,v \in son[x]$

## 代码

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

int n;
int w[6005];
std::vector<int> son[6005];
int f[6005][2];
int in[6005];
void dp(int r)
{
	f[r][0] = 0;
	f[r][1] = w[r];
	for(int i = 0;i < son[r].size();i ++)
	{
		dp(son[r][i]);
		f[r][0] += std::max(f[son[r][i]][0],f[son[r][i]][1]);
		f[r][1] += f[son[r][i]][0]; 
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
	{
		scanf("%d",&w[i]);
	}
	for(int i = 1;i <= n;i ++)
	{
		int f,s;
		scanf("%d%d",&s,&f);
		son[f].push_back(s);
		in[s] ++;
	}
	int root;
	for(int i = 1;i <= n;i ++)
	{
		if(!in[i])
		{
			root = i;
			break;
		}
	}
	dp(root);
	printf("%d",std::max(f[root][0],f[root][1]));	
} 
```

