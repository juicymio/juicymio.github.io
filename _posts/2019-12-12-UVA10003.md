---
layout: post
title: UVA10003 切木棍
date: 2019-12-12 12:58:34
tags: [DP,最优矩阵链乘]
mathjax: true
---
## 链接

[Luogu](https://www.luogu.com.cn/problem/UVA10003)  

[UVA](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=944)  

## 题解

类似最优矩阵链乘,$d(i,j)$ 表示第 $i$ 个点和第 $j$ 个点中间的木棍最优费用,为方便递推,将切割点用 1-n 编号,存进数组$a[]$里,则 $a[0]=0,a[n+1]=L$,则状态转移方程为  
$d(i,j)=min{d(i,k)+d(k,j)|i<k<j}+a[j]-a[i] $

$a[j]-a[i]$即为切割前的木棍的长度,边界$d(i,i+1) = 0$,因为中间没有别的切割点,切不了了,答案$d(0,n+1)$  

注意要按木棍中切割点的数量递增递推,即 $j-i$ 递增,实现见代码  

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>

int a[100];
int d[100][100];

int main()
{
    int L = 0,n = 0;
    while(scanf("%d", &L) && L)
    {
        scanf("%d", &n);
        a[0] = 0,a[n+1] = L;
        for(int i = 1;i <= n;i ++)
           scanf("%d", &a[i]); 
        for(int l = 0;l <= n + 1;l ++)
        {
            for(int i = 0;i + l <= n + 1;i ++)
            {
                d[i][i+l] = 0x3f3f3f3f;
                d[i][i+1] = 0;
                for(int k = i;k <= i+l;k ++)
                {
                    d[i][i+l] = std::min(d[i][i+l],d[i][k]+d[k][i+l]+a[i+l]-a[i]);
                }
            }
        }
        printf("The minimum cutting is %d.\n",d[0][n+1]);
    }
    return 0;
}
```

