---
layout: post
title: P3627 [APIO2009]抢掠计划
date: 2020-01-09 16:15:18
tags: [tarjan,最短路]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P3627)  

## 题解

可以反复经过路口或路,就是提示一个强连通分量里的钱可以一起抢,这样就可以缩点,然后求最长路(点权可以直接当成边权算,见代码),只用含酒吧的点(tarjan的时候与处理一下哪个强连通分量有酒吧)更新答案.

## 代码

```cpp
#include<cstring>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<queue>
#include<stack>

const int MAXN = 500000 + 5;

int value[MAXN];
int value_scc[MAXN];
bool bar[MAXN];
bool bar_scc[MAXN];
bool inqueue[MAXN];
int ans, s, start;
std::stack<int> S;
std::queue<int> Q;
std::vector<int> G[MAXN];
std::vector<int> SCC[MAXN];
int sccno[MAXN], pre[MAXN], lowlink[MAXN], dis[MAXN], dfs_clock, scc_cnt;
void dfs(int u)
{
    pre[u] = lowlink[u] = ++ dfs_clock;
    S.push(u);
    for (int i = 0;i < G[u].size();i ++)
    {
        int v = G[u][i];
        if (!pre[v])
        {
            dfs(v);
            lowlink[u] = std::min(lowlink[u], lowlink[v]);
        }
        else if (!sccno[v])
        {
            lowlink[u] = std::min(lowlink[u], pre[v]);
        }
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt ++;
        while (true)
        {
            int x = S.top();
            S.pop();
            if (x == s)
            {
                start = scc_cnt;
                //printf("s:%d start:%d\n", s, start);
            }
            sccno[x] = scc_cnt;
            value_scc[scc_cnt] += value[x];
            bar_scc[scc_cnt] |= bar[x];
            if (u == x)
                break;
        }
    }
    return;
}
void bellmanFord(int start)
{
    memset(dis, 0, sizeof(dis));
    Q.push(start);
    inqueue[start] = true;
    dis[start] = value_scc[start];
    //printf("dis[start]: %d\n", dis[start]);
    while (!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        inqueue[u] = false;
        for (int i = 0;i < SCC[u].size();i ++)
        {
            int v = SCC[u][i];
            if (dis[u] + value_scc[v] > dis[v])
            {
                dis[v] = dis[u] + value_scc[v];
                if (!inqueue[v])
                {
                    Q.push(v);
                    inqueue[v] = true;
                }
                if (bar_scc[v])
                    ans = std::max(ans, dis[v]);
                    //printf("renew ans : %d\n", ans);
            }
        }
    }
    return;
}
int main()
{
    int n, m, p;
    scanf("%d %d", &n, &m);
    for (int i = 0;i < m; i ++)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        G[u].push_back(v);
    }
    for (int i = 1;i <= n;i ++)
    {
        scanf("%d", &value[i]);
    }
    scanf("%d %d", &s, &p);
    for (int i = 0;i < p;i ++)
    {
        int xzr;
        scanf("%d", &xzr);
        bar[xzr] = true;
    }
    for (int i = 1;i <= n;i ++)
    {
        if (!pre[i]) dfs(i);
    }
    for (int i = 1;i <= n;i ++)
    {
        for (int j = 0;j < G[i].size();j ++)
        {
            int u = sccno[i], v = sccno[G[i][j]];
            if(u != v)
                SCC[u].push_back(v);
        }
    }
    //printf("start : %d\n", start);
    bellmanFord(start);
    printf("%d", ans);
    return 0;
}
```

