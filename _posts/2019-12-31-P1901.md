---
layout: post
title: P1901 发射站
date: 2019-12-31 15:18:28
tags: [单调栈]
mathjax: true
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P1901)  

## 题解

每个发射站的信号只能传给离它最近的比它高的,所以我们维护一个高度单调递减的栈,因为如果一个塔已经比前面的塔高了,前面的塔就不会收到这个塔之后入栈的塔的能量,所以就把比新入栈的塔低的塔全部弹出去.

每次一个新的发射塔入栈,就会把能量发射给弹完栈之后的栈顶.也就是栈中离它最近的比他高的塔,左右各进行一次,就统计出每个塔收到的所有能量,再求出最大值,显然时间复杂度 $O(n)$.

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>

const int MAXN = 1000000+5;

struct Stack
{
    int stack[MAXN];
    int pos;
    Stack() :pos(0) {}
    bool empty()
    {
        return pos == 0;
    }
    void clear()
    {
        pos = 0;
    }
    int top()
    {
        return stack[pos];
    }
    bool pop()
    {
        if (pos)
        {
            pos --;
            return true;
        }
        return false;
    }
    void push(int x)
    {
        stack[++ pos] = x;
    }
} S;
long long h[MAXN], v[MAXN], power[MAXN];
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1;i <= n;i ++)
    {
        scanf("%lld %lld", &h[i], &v[i]);
        while (!S.empty() && h[S.top()] < h[i]) S.pop();
        if (!S.empty()) power[S.top()] += v[i];
        S.push(i);
    }
    S.clear();
    for (int i = n;i >= 1;i --)
    {
        while(!S.empty() && h[S.top()] < h[i]) S.pop();
        if(!S.empty()) power[S.top()] += v[i];
        S.push(i);
    }
    long long maxpower = 0;
    for (int i = 1;i <= n;i ++)
    {
        maxpower = std::max(maxpower, power[i]);
    }
    printf("%d", maxpower);
    return 0;
}
```

