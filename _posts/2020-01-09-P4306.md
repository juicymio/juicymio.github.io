---
title: P4306 连通数
date: 2020-01-09 16:26:23
tags: [tarjan,bitset]
---

## 链接

[Luogu](https://www.luogu.com.cn/problem/P4306)  

bzoj也有  

## 题解

考虑DAG上的做法,显然拓扑排序建反图把连通情况算出来,之后直接双重循环求结果就好了.那就缩点转化成DAG.不过这样会TLE.这时可以使用bitset优化,用bitset记录连通情况.可以让复杂度从 $O(n^3)$ 变成 $O(n^3/w)$,其中$w=32(计算机的位数)$.然后就过了.

## 代码

```cpp
#include<vector>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cstdio>
#include<bitset>
#include<queue>
#include<stack>

const int MAXN = 2010;
std::vector<int> G[MAXN],SCC[MAXN];
int pre[MAXN], lowlink[MAXN], sccno[MAXN], size[MAXN], deg[MAXN], dfs_clock, scc_cnt;
std::stack<int> S;
std::queue<int> Q;
std::bitset<MAXN> f[MAXN];
void dfs(int u)
{
    S.push(u);
    pre[u] = lowlink[u] = ++ dfs_clock;
    for (int i = 0;i < G[u].size();i ++)
    {
        int v = G[u][i];
        if (!pre[v])
        {
            dfs(v);
            lowlink[u] = std::min(lowlink[u], lowlink[v]);
        }
        else if (!sccno[v])
        {
            lowlink[u] = std::min(lowlink[u], pre[v]); 
        }
    }
    if (lowlink[u] == pre[u])
    {
        scc_cnt ++;
        while(1)
        {
            int x = S.top();
            S.pop();
            size[scc_cnt] ++;
            sccno[x] = scc_cnt;
            if(x == u) break;
        }
    }
    return;
}
void topo()
{
    while(!Q.empty())
    {
        int x = Q.front();
        Q.pop();
        for (int i = 0;i < SCC[x].size();i ++)
        {
            int v = SCC[x][i];
            deg[v] --;
            f[v] |= f[x];
            if (!deg[v])
                Q.push(v);
        }
    }
}

char ch[MAXN];
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1;i <= n;i ++)
    {
        scanf("%s" ,ch + 1);
        for (int j = 1;j <= n;j ++)
        {
            if(ch[j] == '1')
                G[i].push_back(j);
        }
    }
    for (int i = 1;i <= n;i ++)
    {
        if(!pre[i])
            dfs(i);
    }
    for (int u = 1;u <= n;u ++)
    {
        for (int i = 0;i < G[u].size();i ++)
        {
            int v = G[u][i];
            if(sccno[v] != sccno[u])
            {
                SCC[sccno[v]].push_back(sccno[u]);
                deg[sccno[u]] ++;
            }
        }
    }
    for (int i = 1;i <= scc_cnt;i ++)
    {
        f[i].set(i);
        if (!deg[i])
            Q.push(i);
    }
    topo();
    int ans = 0;
    for (int i = 1;i <= scc_cnt;i ++)
    {
        for (int j = 1;j <= scc_cnt;j ++)
        {
            if(f[i][j])
                ans += size[i] * size[j];
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

