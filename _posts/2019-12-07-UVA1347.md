---
layout: post
title: UVA1347 旅行
date: 2019-12-07 00:38:43
tags: [DP]
mathjax: true
---

按$x$递增顺序给出$n$个点,设计一条从最左边的点出发到最右边的点再返回的路径,使得除了最左点与最右点之外每个点恰好经过一次,且路径总长度最短.

## 题解

假设两个人同时从最左点出发,则用 $d(i,j)$ 表示$1-max(i,j)$ 全部走过,且两个人分别处于 $i,j$ 时到终点还要多长距离.  

易知$d(i,j) = d(j,i)$ 则规定 $i > j$ .因每个点都要走过,即不能跳过任何点,也就是 $i+1$ 一定会被$i$或$j$走到 

则状态转移方程为

$d(i,j) = \min(d(i+1,j)+dist(i,i+1),d(i+1,i)+dist(j,i+1)$ 即 $i$ 走到 $i+1$ 或 $j$ 走到 $i+1$ .

最终答案为 $d(1,1)$ 或 $dist(1,2)+d(2,1)$,因为第一步必定是某人走到了 $2$ 点

## 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
#define DEBUG

const int MAXN = 1000+10;
 
struct Node
{
    int x, y;
} nodes[MAXN];

int read()
{
    char c;
    int f=1,ans=0;
    do { c=getchar(); if (c=='-')f=-1; } while (c<'0'||c>'9');
    do { ans=(ans << 3)+(ans<<1)+c-'0'; c=getchar(); } while (c>='0'&&c<='9');
    return f * ans;
}

double dis[MAXN][MAXN];
double f[MAXN][MAXN];

double dist(int i,int j)
{
    if(dis[i][j] > 0)
        return dis[i][j];
    else
    {
        double x = std::abs(nodes[i].x - nodes[j].x);
        double y = std::abs(nodes[i].y - nodes[j].y);
        dis[i][j] = sqrt(x*x+y*y);
    }
    return dis[i][j];
}

int n;

double d(int i,int j)
{
    if(f[i][j] > 0)
        return f[i][j];
    f[i][j] = 0.0;
    if(i == n - 1)
        f[i][j] = dist(n-1,n) + dist(j,n);
    else
        f[i][j] = std::min(dist(i,i+1)+d(i+1,j),dist(j,i+1)+d(i+1,i));
    return f[i][j];
}

int main()
{
    while (~scanf("%d",&n) && n)
    {
        for (int i = 0; i < 1010; i++)
		    for (int j = 0; j < 1010; j++)
		    {
			    dis[i][j] = -1.0;
			    f[i][j] = -1.0;
		    }
        //上面的初值不写会WA
        for (int i = 1;i <= n;i ++)
        {
            scanf("%d%d",&nodes[i].x,&nodes[i].y);
        }
        /*
        for (int i = 1;i < n - 1;i ++)
       	   f[n-1][i] = dist(n-1,n) + dist(i,n);
        for(int i = n - 2;i > 1;i --)
        {
            for(int j = i - 1;j > 0;j --)
            {
                f[i][j] = std::min(dist(i,i+1)+f[i+1][j],dist(j,i+1)+f[i+1][i]);
            }
        }
       */ printf("%.2f\n",d(1,1));//dist(1,2)+f[2][1]
    }
    return 0;
}
//代码注释中为递推版
```

