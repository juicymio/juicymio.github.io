---
layout: post
title: P1462 通往奥格瑞玛的道路
date: 2019-12-05 13:24:19
tags: [最短路,二分]
mathjax: true
---

## 简要思路

二分答案+最短路验证  

点权为费用,所以只挑符合答案的点走,边权为血量,显然最短路是扣血最少的,所以可以用最短路  

这个题意毒瘤,其实是求路径上的边权的最大值最小为多少(于是就是二分

## 代码

```cpp
#include<vector>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
int n,m,b;
struct node
{
    int u,d;
    
    bool operator <(const node& rhs)const
    {
        return d > rhs.d;
    }
};
struct edge
{
    int v,w;
};
int read()
{
    char c;
    int f = 1;
    int ans = 0;
    do
    {
        c = getchar();
        if(c == '-')
            f = -1;
    }
    while(c < '0' || c > '9');
    do
    {
        ans = ans*10+c-'0';
        c = getchar();
    }
    while(c >= '0' && c <= '9');
    return f*ans;
}
std::vector<edge> G[10000+10];
int N[10000+10];
int dis[10000+10];
void addEdge(int u,int v,int w)
{
    edge e;
    e.v = v,e.w = w;
    G[u].push_back(e);
}
bool dijkstra(int M)
{
    int mx = -1;
    memset(dis,0x3f,sizeof(dis));
    std::priority_queue<node> Q;
    node cur;
    dis[1] = 0;
    cur.u = 1,cur.d = 0;
    Q.push(cur);
    while(!Q.empty())
    {
        cur = Q.top();
        Q.pop();
        if(cur.d != dis[cur.u])
            continue;
        for(register unsigned int i = 0;i < G[cur.u].size();i ++)
        {
            if(dis[cur.u]+G[cur.u][i].w < dis[G[cur.u][i].v] && N[G[cur.u][i].v] <= M)
            {
                dis[G[cur.u][i].v] = dis[cur.u]+G[cur.u][i].w;
                Q.push({G[cur.u][i].v,dis[G[cur.u][i].v]});
            }
        }
    }
    if(dis[n] < b) return true;
    else return false;
}
int main()
{
    //freopen("1462.in","r",stdin);
    //freopen("1462.out","w",stdout);
    int mx = -1;
    n = read(),m = read(),b = read();
    for(register int i = 1;i <= n;i ++)
    {
        N[i] = read();
        mx = N[i] > mx ? N[i] : mx;
    }
    int u,v,w;
    for(register int i = 0;i < m;i ++)
    {
        u = read(),v = read(),w = read();
        if(u != v)
        {
            addEdge(u,v,w);
            addEdge(v,u,w);   
        }
    }
    if(!dijkstra(0x3f3f3f3f))
    {
        printf("AFK");
        return 0;
    }
    int l = 0,r = mx+1,mid;
    while(l <= r)
    {
        mid = (l+r) >> 1;
        bool res = dijkstra(mid);
        if(res)
            r = mid - 1;
        else
            l = mid + 1;
    }
    printf("%d",l);
    return 0;
}
```

