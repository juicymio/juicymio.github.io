[{"categories":null,"content":"环境准备 WSL2(Ubuntu22.04) + VSCode apt-get update sudo apt-get install build-essential sudo apt-get install gcc-multilib sudo apt-get install gdb ","date":"2022-10-15","objectID":"/csapp_lab/:1:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"Data Lab ","date":"2022-10-15","objectID":"/csapp_lab/:2:0","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"食用方法 阅读README获得完整信息 按照bits.c文件的注释修改bits.c 使用./dlc bits.c 检查代码是否符合标准, 若符合则无输出. ./dlc -e bits.c查看用了多少操作符 每次修改bits.c后 执行make clean \u0026\u0026 make btest编译测试工具 执行./btest检查正确性,./btest -f foo可以单独检查某个函数的正确性 运行./driver.pl打分 ","date":"2022-10-15","objectID":"/csapp_lab/:2:1","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"题目 bitXor 只使用~和\u0026实现^ a^b = (a|b)\u0026(~a|~b) = ~(~a\u0026~b)\u0026(a\u0026b) = (a\u0026~b)|(~a\u0026b) //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~(x \u0026 ~ y) \u0026 ~(~x \u0026 y)); } tmin /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } isTmax 最大值x应该是第一位为0, 其它位都为1, 则x+1 = ~x. 但是由于所有位都为1的-1+1之后进位的0会溢出消失, 所以-1 + 1 = ~(-1)需要特判, 只需特判~x是否为0, 即(!!~x) //2 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !((x+1)^(~x))\u0026(!!~x); } ","date":"2022-10-15","objectID":"/csapp_lab/:2:2","tags":["CSAPP"],"title":"Csapp_lab","uri":"/csapp_lab/"},{"categories":null,"content":"CSAPP第二章家庭作业2.65 /*Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w=32 */ int odd_ones(unsigned x) 函数应该遵循位级整数编码规则,你的代码最多只能包含12个算术运算,位运算和逻辑运算. ","date":"2022-10-12","objectID":"/odd_ones/:0:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"代码 先上个代码 int odd_ones(unsigned x) { x ^= x \u003e\u003e 16; x ^= x \u003e\u003e 8; x ^= x \u003e\u003e 4; x ^= x \u003e\u003e 2; x ^= x \u003e\u003e 1; return x \u0026 1; //http://stackoverflow.com/a/9133406 } 在使用循环的情况下就可以不用预先知道int的位数是多少,如下 int odd_ones(unsigned x) { int w = sizeof(x) * 8;//获得x有多少位二进制位,这里是32 int n = 1; while(n \u003c w) { x ^= (x \u003e\u003e n); n \u003c\u003c= 1; } return x \u0026 1; } ","date":"2022-10-12","objectID":"/odd_ones/:1:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"原理 由于异或的性质, 可以反映异或对应位上1的个数. 例: 0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 1 = 0. 即只有两位中有奇数个(1个)1的时候, 该位的异或值为1.也就是我们用异或结果的一个位压缩了进行异或的两位的1的个数. 依照这个思想我们可以先写出一个简单的版本: int odd_ones(unsigned x) { unsigned s = x \u003e\u003e 1; while(x) { x ^= s; s \u003e\u003e= 1; } return x \u0026 1; } 我们设最右侧一位为第0位,最左侧一位为第w位, 即x第0位一开始代表第0位的1是否为奇数个,一次异或后变为第0和第1位的1是否位奇数个, 然后是第0~2位中的1是否为奇数个… 经过w-1次移位, 第0位代表第0~w-1位的1总共是否为奇数个, 此时返回x\u00261即可. 但我们发现这样移位一次只利用了每次第0位的异或结果, 有优化空间. 我们可以同时利用多个异或结果, 并且这些异或结果所代表的位不能重叠.(因为最后需要有一位代表0~w-1位中1的个数, 若有重叠就会导致某一位多计算一次). 那么最大化且不重叠的利用办法就是一次右移一半, 像将这个数字\"对折\"一样. 此时的异或结果中0~w/2-1位中每一位分别代表第i位和第i+w/2-1位中1的个数是否为奇数. 每次右移一半直到只剩一位, 我们只需进行$log_2w$次异或和右移运算.代码见开头. ","date":"2022-10-12","objectID":"/odd_ones/:2:0","tags":null,"title":"二进制数中1的个数是否为奇数","uri":"/odd_ones/"},{"categories":null,"content":"用于记录一些比较奇怪/少见的c语法/易错易忘点, 以备考试等用途 编译没过先看报错信息, 不认识英文请善用翻译 带缺省值的参数需要放在后面, 这样在调用函数的时候就可以不写那个参数. 放在前面编译会报错. int f(int b, int a = 0); // right int f(int a = 0, int b); // wrong 字符串占用的空间要算上 ‘\\0’ ","date":"2022-10-12","objectID":"/c/:0:0","tags":null,"title":"C八股","uri":"/c/"},{"categories":null,"content":"JuicyMio 前OIer 现尝试学习CTF 邮箱:guanhyjuicymio@gmail.com ","date":"2022-10-12","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"pwnable.kr writeup ","date":"2022-10-12","objectID":"/pwnable/:0:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable/"},{"categories":null,"content":"1 fd 文件描述符(file descricptor) 维基百科：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。 习惯上 标准输入(stdin)为0, 标准输出(stdout)为1, 标准错误(stderr)为2. //fd.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc\u003c2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } 得到flag的关键在于如歌通过第二个if语句, 也就是如何让buf=LETMEMIN 可以看到read从fd中读入32个字节为buf赋值, 如果我们想控制buf的值就要控制fd中的内容, 那么只要让fd=0, 再向标准输入(从命令行直接输入)中输入LETMEWIN就可以了. 注意到fd在此处赋值: int fd = atoi( argv[1] ) - 0x1234; 其中atoi是将字符串转化为整数的函数 int main(int argc, char* argv[], char* envp[]){ 可以看到argv[]是main函数的一个参数, 而main函数的参数都是程序运行时在命令行输入的, argc代表输入参数的个数(第一个参数是程序路径), argv则存储着指向这些参数的指针. envp存储指向环境变量的指针, 此处没用到. 例如运行程序fd ./fd 4660 此时argc值为2, 而argv[0] = “./fd”, argv[1] = “4660” atoi不能转化16进制数, 所以我们手动转换0x1234, 它的十进制表示是4660 这样我们就可以让fd = 0, 程序等待从stdin中读取字符 我们再向命令行中输入LETMEWIN, 即可得到flag ","date":"2022-10-12","objectID":"/pwnable/:1:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable/"},{"categories":null,"content":"2 collision ","date":"2022-10-12","objectID":"/pwnable/:2:0","tags":["pwn"],"title":"Pwnable.kr","uri":"/pwnable/"}]