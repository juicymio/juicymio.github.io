<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>操作系统学习笔记 | JuicyMio's Blog</title>
<meta name=keywords content="os"><meta name=description content='0xFE 序言
赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.
0xFF 操作系统的启动
实模式
刚开机时CPU进入实模式, 因为此时只能使用物理地址.
实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.
BIOS(Basic Input/Output System)
基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.
BIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.
Boot
BOOT(靴子), 意为"to load a program into a computer from a disk; to start or ready for use especially by booting a program."
BOOTSTRAP(鞋带)

pull oneself up by one&rsquo;s bootstraps 靠自己自立自强
by one&rsquo;s own bootstraps 自己努力, 自强'><meta name=author content="JuicyMio"><link rel=canonical href=https://juicymio.github.io/posts/oslearning/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://juicymio.github.io/posts/oslearning/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="操作系统学习笔记"><meta property="og:description" content='0xFE 序言
赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.
0xFF 操作系统的启动
实模式
刚开机时CPU进入实模式, 因为此时只能使用物理地址.
实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.
BIOS(Basic Input/Output System)
基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.
BIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.
Boot
BOOT(靴子), 意为"to load a program into a computer from a disk; to start or ready for use especially by booting a program."
BOOTSTRAP(鞋带)

pull oneself up by one&rsquo;s bootstraps 靠自己自立自强
by one&rsquo;s own bootstraps 自己努力, 自强'><meta property="og:type" content="article"><meta property="og:url" content="https://juicymio.github.io/posts/oslearning/"><meta property="og:image" content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-14T22:36:18+08:00"><meta property="article:modified_time" content="2023-03-14T22:36:18+08:00"><meta property="og:site_name" content="JuicyMio's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="操作系统学习笔记"><meta name=twitter:description content='0xFE 序言
赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.
0xFF 操作系统的启动
实模式
刚开机时CPU进入实模式, 因为此时只能使用物理地址.
实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.
BIOS(Basic Input/Output System)
基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.
BIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.
Boot
BOOT(靴子), 意为"to load a program into a computer from a disk; to start or ready for use especially by booting a program."
BOOTSTRAP(鞋带)

pull oneself up by one&rsquo;s bootstraps 靠自己自立自强
by one&rsquo;s own bootstraps 自己努力, 自强'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juicymio.github.io/posts/"},{"@type":"ListItem","position":2,"name":"操作系统学习笔记","item":"https://juicymio.github.io/posts/oslearning/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"操作系统学习笔记","name":"操作系统学习笔记","description":"0xFE 序言 赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.\n0xFF 操作系统的启动 实模式 刚开机时CPU进入实模式, 因为此时只能使用物理地址.\n实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.\nBIOS(Basic Input/Output System) 基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.\nBIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.\nBoot BOOT(靴子), 意为\u0026quot;to load a program into a computer from a disk; to start or ready for use especially by booting a program.\u0026quot; BOOTSTRAP(鞋带)\npull oneself up by one\u0026rsquo;s bootstraps 靠自己自立自强 by one\u0026rsquo;s own bootstraps 自己努力, 自强\n","keywords":["os"],"articleBody":"0xFE 序言 赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到从0到-1写一个操作系统-0xFF-!!完结撒花!!, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.\n0xFF 操作系统的启动 实模式 刚开机时CPU进入实模式, 因为此时只能使用物理地址.\n实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.\nBIOS(Basic Input/Output System) 基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.\nBIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.\nBoot BOOT(靴子), 意为\"to load a program into a computer from a disk; to start or ready for use especially by booting a program.\" BOOTSTRAP(鞋带)\npull oneself up by one’s bootstraps 靠自己自立自强 by one’s own bootstraps 自己努力, 自强\n必须先运行程序, 计算机才能启动, 但是计算机不启动就无法运行程序. 这与人没法拽着鞋带把自己拉起来类似. 于是早期工程师们设法先将一小段程序装入内存, 称之为\"boot\", 意为\"自引导程序\".\nMBR(Master boot record) BIOS按照设定的启动顺序, 将控制权转移给启动顺序首位的存储设备. BIOS首先寻找他们的MBR, 如果该磁盘的主引导扇区(0柱头, 0磁头, 1扇区, 即前512个字节)最后两字节为0x55和0xaa, BIOS则认为MBR有效, 并将控制权转交给MBR. 如果未找到MBR, BIOS会去启动顺序中下一顺位的设备中寻找. MBR由三部分组成: 启动代码(446字节), 磁盘分区表(16x4字节), 结束标志(0x55, 0xaa 两字节).\nBoot Loader Boot Loader(启动引导程序)用于加载操作系统内核文件. 用户可以用Boot Loader来选择启动不同的操作系统. Windows的Boot Loader是Windows Boot Manager.\n操作系统 操作系统内核被载入内存后, 再经过一系列初始化过程完成操作系统的启动.\n参考文献 计算机是如何启动的\n0x00 分割线 显然我完全没坚持下去。\n转眼一年半过去了，已经到了上操作系统实验课的时间。\n0x01 实验环境搭建 搭建实验的基本环境，熟悉开发与调试工具\n实验目标 • 搭建基本实验环境，熟悉基本开发与调试工具 • 对应章节：第一、二章\n本次实验内容 认真阅读章节资料 在实验机上安装虚拟运行环境，并安装ubuntu（实验 室机器已安装，若需要可在自己笔记本电脑另行安装） 安装ubuntu开发环境，32位环境 笔者实体机使用archlinux x86_64 下载bochs源码，编译并安装bochs环境 qemu+gdb 使用bochs自带工具bximageqemu-img创建虚拟软驱 阅读、编译boot.asm，并反汇编阅读 ~~修改bochsrc，~~运行并调试你的第一个程序 完成实验练习要求 实验要求运行的代码为OrangeS第一章osfs1 实验练习要求 删除0xAA55，观察程序效果，找出原因 会显示No bootable device。 原因具体见0xFF部分的MBR介绍。\ntest.bin中的代码是作为MBR使用的，没有校验位0x55aa,BIOS会认为该MBR无效，也就不会装载运行其代码。\n修改程序中输出为，一个包含自己名字的字符串，调试程序 注意修改字符串后，需要同时修改参数cx：字符串的长度。此处修改为结尾-开头，编译时自动计算长度。\n把生成的可执行文件反汇编，看看输出的内容是怎样的，并在虚拟机启动过程，设置断点进行调试，在实验报告中截图 注意此处遇到一个问题：gdb 调试 qemu 程序时，会与 qemu 通信获取架构，且无法用 set arch 指令覆盖。这导致在使用 32 位的 qemu 在实模式下运行 16 位的程序时，gdb 无法 正确识别架构。 解 决 方 法 参 考 How to disassemble 16-bit x86 boot sector code in GDB with “x/i $pc”? It gets treated as 32-bit里面的这篇回答，手动修改tdesc。\n为什么要jmp $，如何改造程序，让这个输出过程执行100次 jmp $含义为跳转回当前指令，也就是无限循环。因为这句代码下面没有别的代码了，所以为了防止误将数据当代码执行，要放一个无限循环。\n为什么要对段寄存器进行赋值 程序加载后，code段寄存器为0x7c00,而通过赋值段寄存器将data段和extra段寄存器为与cs相同，这样可以寻址到输出的字符串。\n如何在该程序中调用系统中断 使用int指令。\n0x02 保护模式工作机理 ","wordCount":"208","inLanguage":"en","image":"https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-03-14T22:36:18+08:00","dateModified":"2023-03-14T22:36:18+08:00","author":[{"@type":"Person","name":"JuicyMio"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://juicymio.github.io/posts/oslearning/"},"publisher":{"@type":"Organization","name":"JuicyMio's Blog","logo":{"@type":"ImageObject","url":"https://juicymio.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juicymio.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://juicymio.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juicymio.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://juicymio.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juicymio.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juicymio.github.io/friends/ title=friends><span>friends</span></a></li><li><a href=https://juicymio.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juicymio.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juicymio.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">操作系统学习笔记</h1><div class=post-meta><span title='2023-03-14 22:36:18 +0800 CST'>March 14, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;208 words&nbsp;·&nbsp;JuicyMio&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/OSlearning.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0xfe-序言>0xFE 序言</a></li><li><a href=#0xff-操作系统的启动>0xFF 操作系统的启动</a><ul><li><a href=#实模式>实模式</a></li><li><a href=#biosbasic-inputoutput-system>BIOS(Basic Input/Output System)</a></li><li><a href=#boot>Boot</a></li><li><a href=#mbrmaster-boot-record>MBR(Master boot record)</a></li><li><a href=#boot-loader>Boot Loader</a></li><li><a href=#操作系统>操作系统</a></li></ul></li><li><a href=#参考文献>参考文献</a></li><li><a href=#0x00-分割线>0x00 分割线</a></li><li><a href=#0x01-实验环境搭建>0x01 实验环境搭建</a><ul><li><a href=#实验目标>实验目标</a></li><li><a href=#本次实验内容>本次实验内容</a></li><li><a href=#实验练习要求>实验练习要求</a></li></ul></li><li><a href=#0x02-保护模式工作机理>0x02 保护模式工作机理</a></li></ul></nav></div></details></div><div class=post-content><h2 id=0xfe-序言>0xFE 序言<a hidden class=anchor aria-hidden=true href=#0xfe-序言>#</a></h2><p>赶上吾爱破解十五周年开放注册, 注册了个账号. 随便翻了翻精品帖子, 看到<a href=https://www.52pojie.cn/thread-1748588-1-1.html>从0到-1写一个操作系统-0xFF-!!完结撒花!!</a>, 感觉还不错, 于是开始动手实践, 开一个博客记录, 也是督促自己坚持下去.</p><h2 id=0xff-操作系统的启动>0xFF 操作系统的启动<a hidden class=anchor aria-hidden=true href=#0xff-操作系统的启动>#</a></h2><h3 id=实模式>实模式<a hidden class=anchor aria-hidden=true href=#实模式>#</a></h3><p>刚开机时CPU进入实模式, 因为此时只能使用物理地址.<br>实模式地址的分布是固定的,以8086为例, BIOS入口在0xFFFF0到0xFFFFF之间, 其中是一个jmp指令, 跳转到真正的BIOS位置. 中断向量表在0x00000到0x003FF. MBR加载地址在0x7C00到0x7DFF.</p><h3 id=biosbasic-inputoutput-system>BIOS(Basic Input/Output System)<a hidden class=anchor aria-hidden=true href=#biosbasic-inputoutput-system>#</a></h3><p>基本输入输出系统. 早期存储在ROM中, 现在存储在主板上的一个或多个芯片中. 目前其继承者UEFI(Unified Extensible Firmware Interface)正在全面取代BIOS.<br>BIOS首先进行加电自检(Power-On Self-Test), 缩写为POST, 检查CPU, 内存, 主板, 硬盘, 显卡等设备. POST结束后系统BIOS调用其他设备的BIOS对各个设备进行检测和初始化. 如果自检没有出现问题, 将执行启动程序.</p><h3 id=boot>Boot<a hidden class=anchor aria-hidden=true href=#boot>#</a></h3><p>BOOT(靴子), 意为"to load a program into a computer from a disk; to start or ready for use especially by booting a program."
BOOTSTRAP(鞋带)</p><blockquote><p>pull oneself up by one&rsquo;s bootstraps 靠自己自立自强
by one&rsquo;s own bootstraps 自己努力, 自强</p></blockquote><p>必须先运行程序, 计算机才能启动, 但是计算机不启动就无法运行程序. 这与人没法拽着鞋带把自己拉起来类似. 于是早期工程师们设法先将一小段程序装入内存, 称之为"boot", 意为"自引导程序".</p><h3 id=mbrmaster-boot-record>MBR(Master boot record)<a hidden class=anchor aria-hidden=true href=#mbrmaster-boot-record>#</a></h3><p>BIOS按照设定的启动顺序, 将控制权转移给启动顺序首位的存储设备. BIOS首先寻找他们的MBR, 如果该磁盘的主引导扇区(0柱头, 0磁头, 1扇区, 即前512个字节)最后两字节为0x55和0xaa, BIOS则认为MBR有效, 并将控制权转交给MBR. 如果未找到MBR, BIOS会去启动顺序中下一顺位的设备中寻找.
MBR由三部分组成: 启动代码(446字节), 磁盘分区表(16x4字节), 结束标志(0x55, 0xaa 两字节).</p><h3 id=boot-loader>Boot Loader<a hidden class=anchor aria-hidden=true href=#boot-loader>#</a></h3><p>Boot Loader(启动引导程序)用于加载操作系统内核文件. 用户可以用Boot Loader来选择启动不同的操作系统. Windows的Boot Loader是Windows Boot Manager.</p><h3 id=操作系统>操作系统<a hidden class=anchor aria-hidden=true href=#操作系统>#</a></h3><p>操作系统内核被载入内存后, 再经过一系列初始化过程完成操作系统的启动.</p><h2 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h2><p><a href=https://www.ruanyifeng.com/blog/2013/02/booting.html>计算机是如何启动的</a></p><hr><h2 id=0x00-分割线>0x00 分割线<a hidden class=anchor aria-hidden=true href=#0x00-分割线>#</a></h2><p>显然我完全没坚持下去。<br>转眼一年半过去了，已经到了上操作系统实验课的时间。</p><hr><h2 id=0x01-实验环境搭建>0x01 实验环境搭建<a hidden class=anchor aria-hidden=true href=#0x01-实验环境搭建>#</a></h2><p>搭建实验的基本环境，熟悉开发与调试工具</p><h3 id=实验目标>实验目标<a hidden class=anchor aria-hidden=true href=#实验目标>#</a></h3><p>• 搭建基本实验环境，熟悉基本开发与调试工具
• 对应章节：第一、二章</p><h3 id=本次实验内容>本次实验内容<a hidden class=anchor aria-hidden=true href=#本次实验内容>#</a></h3><ol><li>认真阅读章节资料</li><li><del>在实验机上安装虚拟运行环境，并安装ubuntu（实验
室机器已安装，若需要可在自己笔记本电脑另行安装）</del></li><li><del>安装ubuntu开发环境，32位环境</del> 笔者实体机使用archlinux x86_64</li><li><del>下载bochs源码，编译并安装bochs环境</del> qemu+gdb</li><li>使用<del>bochs自带工具bximage</del>qemu-img创建虚拟软驱</li><li>阅读、编译boot.asm，并反汇编阅读</li><li>~~修改bochsrc，~~运行并调试你的第一个程序</li><li>完成实验练习要求
实验要求运行的代码为OrangeS第一章<a href=https://github.com/yyu/osfs01>osfs1</a></li></ol><h3 id=实验练习要求>实验练习要求<a hidden class=anchor aria-hidden=true href=#实验练习要求>#</a></h3><h4 id=删除0xaa55观察程序效果找出原因>删除0xAA55，观察程序效果，找出原因<a hidden class=anchor aria-hidden=true href=#删除0xaa55观察程序效果找出原因>#</a></h4><p><img loading=lazy src=/OSlearning-1.png alt>
会显示No bootable device。
原因具体见0xFF部分的MBR介绍。<br>test.bin中的代码是作为MBR使用的，没有校验位0x55aa,BIOS会认为该MBR无效，也就不会装载运行其代码。</p><h4 id=修改程序中输出为一个包含自己名字的字符串调试程序>修改程序中输出为，一个包含自己名字的字符串，调试程序<a hidden class=anchor aria-hidden=true href=#修改程序中输出为一个包含自己名字的字符串调试程序>#</a></h4><p><img loading=lazy src=/OSlearning-2.png alt>
注意修改字符串后，需要同时修改参数cx：字符串的长度。此处修改为结尾-开头，编译时自动计算长度。</p><h4 id=把生成的可执行文件反汇编看看输出的内容是怎样的并在虚拟机启动过程设置断点进行调试在实验报告中截图>把生成的可执行文件反汇编，看看输出的内容是怎样的，并在虚拟机启动过程，设置断点进行调试，在实验报告中截图<a hidden class=anchor aria-hidden=true href=#把生成的可执行文件反汇编看看输出的内容是怎样的并在虚拟机启动过程设置断点进行调试在实验报告中截图>#</a></h4><p><img loading=lazy src=/OSlearning-5.png alt>
<img loading=lazy src=/OSlearning-3.png alt>
注意此处遇到一个问题：gdb 调试 qemu 程序时，会与 qemu 通信获取架构，且无法用 set arch 指令覆盖。这导致在使用 32 位的 qemu 在实模式下运行 16 位的程序时，gdb 无法
正确识别架构。
解 决 方 法 参 考 <a href=https://stackoverflow.com/questions/32955887/how-to-disassemble-16-bit-x86-boot-sector-code-in-gdb-with-x-i-pc-it-gets-tr>How to disassemble 16-bit x86 boot sector code in GDB with &ldquo;x/i $pc&rdquo;? It gets treated as 32-bit</a>里面的<a href=https://stackoverflow.com/a/61981253/23527798>这篇回答</a>，手动修改tdesc。</p><h4 id=为什么要jmp-如何改造程序让这个输出过程执行100次>为什么要jmp $，如何改造程序，让这个输出过程执行100次<a hidden class=anchor aria-hidden=true href=#为什么要jmp-如何改造程序让这个输出过程执行100次>#</a></h4><p>jmp $含义为跳转回当前指令，也就是无限循环。因为这句代码下面没有别的代码了，所以为了防止误将数据当代码执行，要放一个无限循环。</p><h4 id=为什么要对段寄存器进行赋值>为什么要对段寄存器进行赋值<a hidden class=anchor aria-hidden=true href=#为什么要对段寄存器进行赋值>#</a></h4><p>程序加载后，code段寄存器为0x7c00,而通过赋值段寄存器将data段和extra段寄存器为与cs相同，这样可以寻址到输出的字符串。</p><h4 id=如何在该程序中调用系统中断>如何在该程序中调用系统中断<a hidden class=anchor aria-hidden=true href=#如何在该程序中调用系统中断>#</a></h4><p>使用int指令。</p><h2 id=0x02-保护模式工作机理>0x02 保护模式工作机理<a hidden class=anchor aria-hidden=true href=#0x02-保护模式工作机理>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://juicymio.github.io/tags/os/>Os</a></li></ul><nav class=paginav><a class=prev href=https://juicymio.github.io/posts/buuctfothers_shellcode/><span class=title>« Prev</span><br><span>[BUUCTF]others_shellcode wp</span>
</a><a class=next href=https://juicymio.github.io/posts/mayctf_writeup/><span class=title>Next »</span><br><span>mayctf writeup by Mio and K-ON!</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://juicymio.github.io/>JuicyMio's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>