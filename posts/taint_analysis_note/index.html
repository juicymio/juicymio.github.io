<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>污点分析学习笔记 | JuicyMio's Blog</title><meta name=keywords content="pwn,taint_analysis"><meta name=description content="静态分析
静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题
给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：

程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；
程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；
程序P中的类型转换（Type Cast）是否都是安全的；
程序P中是否存在可能无法满足的断言（Assertion Error）；
程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）


是否存在算法能给出该判定问题的答案？
软件测试？
&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra

希尔伯特计划

&ldquo;Wir müssen wissen, wir werden wissen.&rdquo;  ——David Hilbert
(我们必须知道，我们必将知道)

1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><meta name=author content="JuicyMio"><link rel=canonical href=https://juicymio.github.io/posts/taint_analysis_note/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://juicymio.github.io/posts/taint_analysis_note/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css integrity=sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js integrity=sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://juicymio.github.io/posts/taint_analysis_note/"><meta property="og:site_name" content="JuicyMio's Blog"><meta property="og:title" content="污点分析学习笔记"><meta property="og:description" content="静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：
程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？ 软件测试？ “Testing shows the presence, not the absence of bugs.” ——Edsger W. Dijkstra
希尔伯特计划 “Wir müssen wissen, wir werden wissen.” ——David Hilbert (我们必须知道，我们必将知道)
1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。 这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为： $$ R = { x \mid x \notin x }, \qquad R \in R \iff R \notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-17T00:00:00+00:00"><meta property="article:tag" content="Pwn"><meta property="article:tag" content="Taint_analysis"><meta property="og:image" content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="污点分析学习笔记"><meta name=twitter:description content="静态分析
静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题
给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：

程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；
程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；
程序P中的类型转换（Type Cast）是否都是安全的；
程序P中是否存在可能无法满足的断言（Assertion Error）；
程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）


是否存在算法能给出该判定问题的答案？
软件测试？
&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra

希尔伯特计划

&ldquo;Wir müssen wissen, wir werden wissen.&rdquo;  ——David Hilbert
(我们必须知道，我们必将知道)

1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juicymio.github.io/posts/"},{"@type":"ListItem","position":2,"name":"污点分析学习笔记","item":"https://juicymio.github.io/posts/taint_analysis_note/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"污点分析学习笔记","name":"污点分析学习笔记","description":"静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。\n缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：\n程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？ 软件测试？ \u0026ldquo;Testing shows the presence, not the absence of bugs.\u0026rdquo; ——Edsger W. Dijkstra\n希尔伯特计划 \u0026ldquo;Wir müssen wissen, wir werden wissen.\u0026rdquo; ——David Hilbert (我们必须知道，我们必将知道)\n1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。\n希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。 这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为： $$ R = { x \\mid x \\notin x }, \\qquad R \\in R \\iff R \\notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。\n","keywords":["pwn","taint_analysis"],"articleBody":"静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。\n缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：\n程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？ 软件测试？ “Testing shows the presence, not the absence of bugs.” ——Edsger W. Dijkstra\n希尔伯特计划 “Wir müssen wissen, wir werden wissen.” ——David Hilbert (我们必须知道，我们必将知道)\n1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。\n希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。 这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为： $$ R = { x \\mid x \\notin x }, \\qquad R \\in R \\iff R \\notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。\n哥德尔不完备定理 1930年9月7日，时年25岁的哥德尔（Kurt Friedrich Gödel, 1906-1978）发表了著名的“不完备性定理”：“如果数学是一致的，那么它就是不完备的”。具体地说，哥德尔证明了 ：任何一个包含算术系统在内的数学系统不可能同时是完备的和一致的。换句话说，人们如果能在一个数学系统中做算术的话，那么这个系统或者是自相矛盾的，或者存在一些定理在这个系统内是无法证明的。其次，他证明了，对于任意一个包含算术系统的数学系统来说，不可能在这个系统内部证明它本身的一致性。\n希尔伯特别无选择，对计划作了修正，取消了有限步骤这个约束。随后，根茨（G.Gentaen, 1909-1945）于1936年使用某种非形式化方法（超限归纳法）证明了算术公理系统的一致性。\n内存泄漏判定 前面这些理论和程序分析有什么关系呢？\n主流程序语言能表示自然数和基本运算（语法+语义=能表示自然数的形式系统） 注意数学上的自然数是无限的，不等价于Int 在现代数学中，任何自动证明算法必须以某种形式系统为基础 对逻辑学不熟悉的同学可以理解为公理+推导规则 设在所使用的形式系统中有表达式T不能被证明 a=malloc() if (T) free(a); return; 若T为永真式，则没有内存泄漏，否则就可能有。由于无法证明T，所以无法判断是否内存泄漏。 停机问题 是否存在一个算法，能够对任意程序 $P$ 和输入 $x$，判断 $P(x)$是否会在有限时间内停机？\n图灵于1936年证明：不存在一个算法能回答停机问题。（此时计算机还没有被发明出来，图灵顺便提出了图灵机模型。）\n证明 假设存在停机问题判定算法: bool Halt(p)，其中p为特定程序。 给定某邪恶程序\nvoid Evil() { if (!Halt(Evil)) return; else while(1); } Halt(Evil)的返回值如果为真，则Evil不停机，矛盾。如果为假，则Evil停机，又矛盾。这个证明是由假设Halt存在并构造自指共同推出的，与罗素悖论同源。\n无内存泄漏算法？ 假设存在算法：bool LeakFree(Program p) 给定\nvoid Evil() { int a = malloc(); if (LeakFree(Evil)) return; else free(a); } 就会产生与停机问题类似的矛盾。\n可判定问题 判定问题（Decision Problem）：回答是/否的问题 可判定问题（Decidable Problem）是一个判定问题，该问题存在一个算法，使得对于该问题的每一个实例都能给出是/否的答案。 由前面的分析我们可以得出：停机问题是不可判定问题，确定程序有无内存泄露是不可判定问题。 Rice定理 $$ \\text{If } \\mathcal{P} \\text{ is a non-trivial semantic property of } {\\varphi_e}, \\text{ then } { e \\mid \\varphi_e \\in \\mathcal{P} } \\text{ is undecidable.} $$ 原本的莱斯定理定义在递归可枚举语言上，下面为了解释方便采用了等价的说法，并默认程序由图灵机定义。 我们可以把任意程序看成一个从输入到输出上的函数（输入输出对的集合），该函数描述了程序的行为。\n关于该函数/集合的任何非平凡属性，都不存在可以检查该属性的通用算法。 平凡属性：要么对全体程序都为真，要么对全体程序都为假 非平凡属性：不是平凡属性的所有属性 关于程序行为：即能定义在函数上的属性 也就是说任何关于程序“做什么”的非平凡问题，都是不可判定的。 注意：不符合莱斯定理定义也不代表可判定。 证明 反证法：给定函数上的非平凡性质P。\n首先假设空集（对任何输入都不输出的程序）不满足P。 因为P非平凡，所以一定存在程序使得P满足，记为 ok_prog。 假设检测该性质P的算法为P_holds。 我们可以编写如下函数来检测程序q是否停机 bool halt(Program q) { void evil(Input n) { Output v = ok_prog(n); q(); return v; } return P_holds(evil); } 如果空集满足P，将ok_prog换成一个让P不满足的程序，同样推出矛盾。 静态分析的类型 完美静态分析 如果一个静态分析 $S$ 能够对于程序 $P$ 的某个非平凡性质 $Q$ 给出确切的答案，我们就称 $S$ 是 $P$ 关于 $Q$ 的 完美静态分析（Perfect Static Analysis） 。我们定义程序$P$的关于$Q$的真实行为为 真相（Truth） ，那么完美静态分析有两层含义：\n完全性（Soundness）：真相一定包含在 $S$ 给出的答案中； 正确性（Completeness）：$S$ 给出的答案一定包含在真相中； 记这个静态分析程序给出的答案集合 $A$ ，真相集合为 $T$ ，则完美的静态分析满足： T⊆A∧A⊆T⇔A=T 其中， T⊆A 体现了完全性， A⊆T体现了正确性。 简单理解，一个完美的静态分析给出的答案应当既是对的，也是全的。\n但是Rice定理告诉我们，不存在完美的静态分析。\n那么我们就对程序分析问题束手无策了吗？当然不是的。 近似静态分析 记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 Sound 的静态分析（Sound Static Analysis） ，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 T⊆A ，这种分析策略也称作 过近似（Over-approximation） 。 记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 Complete 的静态分析（Complete Static Analysis），当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 A⊆T ，这种分析策略也称作 欠近似（Under-approximation） 。 其中\nSound 的静态分析保证了完全性，妥协了正确性，会过近似（Overapproximate）程序的行为，因此会出现假阳性（False Positive）的现象，即判定为阳性，但实际是阴性的。反映在现实场景中即为误报问题。 Complete 的静态分析保证了正确性，妥协了完全性，会欠近似（Underapproximate）程序的行为，因此会出现假阴性（False Negative）现象，即判定为阴性，但实际是阳性。反映在现实场景中即为漏报问题。 实际应用 大多数的静态分析会妥协正确性，保证完全性，即 Sound 的静态分析居多，这样的静态分析虽然不是完美的，但是有用的。以 debug 为例，在实际的开发过程中，Sound 的静态分析可以帮助我们有效的缩小 debug 的范围，我们最多只需要暴力排查掉所有的假阳性实例（False Positive Instance）就可以了。\n参考资料 静态分析\n[math/0508572] Hilbert’s Program Then and Now\n","wordCount":"327","inLanguage":"en","image":"https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-12-17T00:00:00Z","dateModified":"2025-12-17T00:00:00Z","author":[{"@type":"Person","name":"JuicyMio"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://juicymio.github.io/posts/taint_analysis_note/"},"publisher":{"@type":"Organization","name":"JuicyMio's Blog","logo":{"@type":"ImageObject","url":"https://juicymio.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://juicymio.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://juicymio.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juicymio.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://juicymio.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juicymio.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juicymio.github.io/friends/ title=friends><span>friends</span></a></li><li><a href=https://juicymio.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juicymio.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juicymio.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">污点分析学习笔记</h1><div class=post-meta><span title='2025-12-17 00:00:00 +0000 UTC'>December 17, 2025</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>327 words</span>&nbsp;·&nbsp;<span>JuicyMio</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/taint_analysis_note/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#静态分析>静态分析</a><ul><li><a href=#缺陷检测问题>缺陷检测问题</a></li><li><a href=#希尔伯特计划>希尔伯特计划</a></li><li><a href=#哥德尔不完备定理>哥德尔不完备定理</a></li><li><a href=#内存泄漏判定>内存泄漏判定</a></li><li><a href=#停机问题>停机问题</a></li><li><a href=#可判定问题>可判定问题</a></li><li><a href=#rice定理>Rice定理</a></li><li><a href=#静态分析的类型>静态分析的类型</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><h2 id=静态分析>静态分析<a hidden class=anchor aria-hidden=true href=#静态分析>#</a></h2><p><strong>静态分析（Static Analysis）</strong> 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 <strong>性质（Property）</strong> $Q$ 。</p><h3 id=缺陷检测问题>缺陷检测问题<a hidden class=anchor aria-hidden=true href=#缺陷检测问题>#</a></h3><p>给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：</p><ul><li>程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；</li><li>程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；</li><li>程序P中的类型转换（Type Cast）是否都是安全的；</li><li>程序P中是否存在可能无法满足的断言（Assertion Error）；</li><li>程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）</li></ul><blockquote><p>是否存在算法能给出该判定问题的答案？
软件测试？
&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra</p></blockquote><h3 id=希尔伯特计划>希尔伯特计划<a hidden class=anchor aria-hidden=true href=#希尔伯特计划>#</a></h3><blockquote><p>&ldquo;Wir müssen wissen, wir werden wissen.&rdquo; ——David Hilbert
(我们必须知道，我们必将知道)</p></blockquote><p>1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“<strong>希尔伯特问题</strong>”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。<br>希尔伯特的第二问题是有名的“<strong>判定问题</strong>”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“<strong>希尔伯特计划</strong>”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明<strong>整个数学系统是完备的</strong>，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是<strong>一致的</strong>，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有<strong>可判断性</strong>，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致<strong>自指性矛盾</strong>。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。</p><h3 id=哥德尔不完备定理>哥德尔不完备定理<a hidden class=anchor aria-hidden=true href=#哥德尔不完备定理>#</a></h3><p>1930年9月7日，时年25岁的哥德尔（Kurt Friedrich Gödel, 1906-1978）发表了著名的“不完备性定理”：“<strong>如果数学是一致的，那么它就是不完备的</strong>”。具体地说，哥德尔证明了 ：任何一个包含算术系统在内的数学系统不可能同时是完备的和一致的。换句话说，人们如果能在一个数学系统中做算术的话，那么这个系统或者是自相矛盾的，或者<strong>存在一些定理在这个系统内是无法证明的</strong>。其次，他证明了，对于任意一个<strong>包含算术系统</strong>的数学系统来说，<strong>不可能在这个系统内部证明它本身的一致性</strong>。<br>希尔伯特别无选择，对计划作了修正，取消了有限步骤这个约束。随后，根茨（G.Gentaen, 1909-1945）于1936年使用某种非形式化方法（超限归纳法）证明了算术公理系统的一致性。</p><h3 id=内存泄漏判定>内存泄漏判定<a hidden class=anchor aria-hidden=true href=#内存泄漏判定>#</a></h3><p>前面这些理论和程序分析有什么关系呢？</p><ul><li>主流程序语言能表示自然数和基本运算（语法+语义=能表示自然数的形式系统）<ul><li>注意数学上的自然数是无限的，不等价于Int</li></ul></li><li>在现代数学中，任何自动证明算法必须以某种形式系统为基础<ul><li>对逻辑学不熟悉的同学可以理解为公理+推导规则</li></ul></li><li>设在所使用的形式系统中有表达式T不能被证明<ul><li>a=malloc()</li><li>if (T) free(a);</li><li>return;
若T为永真式，则没有内存泄漏，否则就可能有。由于无法证明T，所以无法判断是否内存泄漏。</li></ul></li></ul><h3 id=停机问题>停机问题<a hidden class=anchor aria-hidden=true href=#停机问题>#</a></h3><p>是否存在一个算法，能够对任意程序 $P$ 和输入 $x$，判断 $P(x)$是否会在有限时间内停机？<br>图灵于1936年证明：不存在一个算法能回答停机问题。（此时计算机还没有被发明出来，图灵顺便提出了图灵机模型。）</p><h4 id=证明>证明<a hidden class=anchor aria-hidden=true href=#证明>#</a></h4><p>假设存在停机问题判定算法: <code>bool Halt(p)</code>，其中p为特定程序。
给定某邪恶程序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Evil</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>Halt</span><span class=p>(</span><span class=n>Evil</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Halt(Evil)的返回值如果为真，则Evil不停机，矛盾。如果为假，则Evil停机，又矛盾。这个证明是由假设Halt存在并构造自指共同推出的，与罗素悖论同源。</p><h4 id=无内存泄漏算法>无内存泄漏算法？<a hidden class=anchor aria-hidden=true href=#无内存泄漏算法>#</a></h4><p>假设存在算法：<code>bool LeakFree(Program p)</code>
给定</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Evil</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>LeakFree</span><span class=p>(</span><span class=n>Evil</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>就会产生与停机问题类似的矛盾。</p><h3 id=可判定问题>可判定问题<a hidden class=anchor aria-hidden=true href=#可判定问题>#</a></h3><ul><li>判定问题（Decision Problem）：回答是/否的问题</li><li>可判定问题（Decidable Problem）是一个判定问题，该问题存在一个算法，使得对于该问题的每一个实例都能给出是/否的答案。
由前面的分析我们可以得出：停机问题是不可判定问题，确定程序有无内存泄露是不可判定问题。</li></ul><h3 id=rice定理>Rice定理<a hidden class=anchor aria-hidden=true href=#rice定理>#</a></h3><p>$$
\text{If } \mathcal{P} \text{ is a non-trivial semantic property of }
{\varphi_e},
\text{ then } { e \mid \varphi_e \in \mathcal{P} }
\text{ is undecidable.}
$$
原本的莱斯定理定义在递归可枚举语言上，下面为了解释方便采用了等价的说法，并默认程序由图灵机定义。
我们可以把任意程序看成一个从输入到输出上的函数（输入输出对的集合），该函数描述了程序的行为。</p><ul><li>关于该函数/集合的任何非平凡属性，都不存在可以检查该属性的通用算法。</li><li>平凡属性：要么对全体程序都为真，要么对全体程序都为假</li><li>非平凡属性：不是平凡属性的所有属性</li><li>关于程序行为：即能定义在函数上的属性
也就是说<strong>任何关于程序“做什么”的非平凡问题，都是不可判定的。</strong>
注意：不符合莱斯定理定义也不代表可判定。</li></ul><h4 id=证明-1>证明<a hidden class=anchor aria-hidden=true href=#证明-1>#</a></h4><p>反证法：给定函数上的非平凡性质P。</p><ul><li>首先假设空集（对任何输入都不输出的程序）不满足P。<ul><li>因为P非平凡，所以一定存在程序使得P满足，记为 ok_prog。</li><li>假设检测该性质P的算法为P_holds。</li></ul></li><li>我们可以编写如下函数来检测程序q是否停机<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>halt</span><span class=p>(</span><span class=n>Program</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>evil</span><span class=p>(</span><span class=n>Input</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>Output</span> <span class=n>v</span> <span class=o>=</span> <span class=nf>ok_prog</span><span class=p>(</span><span class=n>n</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>		<span class=nf>q</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>v</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>		<span class=p>}</span> 
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>P_holds</span><span class=p>(</span><span class=n>evil</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>如果空集满足P，将ok_prog换成一个让P不满足的程序，同样推出矛盾。</li></ul><h3 id=静态分析的类型>静态分析的类型<a hidden class=anchor aria-hidden=true href=#静态分析的类型>#</a></h3><h4 id=完美静态分析>完美静态分析<a hidden class=anchor aria-hidden=true href=#完美静态分析>#</a></h4><p>如果一个静态分析 $S$ 能够对于程序 $P$ 的某个非平凡性质 $Q$ 给出确切的答案，我们就称 $S$ 是 $P$ 关于 $Q$ 的 <strong>完美静态分析（Perfect Static Analysis）</strong> 。我们定义程序$P$的关于$Q$的真实行为为 <strong>真相（Truth）</strong> ，那么完美静态分析有两层含义：</p><ul><li><strong>完全性（Soundness）</strong>：真相一定包含在 $S$ 给出的答案中；</li><li><strong>正确性（Completeness）</strong>：$S$ 给出的答案一定包含在真相中；
记这个静态分析程序给出的答案集合 $A$ ，真相集合为 $T$ ，则完美的静态分析满足：
T⊆A∧A⊆T⇔A=T
其中， T⊆A 体现了完全性， A⊆T体现了正确性。
简单理解，一个完美的静态分析给出的答案应当既是对的，也是全的。<br>但是Rice定理告诉我们，不存在完美的静态分析。<br>那么我们就对程序分析问题束手无策了吗？当然不是的。</li></ul><h4 id=近似静态分析>近似静态分析<a hidden class=anchor aria-hidden=true href=#近似静态分析>#</a></h4><p>记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 <strong>Sound 的静态分析（Sound Static Analysis）</strong> ，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 T⊆A ，这种分析策略也称作 <strong>过近似（Over-approximation）</strong> 。
记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为  <strong>Complete 的静态分析（Complete Static Analysis）</strong>，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 A⊆T ，这种分析策略也称作 <strong>欠近似（Under-approximation）</strong> 。
其中</p><ul><li>Sound 的静态分析保证了完全性，妥协了正确性，会过近似（Overapproximate）程序的行为，因此会出现假阳性（False Positive）的现象，即判定为阳性，但实际是阴性的。反映在现实场景中即为误报问题。</li><li><img loading=lazy src=/posts/taint_analysis_note/index-1.png></li><li>Complete 的静态分析保证了正确性，妥协了完全性，会欠近似（Underapproximate）程序的行为，因此会出现假阴性（False Negative）现象，即判定为阴性，但实际是阳性。反映在现实场景中即为漏报问题。</li><li><img loading=lazy src=/posts/taint_analysis_note/index-2.png></li></ul><h4 id=实际应用>实际应用<a hidden class=anchor aria-hidden=true href=#实际应用>#</a></h4><p>大多数的静态分析会妥协正确性，保证完全性，即 Sound 的静态分析居多，这样的静态分析虽然不是完美的，但是有用的。以 debug 为例，在实际的开发过程中，Sound 的静态分析可以帮助我们有效的缩小 debug 的范围，我们最多只需要暴力排查掉所有的假阳性实例（False Positive Instance）就可以了。</p><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://static-analysis.cuijiacai.com/>静态分析</a><br><a href=https://arxiv.org/abs/math/0508572>[math/0508572] Hilbert&rsquo;s Program Then and Now</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juicymio.github.io/tags/pwn/>Pwn</a></li><li><a href=https://juicymio.github.io/tags/taint_analysis/>Taint_analysis</a></li></ul><nav class=paginav><a class=next href=https://juicymio.github.io/posts/ccbciscn/><span class=title>Next »</span><br><span>ccbciscn pwn wp</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://juicymio.github.io/>JuicyMio's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>