<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>污点分析学习笔记（一）：程序分析基础 | JuicyMio's Blog</title><meta name=keywords content="pwn,taint_analysis"><meta name=description content="静态分析
静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题
给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：

程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；
程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；
程序P中的类型转换（Type Cast）是否都是安全的；
程序P中是否存在可能无法满足的断言（Assertion Error）；
程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）


是否存在算法能给出该判定问题的答案？
软件测试？
&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra

希尔伯特计划

&ldquo;Wir müssen wissen, wir werden wissen.&rdquo;  ——David Hilbert 
(我们必须知道，我们必将知道)

1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><meta name=author content="JuicyMio"><link rel=canonical href=https://juicymio.github.io/posts/taint_analysis_note/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://juicymio.github.io/posts/taint_analysis_note/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.css integrity=sha384-Pu5+C18nP5dwykLJOhd2U4Xen7rjScHN/qusop27hdd2drI+lL5KvX7YntvT8yew crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/katex.min.js integrity=sha384-2B8pfmZZ6JlVoScJm/5hQfNS2TI/6hPqDZInzzPc8oHpN5SgeNOf4LzREO6p5YtZ crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.27/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://juicymio.github.io/posts/taint_analysis_note/"><meta property="og:site_name" content="JuicyMio's Blog"><meta property="og:title" content="污点分析学习笔记（一）：程序分析基础"><meta property="og:description" content="静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：
程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？
软件测试？
“Testing shows the presence, not the absence of bugs.” ——Edsger W. Dijkstra
希尔伯特计划 “Wir müssen wissen, wir werden wissen.” ——David Hilbert (我们必须知道，我们必将知道)
1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$ R = { x \mid x \notin x }, \qquad R \in R \iff R \notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-17T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-17T00:00:00+00:00"><meta property="article:tag" content="Pwn"><meta property="article:tag" content="Taint_analysis"><meta property="og:image" content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="污点分析学习笔记（一）：程序分析基础"><meta name=twitter:description content="静态分析
静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。
缺陷检测问题
给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：

程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；
程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；
程序P中的类型转换（Type Cast）是否都是安全的；
程序P中是否存在可能无法满足的断言（Assertion Error）；
程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）


是否存在算法能给出该判定问题的答案？
软件测试？
&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra

希尔伯特计划

&ldquo;Wir müssen wissen, wir werden wissen.&rdquo;  ——David Hilbert 
(我们必须知道，我们必将知道)

1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。
希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。
这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：
$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juicymio.github.io/posts/"},{"@type":"ListItem","position":2,"name":"污点分析学习笔记（一）：程序分析基础","item":"https://juicymio.github.io/posts/taint_analysis_note/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"污点分析学习笔记（一）：程序分析基础","name":"污点分析学习笔记（一）：程序分析基础","description":"静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。\n缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：\n程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？\n软件测试？\n\u0026ldquo;Testing shows the presence, not the absence of bugs.\u0026rdquo; ——Edsger W. Dijkstra\n希尔伯特计划 \u0026ldquo;Wir müssen wissen, wir werden wissen.\u0026rdquo; ——David Hilbert (我们必须知道，我们必将知道)\n1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。\n希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。\n这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：\n$$ R = { x \\mid x \\notin x }, \\qquad R \\in R \\iff R \\notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。\n","keywords":["pwn","taint_analysis"],"articleBody":"静态分析 静态分析（Static Analysis） 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 性质（Property） $Q$ 。\n缺陷检测问题 给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。 我们可能关注的程序性质（缺陷）可能有：\n程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）； 程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）； 程序P中的类型转换（Type Cast）是否都是安全的； 程序P中是否存在可能无法满足的断言（Assertion Error）； 程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码） 是否存在算法能给出该判定问题的答案？\n软件测试？\n“Testing shows the presence, not the absence of bugs.” ——Edsger W. Dijkstra\n希尔伯特计划 “Wir müssen wissen, wir werden wissen.” ——David Hilbert (我们必须知道，我们必将知道)\n1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“希尔伯特问题”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。\n希尔伯特的第二问题是有名的“判定问题”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。 为了这个目标，他制定了一个后人称之为“希尔伯特计划”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明整个数学系统是完备的，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是一致的，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有可判断性，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。\n这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：\n$$ R = { x \\mid x \\notin x }, \\qquad R \\in R \\iff R \\notin R. $$ 简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致自指性矛盾。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。\n哥德尔不完备定理 1930年9月7日，时年25岁的哥德尔（Kurt Friedrich Gödel, 1906-1978）发表了著名的“不完备性定理”：“如果数学是一致的，那么它就是不完备的”。具体地说，哥德尔证明了 ：任何一个包含算术系统在内的数学系统不可能同时是完备的和一致的。换句话说，人们如果能在一个数学系统中做算术的话，那么这个系统或者是自相矛盾的，或者存在一些定理在这个系统内是无法证明的。其次，他证明了，对于任意一个包含算术系统的数学系统来说，不可能在这个系统内部证明它本身的一致性。\n希尔伯特别无选择，对计划作了修正，取消了有限步骤这个约束。随后，根茨（G.Gentaen, 1909-1945）于1936年使用某种非形式化方法（超限归纳法）证明了算术公理系统的一致性。\n内存泄漏判定 前面这些理论和程序分析有什么关系呢？\n主流程序语言能表示自然数和基本运算（语法+语义=能表示自然数的形式系统） 注意数学上的自然数是无限的，不等价于Int 在现代数学中，任何自动证明算法必须以某种形式系统为基础 对逻辑学不熟悉的同学可以理解为公理+推导规则 设在所使用的形式系统中有表达式T不能被证明 a=malloc() if (T) free(a); return; 若T为永真式，则没有内存泄漏，否则就可能有。由于无法证明T，所以无法判断是否内存泄漏。 停机问题 是否存在一个算法，能够对任意程序 $P$ 和输入 $x$，判断 $P(x)$是否会在有限时间内停机？\n图灵于1936年证明：不存在一个算法能回答停机问题。（此时计算机还没有被发明出来，图灵顺便提出了图灵机模型。）\n证明 假设存在停机问题判定算法: bool Halt(p)，其中p为特定程序。 给定某邪恶程序\nvoid Evil() { if (!Halt(Evil)) return; else while(1); } Halt(Evil)的返回值如果为真，则Evil不停机，矛盾。如果为假，则Evil停机，又矛盾。这个证明是由假设Halt存在并构造自指共同推出的，与罗素悖论同源。\n无内存泄漏算法？ 假设存在算法：bool LeakFree(Program p) 给定\nvoid Evil() { int a = malloc(); if (LeakFree(Evil)) return; else free(a); } 就会产生与停机问题类似的矛盾。\n可判定问题 判定问题（Decision Problem）：回答是/否的问题 可判定问题（Decidable Problem）是一个判定问题，该问题存在一个算法，使得对于该问题的每一个实例都能给出是/否的答案。 由前面的分析我们可以得出：停机问题是不可判定问题，确定程序有无内存泄露是不可判定问题。 Rice定理 $$ \\text{If } \\mathcal{P} \\text{ is a non-trivial semantic property of } {\\varphi_e}, \\text{ then } { e \\mid \\varphi_e \\in \\mathcal{P} } \\text{ is undecidable.} $$ 原本的莱斯定理定义在递归可枚举语言上，下面为了解释方便采用了等价的说法，并默认程序由图灵机定义。\n我们可以把任意程序看成一个从输入到输出上的函数（输入输出对的集合），该函数描述了程序的行为。\n关于该函数/集合的任何非平凡属性，都不存在可以检查该属性的通用算法。 平凡属性：要么对全体程序都为真，要么对全体程序都为假 非平凡属性：不是平凡属性的所有属性 关于程序行为：即能定义在函数上的属性 也就是说任何关于程序“做什么”的非平凡问题，都是不可判定的。\n注意：不符合莱斯定理定义也不代表可判定。 证明 反证法：给定函数上的非平凡性质P。\n首先假设空集（对任何输入都不输出的程序）不满足P。 因为P非平凡，所以一定存在程序使得P满足，记为 ok_prog。 假设检测该性质P的算法为P_holds。 我们可以编写如下函数来检测程序q是否停机 bool halt(Program q) { void evil(Input n) { Output v = ok_prog(n); q(); return v; } return P_holds(evil); } 如果空集满足P，将ok_prog换成一个让P不满足的程序，同样推出矛盾。 静态分析的类型 完美静态分析 如果一个静态分析 $S$ 能够对于程序 $P$ 的某个非平凡性质 $Q$ 给出确切的答案，我们就称 $S$ 是 $P$ 关于 $Q$ 的 完美静态分析（Perfect Static Analysis） 。我们定义程序$P$的关于$Q$的真实行为为 真相（Truth） ，那么完美静态分析有两层含义：\n完全性（Soundness）：真相一定包含在 $S$ 给出的答案中； 正确性（Completeness）：$S$ 给出的答案一定包含在真相中；\n记这个静态分析程序给出的答案集合 $A$ ，真相集合为 $T$ ，则完美的静态分析满足：\nT⊆A∧A⊆T⇔A=T\n其中， T⊆A 体现了完全性， A⊆T体现了正确性。\n简单理解，一个完美的静态分析给出的答案应当既是对的，也是全的。 但是Rice定理告诉我们，不存在完美的静态分析。 那么我们就对程序分析问题束手无策了吗？当然不是的。 近似静态分析 记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 Sound 的静态分析（Sound Static Analysis） ，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 T⊆A ，这种分析策略也称作 过近似（Over-approximation） 。\n记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 Complete 的静态分析（Complete Static Analysis），当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 A⊆T ，这种分析策略也称作 欠近似（Under-approximation） 。\n其中\nSound 的静态分析保证了完全性，妥协了正确性，会过近似（Overapproximate）程序的行为，因此会出现假阳性（False Positive）的现象，即判定为阳性，但实际是阴性的。反映在现实场景中即为误报问题。 Complete 的静态分析保证了正确性，妥协了完全性，会欠近似（Underapproximate）程序的行为，因此会出现假阴性（False Negative）现象，即判定为阴性，但实际是阳性。反映在现实场景中即为漏报问题。 实际应用 大多数的静态分析会妥协正确性，保证完全性，即 Sound 的静态分析居多，这样的静态分析虽然不是完美的，但是有用的。以 debug 为例，在实际的开发过程中，Sound 的静态分析可以帮助我们有效的缩小 debug 的范围，我们最多只需要暴力排查掉所有的假阳性实例（False Positive Instance）就可以了。\n抽象 概念：通过舍弃程序的一些细节，把原本精确但不可判定或计算量过大的语义问题映射到一个可计算、可分析的抽象模型中。\n当我们考虑程序P的性质 $Q$ 时，程序 $P$ 中的各种值，我们或许不一定非得事无巨细。比如说，当我们考虑除零错误（Zero Division Error）的时候，对于某个值，我们只需要判定其是否为 $0$ 即可，至于它具体是多大，我们其实不关心，因为它和我们要研究的性质 $Q$ 没有直接关联。\n这种将 $P$ 中的值的，和我们需要研究的性质 $Q$ 相关的性质提取出来，从而忽略其他细节的过程，就是一个抽象的过程。我们可以将这个过程形式化的定义出来：\n对于程序 $P$ 的某个 具体值集（Concrete Domain） $D_C$ ，静态分析 $S$ 基于要研究的性质 $Q$ 设计一个 抽象值集（Abstract Domain） $D_A$ （一般 $|D_A| \u003c |D_C|$ ，因为这样的设计才有简化问题的意义），并建立映射关系 $f_{D_C \\to D_A}$ （ $f_1 \\subseteq D_C \\times D_A$ ），这个过程称之为 $S$ 对 $P$ 关于 $Q$ 的 抽象（Abstraction） 过程。\n其中， $D_A$ 中通常有两个特殊的值： $\\top$ 表示 未确定（Unknown） 值， $\\bot$ 表示 未定义（Undefined） 值，即通常 $\\top \\in D_A \\wedge \\bot \\in D_A$ ，并且通常 $\\top$ 和 $\\bot$ 会是程序中的表达式的值，因此我们还需要定义基于 $D_A$ 的运算（定义1.8）来理解 $\\top$ 和 $\\bot$ 。\n当我们定义了 $D_A$ 和 $f_{D_C\\to D_A}$ 之后，与 $D_C$ 有关的表达式的抽象值也应当能够随之确定，为此，我们还需要定义状态转移函数。\n记 $f_1 = f_{D_C \\to D_A}$ 考虑程序 $P$ 关于 $D_C$ 的二元操作集 $Op$ ，我们可以建立映射 $f_2 = f_{Op \\times D_A \\times D_A \\to D_A}$ （ $f_2 \\subseteq Op \\times D_A \\times D_A\\times D_A$ ），这样，我们就可以将所有 $D_c$ 相关的表达式的值通过 $f_2 \\circ f_1$ 也映射到 $D_A$。其中 $f_1$ 称为 状态函数（State Function） ， $f_2$ 称为 转移函数（Transfer Function） 。\n由此可见，状态函数定义了我们如何将具体值转化为抽象值，转移函数定义了我们如何基于抽象值去 解析（Evaluate） 表达式。\n这里需要额外说明一下，我们定义了 $Op$ 为二元操作集，其原因是之后会学到三地址码（Three-Address Code, 3AC） ，从而我们能够发现二元操作集表达能力的完备性，因此这里可以将 $Op$ 定义为二元操作。\n关于静态分析的例子\n常见抽象形式：\n数据抽象：将具体值映射到类型、符号或范围。 控制流抽象：将无限循环或递归压缩到有限状态机。 抽象解释（Abstract Interpretation）：通过抽象域计算上界/下界信息。 搜索 概念：通过在程序状态空间或执行路径空间中进行系统性搜索，探索程序可能行为。\n目的是找到具体可执行的路径，尤其是错误路径或敏感数据流路径。 代价是可能遗漏未搜索到的路径（false negatives）或状态爆炸。 抽象通常考虑程序所有的执行，包括整个输入空间和任意长度的执行路径，但给出不精确的结果。往往是过近似的。 搜索通常只考虑一部分执行，包括有限的输入空间和有限的执行路径长度，但对于这部分执行给出精确的分析，是一种欠近似。 二者可以结合 具体方法 基于抽象解释的程序分析 数据流分析 如何对分支、循环等控制结构进行抽象 过程间分析 如何对函数调用关系进行抽象 指针分析 如何对堆上的指向结构进行抽象 解决别名（alias）问题 抽象解释 对于抽象的通用理论 抽象解释的自动化 基于约束求解的程序分析 SAT 基础可满足性问题 SMT 通用可满足性问题 符号执行 基于约束求解对部分执行路径进行程序分析 污点分析中的应用 数据流分析 污点传播可以看作一种数据流分析： 每个变量的状态被抽象为 tainted或 untainted 控制流抽象： 分支：在 if/else 中对每个分支分别计算污点状态，然后合并 循环：用固定点迭代计算循环内污点状态，直到不再变化 过程间分析 跨函数污点传播： 把函数输入抽象为污点/非污点标记 函数返回值和副作用也用相同抽象表示 调用图抽象： 对递归调用或间接调用使用固定点计算或上下文敏感抽象 指针分析 堆对象的污点传播： 每个堆对象或内存块抽象为一个标记或抽象节点 指针指向关系抽象为指向集（points-to set） 别名处理： 如果多个指针可能指向同一对象，任何指针污点都会影响该对象 符号执行 参考资料 静态分析\n[math/0508572] Hilbert’s Program Then and Now https://xiongyingfei.github.io/SA_new/2025/slides/slides01_intro.pdf\n","wordCount":"538","inLanguage":"en","image":"https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-12-17T00:00:00Z","dateModified":"2025-12-17T00:00:00Z","author":[{"@type":"Person","name":"JuicyMio"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://juicymio.github.io/posts/taint_analysis_note/"},"publisher":{"@type":"Organization","name":"JuicyMio's Blog","logo":{"@type":"ImageObject","url":"https://juicymio.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://juicymio.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://juicymio.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juicymio.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://juicymio.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juicymio.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juicymio.github.io/friends/ title=friends><span>friends</span></a></li><li><a href=https://juicymio.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juicymio.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juicymio.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">污点分析学习笔记（一）：程序分析基础</h1><div class=post-meta><span title='2025-12-17 00:00:00 +0000 UTC'>December 17, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>538 words</span>&nbsp;·&nbsp;<span>JuicyMio</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/taint_analysis_note/index.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#静态分析>静态分析</a><ul><li><a href=#缺陷检测问题>缺陷检测问题</a></li><li><a href=#希尔伯特计划>希尔伯特计划</a></li><li><a href=#哥德尔不完备定理>哥德尔不完备定理</a></li><li><a href=#内存泄漏判定>内存泄漏判定</a></li><li><a href=#停机问题>停机问题</a></li><li><a href=#可判定问题>可判定问题</a></li><li><a href=#rice定理>Rice定理</a></li><li><a href=#静态分析的类型>静态分析的类型</a></li><li><a href=#抽象>抽象</a></li><li><a href=#搜索>搜索</a></li><li><a href=#具体方法>具体方法</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></details></div><div class=post-content><h2 id=静态分析>静态分析<a hidden class=anchor aria-hidden=true href=#静态分析>#</a></h2><p><strong>静态分析（Static Analysis）</strong> 是指在实际运行程序 $P$ 之前，通过分析静态程序 $P$ 本身来推测程序的行为，并判断程序是否满足某些特定的 <strong>性质（Property）</strong> $Q$ 。</p><h3 id=缺陷检测问题>缺陷检测问题<a hidden class=anchor aria-hidden=true href=#缺陷检测问题>#</a></h3><p>给定某程序 $P$与某种类型的缺陷（如内存泄露），输出程序$P$是否存在给定类型的缺陷。
我们可能关注的程序性质（缺陷）可能有：</p><ul><li>程序P是否会产生私有信息泄漏（Private Information Leak），或者说是否存在访问控制漏洞（Access Control Vulnerability）；</li><li>程序P是否有空指针的解引用(Null Pointer Dereference)操作，更一般的，是否会发生不可修复的运行时错误（Runtime Error）；</li><li>程序P中的类型转换（Type Cast）是否都是安全的；</li><li>程序P中是否存在可能无法满足的断言（Assertion Error）；</li><li>程序P中是否存在死代码（Dead Code, 即控制流在任何情况下都无法到达的代码）</li></ul><blockquote><p>是否存在算法能给出该判定问题的答案？<br>软件测试？<br>&ldquo;Testing shows the presence, not the absence of bugs.&rdquo; ——Edsger W. Dijkstra</p></blockquote><h3 id=希尔伯特计划>希尔伯特计划<a hidden class=anchor aria-hidden=true href=#希尔伯特计划>#</a></h3><blockquote><p>&ldquo;Wir müssen wissen, wir werden wissen.&rdquo; ——David Hilbert<br>(我们必须知道，我们必将知道)</p></blockquote><p>1900 年，38岁的希尔伯特在巴黎举行的第二届国际数学会议上以“数学问题”为题的演讲中提出了23个重要的数学难题，即众所周知的“<strong>希尔伯特问题</strong>”，激励和推动了后来一个多世纪许多数学分支的蓬勃发展。简而言之，希尔伯特的第1-6问题关于数学基础理论，第 7-12 问题关于数论，第13-18问题属于代数和几何，而最后的第19-23问题属于数学分析范畴。经过许多数学家长期的努力，目前大多数问题都得到了完全或部分解答。<br>希尔伯特的第二问题是有名的“<strong>判定问题</strong>”。它至关重要，涉及整个数学基础，关心数学是否完备和一致？、是不是所有数学命题都可以通过有限次正确的数学步骤作出判定？希尔伯特雄心勃勃，要将整个数学体系严格公理化，然后用他的所谓“元数学”（证明数学的数学）来证明整个数学体系是坚不可摧的。
为了这个目标，他制定了一个后人称之为“<strong>希尔伯特计划</strong>”的部署 ：首先，将所有数学形式化，把每一个数学陈述都用符号来表达。然后，证明<strong>整个数学系统是完备的</strong>，即对任何一个数学陈述都存在一个数学证明（对所有命题，该命题本身或其否定命题一定能被证明）。同时，还要证明数学是<strong>一致的</strong>，也就是说绝不存在自相矛盾的陈述（任意命题和其否定命题不能同时被证明）。最后，还要具有<strong>可判断性</strong>，存在一个可以实现的算法，通过有限步程序最终判定数学陈述的对错。<br>这个计划的背景是罗素悖论引发的第三次数学危机，罗素悖论的公式表述为：<br>$$
R = { x \mid x \notin x }, \qquad
R \in R \iff R \notin R.
$$
简单来说，罗素悖论揭示了朴素数学直觉在形式化下的不一致性，数学中看似直观、自然的推理方式，在形式化后会导致<strong>自指性矛盾</strong>。希尔伯特计划试图通过形式化和元数学的一致性证明为数学奠定绝对可靠的基础。</p><h3 id=哥德尔不完备定理>哥德尔不完备定理<a hidden class=anchor aria-hidden=true href=#哥德尔不完备定理>#</a></h3><p>1930年9月7日，时年25岁的哥德尔（Kurt Friedrich Gödel, 1906-1978）发表了著名的“不完备性定理”：“<strong>如果数学是一致的，那么它就是不完备的</strong>”。具体地说，哥德尔证明了 ：任何一个包含算术系统在内的数学系统不可能同时是完备的和一致的。换句话说，人们如果能在一个数学系统中做算术的话，那么这个系统或者是自相矛盾的，或者<strong>存在一些定理在这个系统内是无法证明的</strong>。其次，他证明了，对于任意一个<strong>包含算术系统</strong>的数学系统来说，<strong>不可能在这个系统内部证明它本身的一致性</strong>。<br>希尔伯特别无选择，对计划作了修正，取消了有限步骤这个约束。随后，根茨（G.Gentaen, 1909-1945）于1936年使用某种非形式化方法（超限归纳法）证明了算术公理系统的一致性。</p><h3 id=内存泄漏判定>内存泄漏判定<a hidden class=anchor aria-hidden=true href=#内存泄漏判定>#</a></h3><p>前面这些理论和程序分析有什么关系呢？</p><ul><li>主流程序语言能表示自然数和基本运算（语法+语义=能表示自然数的形式系统）<ul><li>注意数学上的自然数是无限的，不等价于Int</li></ul></li><li>在现代数学中，任何自动证明算法必须以某种形式系统为基础<ul><li>对逻辑学不熟悉的同学可以理解为公理+推导规则</li></ul></li><li>设在所使用的形式系统中有表达式T不能被证明<ul><li>a=malloc()</li><li>if (T) free(a);</li><li>return;
若T为永真式，则没有内存泄漏，否则就可能有。由于无法证明T，所以无法判断是否内存泄漏。</li></ul></li></ul><h3 id=停机问题>停机问题<a hidden class=anchor aria-hidden=true href=#停机问题>#</a></h3><p>是否存在一个算法，能够对任意程序 $P$ 和输入 $x$，判断 $P(x)$是否会在有限时间内停机？<br>图灵于1936年证明：不存在一个算法能回答停机问题。（此时计算机还没有被发明出来，图灵顺便提出了图灵机模型。）</p><h4 id=证明>证明<a hidden class=anchor aria-hidden=true href=#证明>#</a></h4><p>假设存在停机问题判定算法: <code>bool Halt(p)</code>，其中p为特定程序。
给定某邪恶程序</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Evil</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>Halt</span><span class=p>(</span><span class=n>Evil</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Halt(Evil)的返回值如果为真，则Evil不停机，矛盾。如果为假，则Evil停机，又矛盾。这个证明是由假设Halt存在并构造自指共同推出的，与罗素悖论同源。</p><h4 id=无内存泄漏算法>无内存泄漏算法？<a hidden class=anchor aria-hidden=true href=#无内存泄漏算法>#</a></h4><p>假设存在算法：<code>bool LeakFree(Program p)</code>
给定</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Evil</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=nf>LeakFree</span><span class=p>(</span><span class=n>Evil</span><span class=p>))</span> <span class=k>return</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=nf>free</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>就会产生与停机问题类似的矛盾。</p><h3 id=可判定问题>可判定问题<a hidden class=anchor aria-hidden=true href=#可判定问题>#</a></h3><ul><li>判定问题（Decision Problem）：回答是/否的问题</li><li>可判定问题（Decidable Problem）是一个判定问题，该问题存在一个算法，使得对于该问题的每一个实例都能给出是/否的答案。
由前面的分析我们可以得出：停机问题是不可判定问题，确定程序有无内存泄露是不可判定问题。</li></ul><h3 id=rice定理>Rice定理<a hidden class=anchor aria-hidden=true href=#rice定理>#</a></h3><p>$$
\text{If } \mathcal{P} \text{ is a non-trivial semantic property of }
{\varphi_e},
\text{ then } { e \mid \varphi_e \in \mathcal{P} }
\text{ is undecidable.}
$$
原本的莱斯定理定义在递归可枚举语言上，下面为了解释方便采用了等价的说法，并默认程序由图灵机定义。<br>我们可以把任意程序看成一个从输入到输出上的函数（输入输出对的集合），该函数描述了程序的行为。</p><ul><li>关于该函数/集合的任何非平凡属性，都不存在可以检查该属性的通用算法。</li><li>平凡属性：要么对全体程序都为真，要么对全体程序都为假</li><li>非平凡属性：不是平凡属性的所有属性</li><li>关于程序行为：即能定义在函数上的属性
也就是说<strong>任何关于程序“做什么”的非平凡问题，都是不可判定的。</strong><br>注意：不符合莱斯定理定义也不代表可判定。</li></ul><h4 id=证明-1>证明<a hidden class=anchor aria-hidden=true href=#证明-1>#</a></h4><p>反证法：给定函数上的非平凡性质P。</p><ul><li>首先假设空集（对任何输入都不输出的程序）不满足P。<ul><li>因为P非平凡，所以一定存在程序使得P满足，记为 ok_prog。</li><li>假设检测该性质P的算法为P_holds。</li></ul></li><li>我们可以编写如下函数来检测程序q是否停机<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>halt</span><span class=p>(</span><span class=n>Program</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>evil</span><span class=p>(</span><span class=n>Input</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>Output</span> <span class=n>v</span> <span class=o>=</span> <span class=nf>ok_prog</span><span class=p>(</span><span class=n>n</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>		<span class=nf>q</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>v</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>		<span class=p>}</span> 
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>P_holds</span><span class=p>(</span><span class=n>evil</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>如果空集满足P，将ok_prog换成一个让P不满足的程序，同样推出矛盾。</li></ul><h3 id=静态分析的类型>静态分析的类型<a hidden class=anchor aria-hidden=true href=#静态分析的类型>#</a></h3><h4 id=完美静态分析>完美静态分析<a hidden class=anchor aria-hidden=true href=#完美静态分析>#</a></h4><p>如果一个静态分析 $S$ 能够对于程序 $P$ 的某个非平凡性质 $Q$ 给出确切的答案，我们就称 $S$ 是 $P$ 关于 $Q$ 的 <strong>完美静态分析（Perfect Static Analysis）</strong> 。我们定义程序$P$的关于$Q$的真实行为为 <strong>真相（Truth）</strong> ，那么完美静态分析有两层含义：</p><ul><li><strong>完全性（Soundness）</strong>：真相一定包含在 $S$ 给出的答案中；</li><li><strong>正确性（Completeness）</strong>：$S$ 给出的答案一定包含在真相中；<br>记这个静态分析程序给出的答案集合 $A$ ，真相集合为 $T$ ，则完美的静态分析满足：<br>T⊆A∧A⊆T⇔A=T<br>其中， T⊆A 体现了完全性， A⊆T体现了正确性。<br>简单理解，一个完美的静态分析给出的答案应当既是对的，也是全的。<br>但是Rice定理告诉我们，不存在完美的静态分析。<br>那么我们就对程序分析问题束手无策了吗？当然不是的。</li></ul><h4 id=近似静态分析>近似静态分析<a hidden class=anchor aria-hidden=true href=#近似静态分析>#</a></h4><p>记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为 <strong>Sound 的静态分析（Sound Static Analysis）</strong> ，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 T⊆A ，这种分析策略也称作 <strong>过近似（Over-approximation）</strong> 。<br>记程序 $P$ 的关于性质 $Q$ 的静态分析$S$为  <strong>Complete 的静态分析（Complete Static Analysis）</strong>，当且仅当 $S$ 给出的答案集合 $A$ 和 $P$ 关于 $Q$ 的真相集合 $T$ 之间满足 A⊆T ，这种分析策略也称作 <strong>欠近似（Under-approximation）</strong> 。<br>其中</p><ul><li>Sound 的静态分析保证了完全性，妥协了正确性，会过近似（Overapproximate）程序的行为，因此会出现假阳性（False Positive）的现象，即判定为阳性，但实际是阴性的。反映在现实场景中即为误报问题。</li><li><img loading=lazy src=/posts/taint_analysis_note/index-1.png></li><li>Complete 的静态分析保证了正确性，妥协了完全性，会欠近似（Underapproximate）程序的行为，因此会出现假阴性（False Negative）现象，即判定为阴性，但实际是阳性。反映在现实场景中即为漏报问题。</li><li><img loading=lazy src=/posts/taint_analysis_note/index-2.png></li></ul><h4 id=实际应用>实际应用<a hidden class=anchor aria-hidden=true href=#实际应用>#</a></h4><p>大多数的静态分析会妥协正确性，保证完全性，即 Sound 的静态分析居多，这样的静态分析虽然不是完美的，但是有用的。以 debug 为例，在实际的开发过程中，Sound 的静态分析可以帮助我们有效的缩小 debug 的范围，我们最多只需要暴力排查掉所有的假阳性实例（False Positive Instance）就可以了。</p><h3 id=抽象>抽象<a hidden class=anchor aria-hidden=true href=#抽象>#</a></h3><p>概念：通过舍弃程序的一些细节，把原本精确但不可判定或计算量过大的语义问题映射到一个可计算、可分析的抽象模型中。<br>当我们考虑程序P的性质 $Q$ 时，程序 $P$ 中的各种值，我们或许不一定非得事无巨细。比如说，当我们考虑除零错误（Zero Division Error）的时候，对于某个值，我们只需要判定其是否为 $0$ 即可，至于它具体是多大，我们其实不关心，因为它和我们要研究的性质 $Q$ 没有直接关联。<br>这种将 $P$ 中的值的，和我们需要研究的性质 $Q$ 相关的性质提取出来，从而忽略其他细节的过程，就是一个抽象的过程。我们可以将这个过程形式化的定义出来：<br>对于程序 $P$ 的某个 <strong>具体值集（Concrete Domain）</strong> $D_C$ ，静态分析 $S$ 基于要研究的性质 $Q$ 设计一个 <strong>抽象值集（Abstract Domain）</strong> $D_A$ （一般 $|D_A| &lt; |D_C|$ ，因为这样的设计才有简化问题的意义），并建立映射关系 $f_{D_C \to D_A}$ （ $f_1 \subseteq D_C \times D_A$ ），这个过程称之为 $S$ 对 $P$ 关于 $Q$ 的 <strong>抽象（Abstraction）</strong> 过程。<br>其中， $D_A$ 中通常有两个特殊的值： $\top$ 表示 <strong>未确定（Unknown）</strong> 值， $\bot$ 表示 <strong>未定义（Undefined）</strong> 值，即通常 $\top \in D_A \wedge \bot \in D_A$ ，并且通常 $\top$ 和 $\bot$ 会是程序中的表达式的值，因此我们还需要定义基于 $D_A$ 的运算（定义1.8）来理解 $\top$ 和 $\bot$ 。</p><p>当我们定义了 $D_A$ 和 $f_{D_C\to D_A}$ 之后，与 $D_C$ 有关的表达式的抽象值也应当能够随之确定，为此，我们还需要定义状态转移函数。</p><p>记 $f_1 = f_{D_C \to D_A}$ 考虑程序 $P$ 关于 $D_C$ 的二元操作集 $Op$ ，我们可以建立映射 $f_2 = f_{Op \times D_A \times D_A \to D_A}$ （ $f_2 \subseteq Op \times D_A \times D_A\times D_A$ ），这样，我们就可以将所有 $D_c$ 相关的表达式的值通过 $f_2 \circ f_1$ 也映射到 $D_A$。其中 $f_1$ 称为 <strong>状态函数（State Function）</strong> ， $f_2$ 称为 <strong>转移函数（Transfer Function）</strong> 。</p><p>由此可见，状态函数定义了我们如何将具体值转化为抽象值，转移函数定义了我们如何基于抽象值去 <strong>解析（Evaluate）</strong> 表达式。</p><blockquote><p>这里需要额外说明一下，我们定义了 $Op$ 为二元操作集，其原因是之后会学到<strong>三地址码（Three-Address Code, 3AC）</strong> ，从而我们能够发现二元操作集表达能力的完备性，因此这里可以将 $Op$ 定义为二元操作。</p></blockquote><p><a href=https://static-analysis.cuijiacai.com/01-intro/#_1-3-2-%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E7%9A%84%E4%BE%8B%E5%AD%90>关于静态分析的例子</a></p><p>常见抽象形式：</p><ul><li>数据抽象：将具体值映射到类型、符号或范围。</li><li>控制流抽象：将无限循环或递归压缩到有限状态机。</li><li>抽象解释（Abstract Interpretation）：通过抽象域计算上界/下界信息。</li></ul><h3 id=搜索>搜索<a hidden class=anchor aria-hidden=true href=#搜索>#</a></h3><p>概念：通过在程序状态空间或执行路径空间中进行系统性搜索，探索程序可能行为。</p><ul><li>目的是<strong>找到具体可执行的路径</strong>，尤其是错误路径或敏感数据流路径。</li><li>代价是可能遗漏未搜索到的路径（false negatives）或状态爆炸。
<img loading=lazy src=/posts/taint_analysis_note/index-3.png></li><li>抽象通常考虑程序所有的执行，包括整个输入空间和任意长度的执行路径，但给出不精确的结果。往往是过近似的。</li><li>搜索通常只考虑一部分执行，包括有限的输入空间和有限的执行路径长度，但对于这部分执行给出精确的分析，是一种欠近似。</li><li>二者可以结合</li></ul><h3 id=具体方法>具体方法<a hidden class=anchor aria-hidden=true href=#具体方法>#</a></h3><h4 id=基于抽象解释的程序分析>基于抽象解释的程序分析<a hidden class=anchor aria-hidden=true href=#基于抽象解释的程序分析>#</a></h4><ul><li>数据流分析<ul><li>如何对分支、循环等控制结构进行抽象</li></ul></li><li>过程间分析<ul><li>如何对函数调用关系进行抽象</li></ul></li><li>指针分析<ul><li>如何对堆上的指向结构进行抽象</li><li>解决别名（alias）问题</li></ul></li><li>抽象解释<ul><li>对于抽象的通用理论</li></ul></li><li>抽象解释的自动化</li></ul><h4 id=基于约束求解的程序分析>基于约束求解的程序分析<a hidden class=anchor aria-hidden=true href=#基于约束求解的程序分析>#</a></h4><ul><li>SAT<ul><li>基础可满足性问题</li></ul></li><li>SMT<ul><li>通用可满足性问题</li></ul></li><li>符号执行<ul><li>基于约束求解对部分执行路径进行程序分析</li></ul></li></ul><h4 id=污点分析中的应用>污点分析中的应用<a hidden class=anchor aria-hidden=true href=#污点分析中的应用>#</a></h4><ul><li>数据流分析<ul><li><strong>污点传播</strong>可以看作一种数据流分析：<ul><li>每个变量的状态被抽象为 <code>tainted</code>或 <code>untainted</code></li></ul></li><li>控制流抽象：<ul><li>分支：在 if/else 中对每个分支分别计算污点状态，然后合并</li><li>循环：用固定点迭代计算循环内污点状态，直到不再变化</li></ul></li></ul></li><li>过程间分析<ul><li><strong>跨函数污点传播</strong>：<ul><li>把函数输入抽象为污点/非污点标记</li><li>函数返回值和副作用也用相同抽象表示</li></ul></li><li>调用图抽象：<ul><li>对递归调用或间接调用使用固定点计算或上下文敏感抽象</li></ul></li></ul></li><li>指针分析<ul><li><strong>堆对象的污点传播</strong>：<ul><li>每个堆对象或内存块抽象为一个标记或抽象节点</li><li>指针指向关系抽象为指向集（points-to set）</li></ul></li><li><strong>别名处理</strong>：<ul><li>如果多个指针可能指向同一对象，任何指针污点都会影响该对象</li></ul></li></ul></li><li>符号执行</li></ul><h2 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h2><p><a href=https://static-analysis.cuijiacai.com/>静态分析</a><br><a href=https://arxiv.org/abs/math/0508572>[math/0508572] Hilbert&rsquo;s Program Then and Now</a>
<a href=https://xiongyingfei.github.io/SA_new/2025/slides/slides01_intro.pdf>https://xiongyingfei.github.io/SA_new/2025/slides/slides01_intro.pdf</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juicymio.github.io/tags/pwn/>Pwn</a></li><li><a href=https://juicymio.github.io/tags/taint_analysis/>Taint_analysis</a></li></ul><nav class=paginav><a class=next href=https://juicymio.github.io/posts/ccbciscn/><span class=title>Next »</span><br><span>ccbciscn pwn wp</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://juicymio.github.io/>JuicyMio's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>