<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>当DEBUG无参数启动时, 我们在debug什么? | JuicyMio's Blog</title>
<meta name=keywords content="汇编语言"><meta name=description content='0x00 前言 好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.
0x01 过程 查了一堆类似"What DEBUG for DOS debug without parameters", &ldquo;What DEBUG open by default"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.
尝试用-u指令反汇编阅读代码, 看不出什么有用信息.
然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000.
尝试将整个程序dump下来, 没找到怎么dump.
于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用:
When DEBUG is started without any parameters the DEBUG prompt, a &ldquo;-&rdquo; appears. The user can then enter one of several one or two-letter subcommands, including &ldquo;A&rdquo; to enter the assembler mode, &ldquo;D&rdquo; to perform a hexadecimal dump, &ldquo;T&rdquo; to trace and &ldquo;U&rdquo; to unassemble (disassemble) a program in memory.'><meta name=author content="JuicyMio"><link rel=canonical href=https://juicymio.github.io/posts/when-debug-starts-with-no-command-line-parameters/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://juicymio.github.io/posts/when-debug-starts-with-no-command-line-parameters/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="当DEBUG无参数启动时, 我们在debug什么?"><meta property="og:description" content='0x00 前言 好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.
0x01 过程 查了一堆类似"What DEBUG for DOS debug without parameters", &ldquo;What DEBUG open by default"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.
尝试用-u指令反汇编阅读代码, 看不出什么有用信息.
然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000.
尝试将整个程序dump下来, 没找到怎么dump.
于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用:
When DEBUG is started without any parameters the DEBUG prompt, a &ldquo;-&rdquo; appears. The user can then enter one of several one or two-letter subcommands, including &ldquo;A&rdquo; to enter the assembler mode, &ldquo;D&rdquo; to perform a hexadecimal dump, &ldquo;T&rdquo; to trace and &ldquo;U&rdquo; to unassemble (disassemble) a program in memory.'><meta property="og:type" content="article"><meta property="og:url" content="https://juicymio.github.io/posts/when-debug-starts-with-no-command-line-parameters/"><meta property="og:image" content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-25T12:22:18+08:00"><meta property="article:modified_time" content="2023-03-25T12:22:18+08:00"><meta property="og:site_name" content="JuicyMio's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="当DEBUG无参数启动时, 我们在debug什么?"><meta name=twitter:description content='0x00 前言 好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.
0x01 过程 查了一堆类似"What DEBUG for DOS debug without parameters", &ldquo;What DEBUG open by default"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.
尝试用-u指令反汇编阅读代码, 看不出什么有用信息.
然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000.
尝试将整个程序dump下来, 没找到怎么dump.
于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用:
When DEBUG is started without any parameters the DEBUG prompt, a &ldquo;-&rdquo; appears. The user can then enter one of several one or two-letter subcommands, including &ldquo;A&rdquo; to enter the assembler mode, &ldquo;D&rdquo; to perform a hexadecimal dump, &ldquo;T&rdquo; to trace and &ldquo;U&rdquo; to unassemble (disassemble) a program in memory.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juicymio.github.io/posts/"},{"@type":"ListItem","position":2,"name":"当DEBUG无参数启动时, 我们在debug什么?","item":"https://juicymio.github.io/posts/when-debug-starts-with-no-command-line-parameters/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"当DEBUG无参数启动时, 我们在debug什么?","name":"当DEBUG无参数启动时, 我们在debug什么?","description":"0x00 前言 好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.\n0x01 过程 查了一堆类似\u0026quot;What DEBUG for DOS debug without parameters\u0026quot;, \u0026ldquo;What DEBUG open by default\u0026quot;之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.\n尝试用-u指令反汇编阅读代码, 看不出什么有用信息.\n然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000.\n尝试将整个程序dump下来, 没找到怎么dump.\n于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用:\nWhen DEBUG is started without any parameters the DEBUG prompt, a \u0026ldquo;-\u0026rdquo; appears. The user can then enter one of several one or two-letter subcommands, including \u0026ldquo;A\u0026rdquo; to enter the assembler mode, \u0026ldquo;D\u0026rdquo; to perform a hexadecimal dump, \u0026ldquo;T\u0026rdquo; to trace and \u0026ldquo;U\u0026rdquo; to unassemble (disassemble) a program in memory.","keywords":["汇编语言"],"articleBody":"0x00 前言 好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.\n0x01 过程 查了一堆类似\"What DEBUG for DOS debug without parameters\", “What DEBUG open by default\"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.\n尝试用-u指令反汇编阅读代码, 看不出什么有用信息.\n然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现add [BX+SI], AL指令对应的机器码是0000.\n尝试将整个程序dump下来, 没找到怎么dump.\n于是再次返回搜索引擎, 仔细阅读Debug (command) - Wikipedia, 找到了这段, 他的第一句话看起来有用:\nWhen DEBUG is started without any parameters the DEBUG prompt, a “-” appears. The user can then enter one of several one or two-letter subcommands, including “A” to enter the assembler mode, “D” to perform a hexadecimal dump, “T” to trace and “U” to unassemble (disassemble) a program in memory.13 DEBUG can also be used as a “DEBUG script” interpreter using the following syntax.\n实际上也没什么想要的信息, 还是不知道debug打开的到底是什么. 后来开始翻下面的reference, 找到了这条:\nSedory, Daniel B. “A Guide to DEBUG”. Retrieved 2014-11-29.\n里面有一段这个:\nA. When DEBUG starts with no command-line parameters, it:\n1) Allocates all 64 KiB of the first free Memory Segment.\n2) The Segment registers, CS, DS, ES and SS are all set to the value of that 64 KiB Segment’s location (CS=DS=ES=SS=Segment Location). 3) The Instruction Pointer (IP) is set to cs:0100 and the Stack Pointer (SP) is set to ss:FFEE (under DOS 3.0 or above).\n4) The registers, AX, BX, CX, DX, BP, SI and DI are cleared to zero along with the flag bits in the Flag Register; with one exception: The Interrupts Flag is set to Enable Interrupts. (See the Appendix, The 8086 CPU Registers for more information.)\nDEBUG会分配空闲的前64KB内存段, 将CS, DS, ES, SS同时指向它也就是将它同时当作代码段, 数据段, 附加段和栈段, IP设为100, SP设为FFEE.\n0x02 结论 所以说, DEBUG无参数打开时只是将第一段空闲内存中的无用数据作为指令序列而已, 并且作为运行在实模式下的单任务系统, DOS的内存分布相当固定, 我的DOSbox每次打开debug, 段寄存器的值都是0DBD. 另外, 上面的“A Guide to DEBUG”是个不错的DEBUG祖传使用指南, 从07年更新到20年, 可能还在持续更新.\n","wordCount":"251","inLanguage":"en","image":"https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-03-25T12:22:18+08:00","dateModified":"2023-03-25T12:22:18+08:00","author":{"@type":"Person","name":"JuicyMio"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juicymio.github.io/posts/when-debug-starts-with-no-command-line-parameters/"},"publisher":{"@type":"Organization","name":"JuicyMio's Blog","logo":{"@type":"ImageObject","url":"https://juicymio.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juicymio.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://juicymio.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juicymio.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://juicymio.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juicymio.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juicymio.github.io/friends/ title=friends><span>friends</span></a></li><li><a href=https://juicymio.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juicymio.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juicymio.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">当DEBUG无参数启动时, 我们在debug什么?</h1><div class=post-meta><span title='2023-03-25 12:22:18 +0800 CST'>March 25, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;251 words&nbsp;·&nbsp;JuicyMio&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/When%20DEBUG%20starts%20with%20no%20command-line%20parameters.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0x00-前言>0x00 前言</a></li><li><a href=#0x01-过程>0x01 过程</a></li><li><a href=#0x02-结论>0x02 结论</a></li></ul></nav></div></details></div><div class=post-content><h2 id=0x00-前言>0x00 前言<a hidden class=anchor aria-hidden=true href=#0x00-前言>#</a></h2><p>好奇无参数启动debug时, debug在对什么程序进行debug, 于是进行一番探究.</p><h2 id=0x01-过程>0x01 过程<a hidden class=anchor aria-hidden=true href=#0x01-过程>#</a></h2><p>查了一堆类似"What DEBUG for DOS debug without parameters", &ldquo;What DEBUG open by default"之类的问题, 没找到什么答案, 搜索的过程感觉在考古, 有用信息较少.<br>尝试用-u指令反汇编阅读代码, 看不出什么有用信息.<br>然后尝试二分法寻找指令段的结尾, 也没找到什么有用信息. 在这个过程中发现<code>add [BX+SI], AL</code>指令对应的机器码是0000.<br>尝试将整个程序dump下来, 没找到怎么dump.<br>于是再次返回搜索引擎, 仔细阅读<a href=https://en.wikipedia.org/wiki/Debug_(command)#cite_note-Using_Debug-14>Debug (command) - Wikipedia</a>, 找到了这段, 他的第一句话看起来有用:</p><blockquote><p>When DEBUG is started without any parameters the DEBUG prompt, a &ldquo;-&rdquo; appears. The user can then enter one of several one or two-letter subcommands, including &ldquo;A&rdquo; to enter the assembler mode, &ldquo;D&rdquo; to perform a <a href=https://en.wikipedia.org/wiki/Hex_dump title="Hex dump">hexadecimal dump</a>, &ldquo;T&rdquo; to trace and &ldquo;U&rdquo; to unassemble (disassemble) a program in memory.<a href=https://en.wikipedia.org/wiki/Debug_(command)#cite_note-TechNet-13>13</a> DEBUG can also be used as a &ldquo;DEBUG script&rdquo; <a href=https://en.wikipedia.org/wiki/Interpreter_(computing) title="Interpreter (computing)">interpreter</a> using the following syntax.</p></blockquote><p>实际上也没什么想要的信息, 还是不知道debug打开的到底是什么. 后来开始翻下面的reference, 找到了这条:</p><blockquote><p>Sedory, Daniel B. <a href=http://thestarman.pcministry.com/asm/debug/debug.htm>&ldquo;A Guide to DEBUG&rdquo;</a>. Retrieved 2014-11-29.</p></blockquote><p>里面有一段这个:</p><p></p><blockquote><p><strong>A.</strong> When DEBUG <strong><em>starts</em></strong> with <strong><em>no</em></strong> command-line <strong><em>parameters,</em></strong> it:<br><strong>1)</strong> Allocates <em>all</em> <strong>64 KiB</strong> of the first <strong>free</strong> Memory <strong>Segment.</strong><br><strong>2)</strong> The Segment registers, CS, DS, ES and SS are all set to the value of that <strong>64 KiB</strong> Segment&rsquo;s location (<strong>CS=DS=ES=SS=<em>Segment Location</em></strong>).
<strong>3)</strong> The Instruction Pointer (IP) is set to <strong>cs:0100</strong> <em>and</em> the Stack Pointer (SP) is set to <strong>ss:FFEE</strong> (under DOS <strong>3.0</strong> or above).<br><strong>4)</strong> The registers, AX, BX, CX, DX, BP, SI and DI are <em>cleared</em> to <strong>zero</strong> along with the <strong>flag bits</strong> in the Flag Register; with <em>one exception</em>: The <strong>Interrupts</strong> Flag is <strong><em>set</em></strong> to <strong>E</strong>nable <strong>I</strong>nterrupts. (See the Appendix, <a href=https://thestarman.pcministry.com/asm/debug/8086REGs.htm#REGS>The 8086 CPU Registers</a> for more information.)</p></blockquote><p>DEBUG会分配空闲的前64KB内存段, 将CS, DS, ES, SS同时指向它也就是将它同时当作代码段, 数据段, 附加段和栈段, IP设为100, SP设为FFEE.</p><h2 id=0x02-结论>0x02 结论<a hidden class=anchor aria-hidden=true href=#0x02-结论>#</a></h2><p>所以说, DEBUG无参数打开时只是将第一段空闲内存中的无用数据作为指令序列而已, 并且作为运行在实模式下的单任务系统, DOS的内存分布相当固定, 我的DOSbox每次打开debug, 段寄存器的值都是0DBD.
另外, 上面的<a href=http://thestarman.pcministry.com/asm/debug/debug.htm>&ldquo;A Guide to DEBUG&rdquo;</a>是个不错的DEBUG祖传使用指南, 从07年更新到20年, 可能还在持续更新.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juicymio.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/>汇编语言</a></li></ul><nav class=paginav><a class=prev href=https://juicymio.github.io/posts/phoenix/><span class=title>« Prev</span><br><span>Phoenix</span>
</a><a class=next href=https://juicymio.github.io/posts/buuctfothers_shellcode/><span class=title>Next »</span><br><span>[BUUCTF]others_shellcode wp</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://juicymio.github.io/>JuicyMio's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>