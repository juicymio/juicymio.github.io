<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CVE-2023-25139 | JuicyMio's Blog</title><meta name=keywords content="pwn"><meta name=description content='0x00 背景
TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE：
30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)
0x01 分析
先看上面链接中的复现样例：
#include <stdio.h>
#include <locale.h>

int main (void)
{
  if (setlocale (LC_ALL, ""))
    {
      printf ("1234567890123:\n");
      printf ("%0+ -&#39;13ld:\n", 1234567L);
    }
  return 0;
}
在有漏洞的Glibc2.37下的输出：
1234567890123:
+1,234,567     :
输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。
这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。
由该commit修复：
Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com)
下面就通过这个修复的commit分析一下这个bug是如何产生的。
其中第266行由
width -= workend - string + prec
改成了
width -= number_length + prec_inc
这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)
  int number_length;
#ifndef COMPILE_WPRINTF
  if (use_outdigits && base == 10)
    number_length = __translated_number_width (_NL_CURRENT_LOCALE,
                                               string, workend);
  else
    number_length = workend - string;
  if (group)
    number_length += iter.separators * strlen (thousands_sep);
#else
  number_length = workend - string;
  /* All wide separators have length 1.  */
  if (group && thousands_sep != L&#39;\0&#39;)
    number_length += iter.separators;
#endif
在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。'><meta name=author content="JuicyMio"><link rel=canonical href=https://juicymio.github.io/posts/cve-2023-25139/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://juicymio.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://juicymio.github.io/posts/cve-2023-25139/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://juicymio.github.io/posts/cve-2023-25139/"><meta property="og:site_name" content="JuicyMio's Blog"><meta property="og:title" content="CVE-2023-25139"><meta property="og:description" content='0x00 背景 TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE： 30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)
0x01 分析 先看上面链接中的复现样例：
#include <stdio.h> #include <locale.h> int main (void) { if (setlocale (LC_ALL, "")) { printf ("1234567890123:\n"); printf ("%0+ -&#39;13ld:\n", 1234567L); } return 0; } 在有漏洞的Glibc2.37下的输出：
1234567890123: +1,234,567 : 输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。 这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。 由该commit修复： Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com) 下面就通过这个修复的commit分析一下这个bug是如何产生的。
其中第266行由
width -= workend - string + prec 改成了
width -= number_length + prec_inc 这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)
int number_length; #ifndef COMPILE_WPRINTF if (use_outdigits && base == 10) number_length = __translated_number_width (_NL_CURRENT_LOCALE, string, workend); else number_length = workend - string; if (group) number_length += iter.separators * strlen (thousands_sep); #else number_length = workend - string; /* All wide separators have length 1. */ if (group && thousands_sep != L&#39;\0&#39;) number_length += iter.separators; #endif 在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。'><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-11T20:45:56+08:00"><meta property="article:modified_time" content="2023-12-11T20:45:56+08:00"><meta property="article:tag" content="Pwn"><meta property="og:image" content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CVE-2023-25139"><meta name=twitter:description content='0x00 背景
TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE：
30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)
0x01 分析
先看上面链接中的复现样例：
#include <stdio.h>
#include <locale.h>

int main (void)
{
  if (setlocale (LC_ALL, ""))
    {
      printf ("1234567890123:\n");
      printf ("%0+ -&#39;13ld:\n", 1234567L);
    }
  return 0;
}
在有漏洞的Glibc2.37下的输出：
1234567890123:
+1,234,567     :
输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。
这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。
由该commit修复：
Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com)
下面就通过这个修复的commit分析一下这个bug是如何产生的。
其中第266行由
width -= workend - string + prec
改成了
width -= number_length + prec_inc
这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)
  int number_length;
#ifndef COMPILE_WPRINTF
  if (use_outdigits && base == 10)
    number_length = __translated_number_width (_NL_CURRENT_LOCALE,
                                               string, workend);
  else
    number_length = workend - string;
  if (group)
    number_length += iter.separators * strlen (thousands_sep);
#else
  number_length = workend - string;
  /* All wide separators have length 1.  */
  if (group && thousands_sep != L&#39;\0&#39;)
    number_length += iter.separators;
#endif
在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://juicymio.github.io/posts/"},{"@type":"ListItem","position":2,"name":"CVE-2023-25139","item":"https://juicymio.github.io/posts/cve-2023-25139/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CVE-2023-25139","name":"CVE-2023-25139","description":"0x00 背景 TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE： 30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)\n0x01 分析 先看上面链接中的复现样例：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;locale.h\u0026gt; int main (void) { if (setlocale (LC_ALL, \u0026#34;\u0026#34;)) { printf (\u0026#34;1234567890123:\\n\u0026#34;); printf (\u0026#34;%0+ -\u0026#39;13ld:\\n\u0026#34;, 1234567L); } return 0; } 在有漏洞的Glibc2.37下的输出：\n1234567890123: +1,234,567 : 输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。 这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。 由该commit修复： Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com) 下面就通过这个修复的commit分析一下这个bug是如何产生的。\n其中第266行由\nwidth -= workend - string + prec 改成了\nwidth -= number_length + prec_inc 这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)\nint number_length; #ifndef COMPILE_WPRINTF if (use_outdigits \u0026amp;\u0026amp; base == 10) number_length = __translated_number_width (_NL_CURRENT_LOCALE, string, workend); else number_length = workend - string; if (group) number_length += iter.separators * strlen (thousands_sep); #else number_length = workend - string; /* All wide separators have length 1. */ if (group \u0026amp;\u0026amp; thousands_sep != L\u0026#39;\\0\u0026#39;) number_length += iter.separators; #endif 在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。\n","keywords":["pwn"],"articleBody":"0x00 背景 TPCTF里和qym师傅研究了两天safehttpd这题（虽然我一直在背英语pre，没干什么活），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞），赛后看wp发现有这样一个CVE： 30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)\n0x01 分析 先看上面链接中的复现样例：\n#include #include int main (void) { if (setlocale (LC_ALL, \"\")) { printf (\"1234567890123:\\n\"); printf (\"%0+ -'13ld:\\n\", 1234567L); } return 0; } 在有漏洞的Glibc2.37下的输出：\n1234567890123: +1,234,567 : 输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。 这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。 由该commit修复： Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com) 下面就通过这个修复的commit分析一下这个bug是如何产生的。\n其中第266行由\nwidth -= workend - string + prec 改成了\nwidth -= number_length + prec_inc 这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)\nint number_length; #ifndef COMPILE_WPRINTF if (use_outdigits \u0026\u0026 base == 10) number_length = __translated_number_width (_NL_CURRENT_LOCALE, string, workend); else number_length = workend - string; if (group) number_length += iter.separators * strlen (thousands_sep); #else number_length = workend - string; /* All wide separators have length 1. */ if (group \u0026\u0026 thousands_sep != L'\\0') number_length += iter.separators; #endif 在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。\nif (!left) { width -= number_length + prec; if (number.word != 0 \u0026\u0026 alt \u0026\u0026 (base == 16 || base == 2)) /* Account for 0X, 0x, 0B or 0b hex or binary marker. */ @@ -221,7 +227,7 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ Xprintf_buffer_putc (buf, spec); } width += prec; Xprintf_buffer_pad (buf, L_('0'), width); if (octal_marker) @@ -237,6 +243,8 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ } else { if (is_negative) { Xprintf_buffer_putc (buf, L_('-')); @@ -263,9 +271,13 @@ LABEL (unsigned_number): /* Unsigned number of base BASE. */ if (octal_marker) --width; width -= workend - string + prec; ... } 另外，根据代码可以看出只有在左对齐的情况下（没有进入if(!left), 而是进入下面的else）长度计算是错误的，进行测试：\n#include #include int main() { if (setlocale(LC_ALL, \"en_US.utf8\")) { printf(\"1234567890123:\\n\"); printf(\"%+-'13ld:\\n\", 1234567L); printf(\"%0+'13ld:\\n\", 1234567L); } return 0; } 输出：\n❯ ./test 1234567890123: +1,234,567 : +0001,234,567: 可以看到确实只有左对齐时由于未减去两个千位分隔符的宽度而多填充了两个空格，右对齐时是正常的。\n0x02 其他 将prec替换成prec_inc可能是因为后续还需要用到原来的prec的值，并且这样使变量的语义更加清晰，（由于本人阅读代码水平不足没有查证。 千位分隔符和精度限制同时使用早在2.27时就有前导0缺少千位分隔符（不确定这是不是bug）以及空格的编码长度会影响补0的数量的bug。看来即使是写标准库的程序员处理这种东西也很头痛。 23432 – incorrect printf output for integers with thousands separator and precision field larger than the number of digits (needing leading zeros) (sourceware.org) 赛后复盘时发现搜索sprintf CVE/Glibc sprintf vuln关键词可以定位到这个CVE，而sprintf thousand separator vulnerability/bug/…则难以定位到，一部分原因是其它语言的sprintf造成的干扰、以及CVE的指向性才足够明确。 ","wordCount":"311","inLanguage":"en","image":"https://juicymio.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-11T20:45:56+08:00","dateModified":"2023-12-11T20:45:56+08:00","author":{"@type":"Person","name":"JuicyMio"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juicymio.github.io/posts/cve-2023-25139/"},"publisher":{"@type":"Organization","name":"JuicyMio's Blog","logo":{"@type":"ImageObject","url":"https://juicymio.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://juicymio.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://juicymio.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juicymio.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://juicymio.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://juicymio.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://juicymio.github.io/friends/ title=friends><span>friends</span></a></li><li><a href=https://juicymio.github.io/about/ title=about><span>about</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://juicymio.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://juicymio.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">CVE-2023-25139</h1><div class=post-meta><span title='2023-12-11 20:45:56 +0800 CST'>December 11, 2023</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>311 words</span>&nbsp;·&nbsp;<span>JuicyMio</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/CVE-2023-25139.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0x00-背景>0x00 背景</a></li><li><a href=#0x01-分析>0x01 分析</a></li><li><a href=#0x02-其他>0x02 其他</a></li></ul></nav></div></details></div><div class=post-content><h2 id=0x00-背景>0x00 背景<a hidden class=anchor aria-hidden=true href=#0x00-背景>#</a></h2><p>TPCTF里和qym师傅研究了两天safehttpd这题（<del>虽然我一直在背英语pre，没干什么活</del>），把整个程序可能的漏洞点翻遍了也没找到突破口的off by null如何触发（<del>实际上是测试过程中出现了重大失误，已经找对了地方却没有测试出漏洞</del>），赛后看wp发现有这样一个CVE：
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=30068">30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)</a></p><h2 id=0x01-分析>0x01 分析<a hidden class=anchor aria-hidden=true href=#0x01-分析>#</a></h2><p>先看上面链接中的复现样例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;locale.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>setlocale</span> <span class=p>(</span><span class=n>LC_ALL</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span> <span class=p>(</span><span class=s>&#34;1234567890123:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>printf</span> <span class=p>(</span><span class=s>&#34;%0+ -&#39;13ld:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1234567L</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在有漏洞的Glibc2.37下的输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=mi>1234567890123</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=mi>234</span><span class=p>,</span><span class=mi>567</span>     <span class=o>:</span>
</span></span></code></pre></div><p>输出的长度是15而不是13，因为两个千位分隔符没有被计入宽度，导致输出时多补了两个空格。
这是一个glibc 2.37里短暂出现就被迅速修复的漏洞：千位分隔符在限制长度的格式化输出时没有被正确计入宽度，导致出现了溢出。
由该commit修复：
<a href=https://github.com/bminor/glibc/commit/c980549cc6a1c03c23cc2fe3e7b0fe626a0364b0>Account for grouping in printf width (bug 30068) · bminor/glibc@c980549 (github.com)</a>
下面就通过这个修复的commit分析一下这个bug是如何产生的。</p><p>其中第266行由</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>width</span> <span class=o>-=</span> <span class=n>workend</span> <span class=o>-</span> <span class=n>string</span> <span class=o>+</span> <span class=n>prec</span>
</span></span></code></pre></div><p>改成了</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>width</span> <span class=o>-=</span> <span class=n>number_length</span> <span class=o>+</span> <span class=n>prec_inc</span>
</span></span></code></pre></div><p>这里的width变量为补足宽度限制需要添加的字符的宽度。prec和prec_inc的值是相同的，区别在于number_length和workend - string并不等同：(168-182行)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>number_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef COMPILE_WPRINTF
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span> <span class=p>(</span><span class=n>use_outdigits</span> <span class=o>&amp;&amp;</span> <span class=n>base</span> <span class=o>==</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>number_length</span> <span class=o>=</span> <span class=nf>__translated_number_width</span> <span class=p>(</span><span class=n>_NL_CURRENT_LOCALE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                               <span class=n>string</span><span class=p>,</span> <span class=n>workend</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>number_length</span> <span class=o>=</span> <span class=n>workend</span> <span class=o>-</span> <span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>group</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>number_length</span> <span class=o>+=</span> <span class=n>iter</span><span class=p>.</span><span class=n>separators</span> <span class=o>*</span> <span class=nf>strlen</span> <span class=p>(</span><span class=n>thousands_sep</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=n>number_length</span> <span class=o>=</span> <span class=n>workend</span> <span class=o>-</span> <span class=n>string</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* All wide separators have length 1.  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>group</span> <span class=o>&amp;&amp;</span> <span class=n>thousands_sep</span> <span class=o>!=</span> <span class=sa>L</span><span class=sc>&#39;\0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>number_length</span> <span class=o>+=</span> <span class=n>iter</span><span class=p>.</span><span class=n>separators</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>在上面代码的后几行可以看到number_length是原本的数字长度加上千位分隔符的长度，而workend-string没有计算千位分隔符的长度，导致了错误的长度计算。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>width</span> <span class=o>-=</span> <span class=n>number_length</span> <span class=o>+</span> <span class=n>prec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>number</span><span class=p>.</span><span class=n>word</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>alt</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>base</span> <span class=o>==</span> <span class=mi>16</span> <span class=o>||</span> <span class=n>base</span> <span class=o>==</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Account for 0X, 0x, 0B or 0b hex or binary marker.  */</span>
</span></span><span class=line><span class=cl>	<span class=err>@@</span> <span class=o>-</span><span class=mi>221</span><span class=p>,</span><span class=mi>7</span> <span class=o>+</span><span class=mi>227</span><span class=p>,</span><span class=mi>7</span> <span class=err>@@</span> <span class=nf>LABEL</span> <span class=p>(</span><span class=n>unsigned_number</span><span class=p>)</span><span class=o>:</span>      <span class=cm>/* Unsigned number of base BASE.  */</span>
</span></span><span class=line><span class=cl>          <span class=nf>Xprintf_buffer_putc</span> <span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>spec</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>width</span> <span class=o>+=</span> <span class=n>prec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>Xprintf_buffer_pad</span> <span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=nf>L_</span><span class=p>(</span><span class=sc>&#39;0&#39;</span><span class=p>),</span> <span class=n>width</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>octal_marker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=err>@@</span> <span class=o>-</span><span class=mi>237</span><span class=p>,</span><span class=mi>6</span> <span class=o>+</span><span class=mi>243</span><span class=p>,</span><span class=mi>8</span> <span class=err>@@</span> <span class=nf>LABEL</span> <span class=p>(</span><span class=n>unsigned_number</span><span class=p>)</span><span class=o>:</span>      <span class=cm>/* Unsigned number of base BASE.  */</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>is_negative</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>Xprintf_buffer_putc</span> <span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=nf>L_</span><span class=p>(</span><span class=sc>&#39;-&#39;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=err>@@</span> <span class=o>-</span><span class=mi>263</span><span class=p>,</span><span class=mi>9</span> <span class=o>+</span><span class=mi>271</span><span class=p>,</span><span class=mi>13</span> <span class=err>@@</span> <span class=nf>LABEL</span> <span class=p>(</span><span class=n>unsigned_number</span><span class=p>)</span><span class=o>:</span>      <span class=cm>/* Unsigned number of base BASE.  */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>octal_marker</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>--</span><span class=n>width</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>width</span> <span class=o>-=</span> <span class=n>workend</span> <span class=o>-</span> <span class=n>string</span> <span class=o>+</span> <span class=n>prec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	  <span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>另外，根据代码可以看出只有在左对齐的情况下（没有进入if(!left), 而是进入下面的else）长度计算是错误的，进行测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;locale.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>setlocale</span><span class=p>(</span><span class=n>LC_ALL</span><span class=p>,</span> <span class=s>&#34;en_US.utf8&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;1234567890123:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%+-&#39;13ld:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1234567L</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%0+&#39;13ld:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1234567L</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>❯</span> <span class=p>.</span><span class=o>/</span><span class=n>test</span>
</span></span><span class=line><span class=cl><span class=mi>1234567890123</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=mi>234</span><span class=p>,</span><span class=mi>567</span>     <span class=o>:</span>
</span></span><span class=line><span class=cl><span class=o>+</span><span class=mo>0001</span><span class=p>,</span><span class=mi>234</span><span class=p>,</span><span class=mi>567</span><span class=o>:</span>
</span></span></code></pre></div><p>可以看到确实只有左对齐时由于未减去两个千位分隔符的宽度而多填充了两个空格，右对齐时是正常的。</p><h2 id=0x02-其他>0x02 其他<a hidden class=anchor aria-hidden=true href=#0x02-其他>#</a></h2><ol><li>将prec替换成prec_inc可能是因为后续还需要用到原来的prec的值，并且这样使变量的语义更加清晰，（由于本人阅读代码水平不足没有查证。</li><li>千位分隔符和精度限制同时使用早在2.27时就有前导0缺少千位分隔符（不确定这是不是bug）以及空格的编码长度会影响补0的数量的bug。看来即使是写标准库的程序员处理这种东西也很头痛。
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=23432">23432 – incorrect printf output for integers with thousands separator and precision field larger than the number of digits (needing leading zeros) (sourceware.org)</a></li><li>赛后复盘时发现搜索sprintf CVE/Glibc sprintf vuln关键词可以定位到这个CVE，而sprintf thousand separator vulnerability/bug/&mldr;则难以定位到，一部分原因是其它语言的sprintf造成的干扰、以及CVE的指向性才足够明确。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://juicymio.github.io/tags/pwn/>Pwn</a></li></ul><nav class=paginav><a class=prev href=https://juicymio.github.io/posts/io_pointers_on_bss/><span class=title>« Prev</span><br><span>为什么bss上有时会有stdin,stdout,stderr指针</span>
</a><a class=next href=https://juicymio.github.io/posts/wsl2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/><span class=title>Next »</span><br><span>WSL2中C/C++开发环境配置</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://juicymio.github.io/>JuicyMio's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>